
ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: [ÐºÐ¾Ñ€ÐµÐ½ÑŒ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ð°]

  ðŸ“„ Ð¤Ð°Ð¹Ð»: agent.py
    import pygame
    import math
    import random
    from constants import *
    class Agent:
        def __init__(self, x, y):
        def get_vision_params(self):
        def update(self, delta_time):
        def update_satisfaction_from_hunger(self):
        def decrease_hunger(self):
        def avoid_walls(self):
        def look_for_food(self):
            from world import food_items
        def evaluate_satisfaction(self):
        def get_position(self):
        def get_lifetime(self):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: constants.py
    WHITE = (255, 255, 255)
    BLACK = (0, 0, 0)
    FOOD_COLOR = (255, 0, 0)
    AGENT_COLOR_DEFAULT = (0, 255, 0)
    VISION_COLOR = (0, 150, 255, 50)
    MODAL_BG = (50, 50, 50)
    BUTTON_COLOR = (100, 100, 100)
    BUTTON_HOVER_COLOR = (150, 150, 150)
    BUTTON_ACTIVE_COLOR = (0, 150, 0)
    CLOSE_COLOR = (180, 50, 50)
    MAP_WIDTH = 820
    HEIGHT = 600
    MENU_WIDTH = 1000
    WIDTH = MAP_WIDTH + MENU_WIDTH
    AGENT_RADIUS = 10
    FOOD_RADIUS = 4
    BORDER_THICKNESS = 5
    VISION_DISTANCE = AGENT_RADIUS * 4
    VISION_ANGLE = 30
    BASE_DECREASE_INTERVAL = 5000
    SATISFACTION_INTERVAL = 5.0  # ÑÐµÐºÑƒÐ½Ð´Ñ‹ Ð¼ÐµÐ¶Ð´Ñƒ Ð¾Ñ†ÐµÐ½ÐºÐ°Ð¼Ð¸ Â«Ð¼Ð¾ÐµÐ³Ð¾ ÑƒÐ´Ð¾Ð²Ð¾Ð»ÑŒÑÑ‚Ð²Ð¸ÑÂ»
    AGENT_COST = 100
    FOOD_COST = 5

  ðŸ“„ Ð¤Ð°Ð¹Ð»: main.py
    import pygame
    import sys
    import random
    from constants import *
    from agent import Agent
    import world
    from ui import (

  ðŸ“„ Ð¤Ð°Ð¹Ð»: semantic_summary.py
    import os
    import re
    import sys
        import pyperclip
        CLIPBOARD_AVAILABLE = True
        CLIPBOARD_AVAILABLE = False
    def extract_semantic_structure(root_path, output_file="semantic_summary.txt"):
        def is_relevant_line(line):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: ui.py
    import pygame
    import math
    from constants import *
    from utils import gradient_color
    def draw_speed_buttons(screen, font, button_rects, active_label):
    def draw_add_buttons(screen, font, button_rects, active_mode, score_y):
    def draw_score(screen, score):
    def draw_menu_button(screen, font, mouse_pos, is_active):
    def draw_menu_modal(screen, font, mouse_pos, current_mode, current_add_mode):
    def draw_agent_modal(screen, font, agent, modal_rect, close_rect):
    def draw_agent(screen, agent, color_mode, max_lifetime):
    def draw_vision(screen, agent):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: utils.py
    def gradient_color(value: float, max_value: float) -> tuple:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: world.py
    import pygame
    import random
    from constants import MAP_WIDTH, HEIGHT, FOOD_RADIUS
    from agent import Agent
    def spawn_food(count=10):
    def update_food(agents, delta_time, game_speed_multiplier, global_score):
        from constants import BASE_DECREASE_INTERVAL

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .idea

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .idea\inspectionProfiles

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _virtualenv.py
    from __future__ import annotations
    import os
    import sys
    VIRTUALENV_PATCH_FILE = os.path.join(__file__)
    def patch_dist(dist):
        def parse_config_files(self, *args, **kwargs):
    _DISTUTILS_PATCH = "distutils.dist", "setuptools.dist"
    class _Finder:
        def find_spec(self, fullname, path, target=None):  # noqa: ARG002
                    import threading  # noqa: PLC0415
                from functools import partial  # noqa: PLC0415
                from importlib.util import find_spec  # noqa: PLC0415
        @staticmethod
        def exec_module(old, module):
        @staticmethod
        def load_module(old, name):

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from typing import List, Optional
    def main(args: Optional[List[str]] = None) -> int:
        from pip._internal.utils.entrypoints import _wrapper

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __main__.py
    import os
    import sys
        from pip._internal.cli.main import main as _main

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __pip-runner__.py
    import sys
    PYTHON_REQUIRES = (3, 8)
    def version_str(version):  # type: ignore
    import runpy  # noqa: E402
    from importlib.machinery import PathFinder  # noqa: E402
    from os.path import dirname  # noqa: E402
    PIP_SOURCES_ROOT = dirname(dirname(__file__))
    class PipImportRedirectingFinder:
        @classmethod
        def find_spec(self, fullname, path=None, target=None):  # type: ignore

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal

  ðŸ“„ Ð¤Ð°Ð¹Ð»: build_env.py
    import logging
    import os
    import pathlib
    import site
    import sys
    import textwrap
    from collections import OrderedDict
    from types import TracebackType
    from typing import TYPE_CHECKING, Iterable, List, Optional, Set, Tuple, Type, Union
    from pip._vendor.packaging.version import Version
    from pip import __file__ as pip_location
    from pip._internal.cli.spinners import open_spinner
    from pip._internal.locations import get_platlib, get_purelib, get_scheme
    from pip._internal.metadata import get_default_environment, get_environment
    from pip._internal.utils.logging import VERBOSE
    from pip._internal.utils.packaging import get_requirement
    from pip._internal.utils.subprocess import call_subprocess
    from pip._internal.utils.temp_dir import TempDirectory, tempdir_kinds
        from pip._internal.index.package_finder import PackageFinder
    def _dedup(a: str, b: str) -> Union[Tuple[str], Tuple[str, str]]:
    class _Prefix:
        def __init__(self, path: str) -> None:
    def get_runnable_pip() -> str:
    def _get_system_sitepackages() -> Set[str]:
    class BuildEnvironment:
        def __init__(self) -> None:
                    import os, site, sys
        def __enter__(self) -> None:
        def __exit__(
        def check_requirements(
        def install_requirements(
        @staticmethod
        def _install_requirements(
    class NoOpBuildEnvironment(BuildEnvironment):
        def __init__(self) -> None:
        def __enter__(self) -> None:
        def __exit__(
        def cleanup(self) -> None:
        def install_requirements(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: cache.py
    import hashlib
    import json
    import logging
    import os
    from pathlib import Path
    from typing import Any, Dict, List, Optional
    from pip._vendor.packaging.tags import Tag, interpreter_name, interpreter_version
    from pip._vendor.packaging.utils import canonicalize_name
    from pip._internal.exceptions import InvalidWheelFilename
    from pip._internal.models.direct_url import DirectUrl
    from pip._internal.models.link import Link
    from pip._internal.models.wheel import Wheel
    from pip._internal.utils.temp_dir import TempDirectory, tempdir_kinds
    from pip._internal.utils.urls import path_to_url
    ORIGIN_JSON_NAME = "origin.json"
    def _hash_dict(d: Dict[str, str]) -> str:
    class Cache:
        def __init__(self, cache_dir: str) -> None:
        def _get_cache_path_parts(self, link: Link) -> List[str]:
        def _get_candidates(self, link: Link, canonical_package_name: str) -> List[Any]:
        def get_path_for_link(self, link: Link) -> str:
        def get(
    class SimpleWheelCache(Cache):
        def __init__(self, cache_dir: str) -> None:
        def get_path_for_link(self, link: Link) -> str:
        def get(
    class EphemWheelCache(SimpleWheelCache):
        def __init__(self) -> None:
    class CacheEntry:
        def __init__(
    class WheelCache(Cache):
        def __init__(self, cache_dir: str) -> None:
        def get_path_for_link(self, link: Link) -> str:
        def get_ephem_path_for_link(self, link: Link) -> str:
        def get(
        def get_cache_entry(
        @staticmethod
        def record_download_origin(cache_dir: str, download_info: DirectUrl) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: configuration.py
    import configparser
    import locale
    import os
    import sys
    from typing import Any, Dict, Iterable, List, NewType, Optional, Tuple
    from pip._internal.exceptions import (
    from pip._internal.utils import appdirs
    from pip._internal.utils.compat import WINDOWS
    from pip._internal.utils.logging import getLogger
    from pip._internal.utils.misc import ensure_dir, enum
    CONFIG_BASENAME = "pip.ini" if WINDOWS else "pip.conf"
    ENV_NAMES_IGNORED = "version", "help"
        USER="user",  # User Specific
        GLOBAL="global",  # System Wide
        SITE="site",  # [Virtual] Environment Specific
        ENV="env",  # from PIP_CONFIG_FILE
        ENV_VAR="env-var",  # from Environment Variables
    OVERRIDE_ORDER = kinds.GLOBAL, kinds.USER, kinds.SITE, kinds.ENV, kinds.ENV_VAR
    VALID_LOAD_ONLY = kinds.USER, kinds.GLOBAL, kinds.SITE
    def _normalize_name(name: str) -> str:
    def _disassemble_key(name: str) -> List[str]:
    def get_configuration_files() -> Dict[Kind, List[str]]:
    class Configuration:
        def __init__(self, isolated: bool, load_only: Optional[Kind] = None) -> None:
        def load(self) -> None:
        def get_file_to_edit(self) -> Optional[str]:
        def items(self) -> Iterable[Tuple[str, Any]]:
        def get_value(self, key: str) -> Any:
        def set_value(self, key: str, value: Any) -> None:
        def unset_value(self, key: str) -> None:
        def save(self) -> None:
        def _ensure_have_load_only(self) -> None:
        @property
        def _dictionary(self) -> Dict[str, Any]:
        def _load_config_files(self) -> None:
        def _load_file(self, variant: Kind, fname: str) -> RawConfigParser:
        def _construct_parser(self, fname: str) -> RawConfigParser:
        def _load_environment_vars(self) -> None:
        def _normalized_keys(
        def get_environ_vars(self) -> Iterable[Tuple[str, str]]:
        def iter_config_files(self) -> Iterable[Tuple[Kind, List[str]]]:
        def get_values_in_config(self, variant: Kind) -> Dict[str, Any]:
        def _get_parser_to_modify(self) -> Tuple[str, RawConfigParser]:
        def _mark_as_modified(self, fname: str, parser: RawConfigParser) -> None:
        def __repr__(self) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: exceptions.py
    import configparser
    import contextlib
    import locale
    import logging
    import pathlib
    import re
    import sys
    from itertools import chain, groupby, repeat
    from typing import TYPE_CHECKING, Dict, Iterator, List, Literal, Optional, Union
    from pip._vendor.packaging.requirements import InvalidRequirement
    from pip._vendor.packaging.version import InvalidVersion
    from pip._vendor.rich.console import Console, ConsoleOptions, RenderResult
    from pip._vendor.rich.markup import escape
    from pip._vendor.rich.text import Text
        from hashlib import _Hash
        from pip._vendor.requests.models import Request, Response
        from pip._internal.metadata import BaseDistribution
        from pip._internal.req.req_install import InstallRequirement
    def _is_kebab_case(s: str) -> bool:
    def _prefix_with_indent(
    class PipError(Exception):
    class DiagnosticPipError(PipError):
        def __init__(
        def __repr__(self) -> str:
        def __rich_console__(
    class ConfigurationError(PipError):
    class InstallationError(PipError):
    class MissingPyProjectBuildRequires(DiagnosticPipError):
        def __init__(self, *, package: str) -> None:
    class InvalidPyProjectBuildRequires(DiagnosticPipError):
        def __init__(self, *, package: str, reason: str) -> None:
    class NoneMetadataError(PipError):
        def __init__(
        def __str__(self) -> str:
    class UserInstallationInvalid(InstallationError):
        def __str__(self) -> str:
    class InvalidSchemeCombination(InstallationError):
        def __str__(self) -> str:
    class DistributionNotFound(InstallationError):
    class RequirementsFileParseError(InstallationError):
    class BestVersionAlreadyInstalled(PipError):
    class BadCommand(PipError):
    class CommandError(PipError):
    class PreviousBuildDirError(PipError):
    class NetworkConnectionError(PipError):
        def __init__(
        def __str__(self) -> str:
    class InvalidWheelFilename(InstallationError):
    class UnsupportedWheel(InstallationError):
    class InvalidWheel(InstallationError):
        def __init__(self, location: str, name: str):
        def __str__(self) -> str:
    class MetadataInconsistent(InstallationError):
        def __init__(
        def __str__(self) -> str:
    class MetadataInvalid(InstallationError):
        def __init__(self, ireq: "InstallRequirement", error: str) -> None:
        def __str__(self) -> str:
    class InstallationSubprocessError(DiagnosticPipError, InstallationError):
        def __init__(
        def __str__(self) -> str:
    class MetadataGenerationFailed(InstallationSubprocessError, InstallationError):
        def __init__(
        def __str__(self) -> str:
    class HashErrors(InstallationError):
        def __init__(self) -> None:
        def append(self, error: "HashError") -> None:
        def __str__(self) -> str:
        def __bool__(self) -> bool:
    class HashError(InstallationError):
        def body(self) -> str:
        def __str__(self) -> str:
        def _requirement_name(self) -> str:
    class VcsHashUnsupported(HashError):
    class DirectoryUrlHashUnsupported(HashError):
    class HashMissing(HashError):
        def __init__(self, gotten_hash: str) -> None:
        def body(self) -> str:
            from pip._internal.utils.hashes import FAVORITE_HASH
    class HashUnpinned(HashError):
    class HashMismatch(HashError):
        def __init__(self, allowed: Dict[str, List[str]], gots: Dict[str, "_Hash"]) -> None:
        def body(self) -> str:
        def _hash_comparison(self) -> str:
            def hash_then_or(hash_name: str) -> "chain[str]":
    class UnsupportedPythonVersion(InstallationError):
    class ConfigurationFileCouldNotBeLoaded(ConfigurationError):
        def __init__(
        def __str__(self) -> str:
    _DEFAULT_EXTERNALLY_MANAGED_ERROR = f"""\
    class ExternallyManagedEnvironment(DiagnosticPipError):
        def __init__(self, error: Optional[str]) -> None:
        @staticmethod
        def _iter_externally_managed_error_keys() -> Iterator[str]:
        @classmethod
        def from_config(
                from pip._internal.utils._log import VERBOSE
    class UninstallMissingRecord(DiagnosticPipError):
        def __init__(self, *, distribution: "BaseDistribution") -> None:
    class LegacyDistutilsInstall(DiagnosticPipError):
        def __init__(self, *, distribution: "BaseDistribution") -> None:
    class InvalidInstalledPackage(DiagnosticPipError):
        def __init__(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: main.py
    from typing import List, Optional
    def main(args: Optional[List[str]] = None) -> int:
        from pip._internal.utils.entrypoints import _wrapper

  ðŸ“„ Ð¤Ð°Ð¹Ð»: pyproject.py
    import importlib.util
    import os
    import sys
    from collections import namedtuple
    from typing import Any, List, Optional
        import tomllib
        from pip._vendor import tomli as tomllib
    from pip._vendor.packaging.requirements import InvalidRequirement
    from pip._internal.exceptions import (
    from pip._internal.utils.packaging import get_requirement
    def _is_list_of_str(obj: Any) -> bool:
    def make_pyproject_path(unpacked_source_directory: str) -> str:
    def load_pyproject_toml(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: self_outdated_check.py
    import datetime
    import functools
    import hashlib
    import json
    import logging
    import optparse
    import os.path
    import sys
    from dataclasses import dataclass
    from typing import Any, Callable, Dict, Optional
    from pip._vendor.packaging.version import Version
    from pip._vendor.packaging.version import parse as parse_version
    from pip._vendor.rich.console import Group
    from pip._vendor.rich.markup import escape
    from pip._vendor.rich.text import Text
    from pip._internal.index.collector import LinkCollector
    from pip._internal.index.package_finder import PackageFinder
    from pip._internal.metadata import get_default_environment
    from pip._internal.models.selection_prefs import SelectionPreferences
    from pip._internal.network.session import PipSession
    from pip._internal.utils.compat import WINDOWS
    from pip._internal.utils.entrypoints import (
    from pip._internal.utils.filesystem import adjacent_tmp_file, check_path_owner, replace
    from pip._internal.utils.misc import (
    _WEEK = datetime.timedelta(days=7)
    def _get_statefile_name(key: str) -> str:
    def _convert_date(isodate: str) -> datetime.datetime:
    class SelfCheckState:
        def __init__(self, cache_dir: str) -> None:
        @property
        def key(self) -> str:
        def get(self, current_time: datetime.datetime) -> Optional[str]:
        def set(self, pypi_version: str, current_time: datetime.datetime) -> None:
    @dataclass
    class UpgradePrompt:
        def __rich__(self) -> Group:
    def was_installed_by_pip(pkg: str) -> bool:
    def _get_current_remote_pip_version(
    def _self_version_check_logic(
    def pip_self_version_check(session: PipSession, options: optparse.Values) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: wheel_builder.py
    import logging
    import os.path
    import re
    import shutil
    from typing import Iterable, List, Optional, Tuple
    from pip._vendor.packaging.utils import canonicalize_name, canonicalize_version
    from pip._vendor.packaging.version import InvalidVersion, Version
    from pip._internal.cache import WheelCache
    from pip._internal.exceptions import InvalidWheelFilename, UnsupportedWheel
    from pip._internal.metadata import FilesystemWheel, get_wheel_distribution
    from pip._internal.models.link import Link
    from pip._internal.models.wheel import Wheel
    from pip._internal.operations.build.wheel import build_wheel_pep517
    from pip._internal.operations.build.wheel_editable import build_wheel_editable
    from pip._internal.operations.build.wheel_legacy import build_wheel_legacy
    from pip._internal.req.req_install import InstallRequirement
    from pip._internal.utils.logging import indent_log
    from pip._internal.utils.misc import ensure_dir, hash_file
    from pip._internal.utils.setuptools_build import make_setuptools_clean_args
    from pip._internal.utils.subprocess import call_subprocess
    from pip._internal.utils.temp_dir import TempDirectory
    from pip._internal.utils.urls import path_to_url
    from pip._internal.vcs import vcs
    def _contains_egg_info(s: str) -> bool:
    def _should_build(
    def should_build_for_wheel_command(
    def should_build_for_install_command(
    def _should_cache(
    def _get_cache_dir(
    def _verify_one(req: InstallRequirement, wheel_path: str) -> None:
    def _build_one(
    def _build_one_inside_env(
    def _clean_one_legacy(req: InstallRequirement, global_options: List[str]) -> bool:
    def build(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from typing import List, Optional
    from pip._internal.utils import _log
    def main(args: Optional[List[str]] = None) -> int:
        from pip._internal.utils.entrypoints import _wrapper

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\cli

  ðŸ“„ Ð¤Ð°Ð¹Ð»: autocompletion.py
    import optparse
    import os
    import sys
    from itertools import chain
    from typing import Any, Iterable, List, Optional
    from pip._internal.cli.main_parser import create_main_parser
    from pip._internal.commands import commands_dict, create_command
    from pip._internal.metadata import get_default_environment
    def autocomplete() -> None:
    def get_path_completion_type(
    def auto_complete_paths(current: str, completion_type: str) -> Iterable[str]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: base_command.py
    import logging
    import logging.config
    import optparse
    import os
    import sys
    import traceback
    from optparse import Values
    from typing import List, Optional, Tuple
    from pip._vendor.rich import reconfigure
    from pip._vendor.rich import traceback as rich_traceback
    from pip._internal.cli import cmdoptions
    from pip._internal.cli.command_context import CommandContextMixIn
    from pip._internal.cli.parser import ConfigOptionParser, UpdatingDefaultsHelpFormatter
    from pip._internal.cli.status_codes import (
    from pip._internal.exceptions import (
    from pip._internal.utils.deprecation import deprecated
    from pip._internal.utils.filesystem import check_path_owner
    from pip._internal.utils.logging import BrokenStdoutLoggingError, setup_logging
    from pip._internal.utils.misc import get_prog, normalize_path
    from pip._internal.utils.temp_dir import TempDirectoryTypeRegistry as TempDirRegistry
    from pip._internal.utils.temp_dir import global_tempdir_manager, tempdir_registry
    from pip._internal.utils.virtualenv import running_under_virtualenv
    class Command(CommandContextMixIn):
        def __init__(self, name: str, summary: str, isolated: bool = False) -> None:
        def add_options(self) -> None:
        def handle_pip_version_check(self, options: Values) -> None:
        def run(self, options: Values, args: List[str]) -> int:
        def _run_wrapper(self, level_number: int, options: Values, args: List[str]) -> int:
            def _inner_run() -> int:
        def parse_args(self, args: List[str]) -> Tuple[Values, List[str]]:
        def main(self, args: List[str]) -> int:
        def _main(self, args: List[str]) -> int:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: cmdoptions.py
    import importlib.util
    import logging
    import os
    import textwrap
    from functools import partial
    from optparse import SUPPRESS_HELP, Option, OptionGroup, OptionParser, Values
    from textwrap import dedent
    from typing import Any, Callable, Dict, Optional, Tuple
    from pip._vendor.packaging.utils import canonicalize_name
    from pip._internal.cli.parser import ConfigOptionParser
    from pip._internal.exceptions import CommandError
    from pip._internal.locations import USER_CACHE_DIR, get_src_prefix
    from pip._internal.models.format_control import FormatControl
    from pip._internal.models.index import PyPI
    from pip._internal.models.target_python import TargetPython
    from pip._internal.utils.hashes import STRONG_HASHES
    from pip._internal.utils.misc import strtobool
    def raise_option_error(parser: OptionParser, option: Option, msg: str) -> None:
    def make_option_group(group: Dict[str, Any], parser: ConfigOptionParser) -> OptionGroup:
    def check_dist_restriction(options: Values, check_target: bool = False) -> None:
    def _path_option_check(option: Option, opt: str, value: str) -> str:
    def _package_name_option_check(option: Option, opt: str, value: str) -> str:
    class PipOption(Option):
        TYPES = Option.TYPES + ("path", "package_name")
        TYPE_CHECKER = Option.TYPE_CHECKER.copy()
    def exists_action() -> Option:
    def extra_index_url() -> Option:
    def find_links() -> Option:
    def trusted_host() -> Option:
    def constraints() -> Option:
    def requirements() -> Option:
    def editable() -> Option:
    def _handle_src(option: Option, opt_str: str, value: str, parser: OptionParser) -> None:
    def _get_format_control(values: Values, option: Option) -> Any:
    def _handle_no_binary(
    def _handle_only_binary(
    def no_binary() -> Option:
    def only_binary() -> Option:
    def _convert_python_version(value: str) -> Tuple[Tuple[int, ...], Optional[str]]:
    def _handle_python_version(
    def add_target_python_options(cmd_opts: OptionGroup) -> None:
    def make_target_python(options: Values) -> TargetPython:
    def prefer_binary() -> Option:
    def _handle_no_cache_dir(
    def _handle_no_use_pep517(
    def _handle_config_settings(
    def _handle_merge_hash(
    def check_list_path_option(options: Values) -> None:
    ALWAYS_ENABLED_FEATURES = [

  ðŸ“„ Ð¤Ð°Ð¹Ð»: command_context.py
    from contextlib import ExitStack, contextmanager
    from typing import ContextManager, Generator, TypeVar
    _T = TypeVar("_T", covariant=True)
    class CommandContextMixIn:
        def __init__(self) -> None:
        @contextmanager
        def main_context(self) -> Generator[None, None, None]:
        def enter_context(self, context_provider: ContextManager[_T]) -> _T:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: index_command.py
    import logging
    import os
    import sys
    from optparse import Values
    from typing import TYPE_CHECKING, List, Optional
    from pip._vendor import certifi
    from pip._internal.cli.base_command import Command
    from pip._internal.cli.command_context import CommandContextMixIn
        from ssl import SSLContext
        from pip._internal.network.session import PipSession
    def _create_truststore_ssl_context() -> Optional["SSLContext"]:
            import ssl
            from pip._vendor import truststore
    class SessionCommandMixin(CommandContextMixIn):
        def __init__(self) -> None:
        @classmethod
        def _get_index_urls(cls, options: Values) -> Optional[List[str]]:
        def get_default_session(self, options: Values) -> "PipSession":
        def _build_session(
            from pip._internal.network.session import PipSession
    def _pip_self_version_check(session: "PipSession", options: Values) -> None:
        from pip._internal.self_outdated_check import pip_self_version_check as check
    class IndexGroupCommand(Command, SessionCommandMixin):
        def handle_pip_version_check(self, options: Values) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: main.py
    import locale
    import logging
    import os
    import sys
    import warnings
    from typing import List, Optional
    from pip._internal.cli.autocompletion import autocomplete
    from pip._internal.cli.main_parser import parse_command
    from pip._internal.commands import create_command
    from pip._internal.exceptions import PipError
    from pip._internal.utils import deprecation
    def main(args: Optional[List[str]] = None) -> int:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: main_parser.py
    import os
    import subprocess
    import sys
    from typing import List, Optional, Tuple
    from pip._internal.build_env import get_runnable_pip
    from pip._internal.cli import cmdoptions
    from pip._internal.cli.parser import ConfigOptionParser, UpdatingDefaultsHelpFormatter
    from pip._internal.commands import commands_dict, get_similar_commands
    from pip._internal.exceptions import CommandError
    from pip._internal.utils.misc import get_pip_version, get_prog
    def create_main_parser() -> ConfigOptionParser:
    def identify_python_interpreter(python: str) -> Optional[str]:
    def parse_command(args: List[str]) -> Tuple[str, List[str]]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: parser.py
    import logging
    import optparse
    import shutil
    import sys
    import textwrap
    from contextlib import suppress
    from typing import Any, Dict, Generator, List, NoReturn, Optional, Tuple
    from pip._internal.cli.status_codes import UNKNOWN_ERROR
    from pip._internal.configuration import Configuration, ConfigurationError
    from pip._internal.utils.misc import redact_auth_from_url, strtobool
    class PrettyHelpFormatter(optparse.IndentedHelpFormatter):
        def __init__(self, *args: Any, **kwargs: Any) -> None:
        def format_option_strings(self, option: optparse.Option) -> str:
        def _format_option_strings(
        def format_heading(self, heading: str) -> str:
        def format_usage(self, usage: str) -> str:
        def format_description(self, description: Optional[str]) -> str:
        def format_epilog(self, epilog: Optional[str]) -> str:
        def indent_lines(self, text: str, indent: str) -> str:
    class UpdatingDefaultsHelpFormatter(PrettyHelpFormatter):
        def expand_default(self, option: optparse.Option) -> str:
    class CustomOptionParser(optparse.OptionParser):
        def insert_option_group(
        @property
        def option_list_all(self) -> List[optparse.Option]:
    class ConfigOptionParser(CustomOptionParser):
        def __init__(
        def check_default(self, option: optparse.Option, key: str, val: Any) -> Any:
        def _get_ordered_configuration_items(
        def _update_defaults(self, defaults: Dict[str, Any]) -> Dict[str, Any]:
        def get_default_values(self) -> optparse.Values:
        def error(self, msg: str) -> NoReturn:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: progress_bars.py
    import functools
    import sys
    from typing import Callable, Generator, Iterable, Iterator, Optional, Tuple
    from pip._vendor.rich.progress import (
    from pip._internal.cli.spinners import RateLimiter
    from pip._internal.utils.logging import get_indentation
    def _rich_progress_bar(
    def _raw_progress_bar(
        def write_progress(current: int, total: int) -> None:
    def get_download_progress_renderer(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: req_command.py
    import logging
    from functools import partial
    from optparse import Values
    from typing import Any, List, Optional, Tuple
    from pip._internal.cache import WheelCache
    from pip._internal.cli import cmdoptions
    from pip._internal.cli.index_command import IndexGroupCommand
    from pip._internal.cli.index_command import SessionCommandMixin as SessionCommandMixin
    from pip._internal.exceptions import CommandError, PreviousBuildDirError
    from pip._internal.index.collector import LinkCollector
    from pip._internal.index.package_finder import PackageFinder
    from pip._internal.models.selection_prefs import SelectionPreferences
    from pip._internal.models.target_python import TargetPython
    from pip._internal.network.session import PipSession
    from pip._internal.operations.build.build_tracker import BuildTracker
    from pip._internal.operations.prepare import RequirementPreparer
    from pip._internal.req.constructors import (
    from pip._internal.req.req_file import parse_requirements
    from pip._internal.req.req_install import InstallRequirement
    from pip._internal.resolution.base import BaseResolver
    from pip._internal.utils.temp_dir import (
    KEEPABLE_TEMPDIR_TYPES = [
    def with_cleanup(func: Any) -> Any:
        def configure_tempdir_registry(registry: TempDirectoryTypeRegistry) -> None:
        def wrapper(
    class RequirementCommand(IndexGroupCommand):
        def __init__(self, *args: Any, **kw: Any) -> None:
        @staticmethod
        def determine_resolver_variant(options: Values) -> str:
        @classmethod
        def make_requirement_preparer(
        @classmethod
        def make_resolver(
                import pip._internal.resolution.resolvelib.resolver
            import pip._internal.resolution.legacy.resolver
        def get_requirements(
        @staticmethod
        def trace_basic_info(finder: PackageFinder) -> None:
        def _build_package_finder(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: spinners.py
    import contextlib
    import itertools
    import logging
    import sys
    import time
    from typing import IO, Generator, Optional
    from pip._internal.utils.compat import WINDOWS
    from pip._internal.utils.logging import get_indentation
    class SpinnerInterface:
        def spin(self) -> None:
        def finish(self, final_status: str) -> None:
    class InteractiveSpinner(SpinnerInterface):
        def __init__(
        def _write(self, status: str) -> None:
        def spin(self) -> None:
        def finish(self, final_status: str) -> None:
    class NonInteractiveSpinner(SpinnerInterface):
        def __init__(self, message: str, min_update_interval_seconds: float = 60.0) -> None:
        def _update(self, status: str) -> None:
        def spin(self) -> None:
        def finish(self, final_status: str) -> None:
    class RateLimiter:
        def __init__(self, min_update_interval_seconds: float) -> None:
        def ready(self) -> bool:
        def reset(self) -> None:
    @contextlib.contextmanager
    def open_spinner(message: str) -> Generator[SpinnerInterface, None, None]:
    HIDE_CURSOR = "\x1b[?25l"
    SHOW_CURSOR = "\x1b[?25h"
    @contextlib.contextmanager
    def hidden_cursor(file: IO[str]) -> Generator[None, None, None]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: status_codes.py
    SUCCESS = 0
    ERROR = 1
    UNKNOWN_ERROR = 2
    VIRTUALENV_NOT_FOUND = 3
    PREVIOUS_BUILD_DIR_ERROR = 4
    NO_MATCHES_FOUND = 23

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\commands

  ðŸ“„ Ð¤Ð°Ð¹Ð»: cache.py
    import os
    import textwrap
    from optparse import Values
    from typing import Any, List
    from pip._internal.cli.base_command import Command
    from pip._internal.cli.status_codes import ERROR, SUCCESS
    from pip._internal.exceptions import CommandError, PipError
    from pip._internal.utils import filesystem
    from pip._internal.utils.logging import getLogger
    from pip._internal.utils.misc import format_size
    class CacheCommand(Command):
        def add_options(self) -> None:
        def run(self, options: Values, args: List[str]) -> int:
        def get_cache_dir(self, options: Values, args: List[Any]) -> None:
        def get_cache_info(self, options: Values, args: List[Any]) -> None:
        def list_cache_items(self, options: Values, args: List[Any]) -> None:
        def format_for_human(self, files: List[str]) -> None:
        def format_for_abspath(self, files: List[str]) -> None:
        def remove_cache_items(self, options: Values, args: List[Any]) -> None:
        def purge_cache(self, options: Values, args: List[Any]) -> None:
        def _cache_dir(self, options: Values, subdir: str) -> str:
        def _find_http_files(self, options: Values) -> List[str]:
        def _find_wheels(self, options: Values, pattern: str) -> List[str]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: check.py
    import logging
    from optparse import Values
    from typing import List
    from pip._internal.cli.base_command import Command
    from pip._internal.cli.status_codes import ERROR, SUCCESS
    from pip._internal.metadata import get_default_environment
    from pip._internal.operations.check import (
    from pip._internal.utils.compatibility_tags import get_supported
    from pip._internal.utils.misc import write_output
    class CheckCommand(Command):
        def run(self, options: Values, args: List[str]) -> int:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: completion.py
    import sys
    import textwrap
    from optparse import Values
    from typing import List
    from pip._internal.cli.base_command import Command
    from pip._internal.cli.status_codes import SUCCESS
    from pip._internal.utils.misc import get_prog
    BASE_COMPLETION = """
    COMPLETION_SCRIPTS = {
                COMPREPLY=( $( COMP_WORDS="${{COMP_WORDS[*]}}" \\
                               COMP_CWORD=$COMP_CWORD \\
                               PIP_AUTO_COMPLETE=1 $1 2>/dev/null ) )
                         COMP_CWORD=$((CURRENT-1)) \\
                         PIP_AUTO_COMPLETE=1 $words[1] 2>/dev/null )
    class CompletionCommand(Command):
        def add_options(self) -> None:
        def run(self, options: Values, args: List[str]) -> int:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: configuration.py
    import logging
    import os
    import subprocess
    from optparse import Values
    from typing import Any, List, Optional
    from pip._internal.cli.base_command import Command
    from pip._internal.cli.status_codes import ERROR, SUCCESS
    from pip._internal.configuration import (
    from pip._internal.exceptions import PipError
    from pip._internal.utils.logging import indent_log
    from pip._internal.utils.misc import get_prog, write_output
    class ConfigurationCommand(Command):
        def add_options(self) -> None:
        def run(self, options: Values, args: List[str]) -> int:
        def _determine_file(self, options: Values, need_value: bool) -> Optional[Kind]:
        def list_values(self, options: Values, args: List[str]) -> None:
        def get_name(self, options: Values, args: List[str]) -> None:
        def set_name_value(self, options: Values, args: List[str]) -> None:
        def unset_name(self, options: Values, args: List[str]) -> None:
        def list_config_values(self, options: Values, args: List[str]) -> None:
        def print_config_file_values(self, variant: Kind) -> None:
        def print_env_var_values(self) -> None:
        def open_in_editor(self, options: Values, args: List[str]) -> None:
        def _get_n_args(self, args: List[str], example: str, n: int) -> Any:
        def _save_configuration(self) -> None:
        def _determine_editor(self, options: Values) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: debug.py
    import locale
    import logging
    import os
    import sys
    from optparse import Values
    from types import ModuleType
    from typing import Any, Dict, List, Optional
    import pip._vendor
    from pip._vendor.certifi import where
    from pip._vendor.packaging.version import parse as parse_version
    from pip._internal.cli import cmdoptions
    from pip._internal.cli.base_command import Command
    from pip._internal.cli.cmdoptions import make_target_python
    from pip._internal.cli.status_codes import SUCCESS
    from pip._internal.configuration import Configuration
    from pip._internal.metadata import get_environment
    from pip._internal.utils.compat import open_text_resource
    from pip._internal.utils.logging import indent_log
    from pip._internal.utils.misc import get_pip_version
    def show_value(name: str, value: Any) -> None:
    def show_sys_implementation() -> None:
    def create_vendor_txt_map() -> Dict[str, str]:
    def get_module_from_module_name(module_name: str) -> Optional[ModuleType]:
    def get_vendor_version_from_module(module_name: str) -> Optional[str]:
    def show_actual_vendor_versions(vendor_txt_versions: Dict[str, str]) -> None:
    def show_vendor_versions() -> None:
    def show_tags(options: Values) -> None:
    def ca_bundle_info(config: Configuration) -> str:
    class DebugCommand(Command):
        def add_options(self) -> None:
        def run(self, options: Values, args: List[str]) -> int:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: download.py
    import logging
    import os
    from optparse import Values
    from typing import List
    from pip._internal.cli import cmdoptions
    from pip._internal.cli.cmdoptions import make_target_python
    from pip._internal.cli.req_command import RequirementCommand, with_cleanup
    from pip._internal.cli.status_codes import SUCCESS
    from pip._internal.operations.build.build_tracker import get_build_tracker
    from pip._internal.req.req_install import check_legacy_setup_py_options
    from pip._internal.utils.misc import ensure_dir, normalize_path, write_output
    from pip._internal.utils.temp_dir import TempDirectory
    class DownloadCommand(RequirementCommand):
        def add_options(self) -> None:
        @with_cleanup
        def run(self, options: Values, args: List[str]) -> int:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: freeze.py
    import sys
    from optparse import Values
    from typing import AbstractSet, List
    from pip._internal.cli import cmdoptions
    from pip._internal.cli.base_command import Command
    from pip._internal.cli.status_codes import SUCCESS
    from pip._internal.operations.freeze import freeze
    from pip._internal.utils.compat import stdlib_pkgs
    def _should_suppress_build_backends() -> bool:
    def _dev_pkgs() -> AbstractSet[str]:
    class FreezeCommand(Command):
        def add_options(self) -> None:
        def run(self, options: Values, args: List[str]) -> int:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: hash.py
    import hashlib
    import logging
    import sys
    from optparse import Values
    from typing import List
    from pip._internal.cli.base_command import Command
    from pip._internal.cli.status_codes import ERROR, SUCCESS
    from pip._internal.utils.hashes import FAVORITE_HASH, STRONG_HASHES
    from pip._internal.utils.misc import read_chunks, write_output
    class HashCommand(Command):
        def add_options(self) -> None:
        def run(self, options: Values, args: List[str]) -> int:
    def _hash_of_file(path: str, algorithm: str) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: help.py
    from optparse import Values
    from typing import List
    from pip._internal.cli.base_command import Command
    from pip._internal.cli.status_codes import SUCCESS
    from pip._internal.exceptions import CommandError
    class HelpCommand(Command):
        def run(self, options: Values, args: List[str]) -> int:
            from pip._internal.commands import (

  ðŸ“„ Ð¤Ð°Ð¹Ð»: index.py
    import logging
    from optparse import Values
    from typing import Any, Iterable, List, Optional
    from pip._vendor.packaging.version import Version
    from pip._internal.cli import cmdoptions
    from pip._internal.cli.req_command import IndexGroupCommand
    from pip._internal.cli.status_codes import ERROR, SUCCESS
    from pip._internal.commands.search import print_dist_installation_info
    from pip._internal.exceptions import CommandError, DistributionNotFound, PipError
    from pip._internal.index.collector import LinkCollector
    from pip._internal.index.package_finder import PackageFinder
    from pip._internal.models.selection_prefs import SelectionPreferences
    from pip._internal.models.target_python import TargetPython
    from pip._internal.network.session import PipSession
    from pip._internal.utils.misc import write_output
    class IndexCommand(IndexGroupCommand):
        def add_options(self) -> None:
        def run(self, options: Values, args: List[str]) -> int:
        def _build_package_finder(
        def get_available_package_versions(self, options: Values, args: List[Any]) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: inspect.py
    import logging
    from optparse import Values
    from typing import Any, Dict, List
    from pip._vendor.packaging.markers import default_environment
    from pip._vendor.rich import print_json
    from pip import __version__
    from pip._internal.cli import cmdoptions
    from pip._internal.cli.base_command import Command
    from pip._internal.cli.status_codes import SUCCESS
    from pip._internal.metadata import BaseDistribution, get_environment
    from pip._internal.utils.compat import stdlib_pkgs
    from pip._internal.utils.urls import path_to_url
    class InspectCommand(Command):
        def add_options(self) -> None:
        def run(self, options: Values, args: List[str]) -> int:
        def _dist_to_dict(self, dist: BaseDistribution) -> Dict[str, Any]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: install.py
    import errno
    import json
    import operator
    import os
    import shutil
    import site
    from optparse import SUPPRESS_HELP, Values
    from typing import List, Optional
    from pip._vendor.packaging.utils import canonicalize_name
    from pip._vendor.rich import print_json
    import pip._internal.self_outdated_check  # noqa: F401
    from pip._internal.cache import WheelCache
    from pip._internal.cli import cmdoptions
    from pip._internal.cli.cmdoptions import make_target_python
    from pip._internal.cli.req_command import (
    from pip._internal.cli.status_codes import ERROR, SUCCESS
    from pip._internal.exceptions import CommandError, InstallationError
    from pip._internal.locations import get_scheme
    from pip._internal.metadata import get_environment
    from pip._internal.models.installation_report import InstallationReport
    from pip._internal.operations.build.build_tracker import get_build_tracker
    from pip._internal.operations.check import ConflictDetails, check_install_conflicts
    from pip._internal.req import install_given_reqs
    from pip._internal.req.req_install import (
    from pip._internal.utils.compat import WINDOWS
    from pip._internal.utils.filesystem import test_writable_dir
    from pip._internal.utils.logging import getLogger
    from pip._internal.utils.misc import (
    from pip._internal.utils.temp_dir import TempDirectory
    from pip._internal.utils.virtualenv import (
    from pip._internal.wheel_builder import build, should_build_for_install_command
    class InstallCommand(RequirementCommand):
        def add_options(self) -> None:
        @with_cleanup
        def run(self, options: Values, args: List[str]) -> int:
        def _handle_target_dir(
        def _determine_conflicts(
        def _warn_about_conflicts(
    def get_lib_location_guesses(
    def site_packages_writable(root: Optional[str], isolated: bool) -> bool:
    def decide_user_install(
    def create_os_error_message(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: list.py
    import json
    import logging
    from optparse import Values
    from typing import TYPE_CHECKING, Generator, List, Optional, Sequence, Tuple, cast
    from pip._vendor.packaging.utils import canonicalize_name
    from pip._vendor.packaging.version import Version
    from pip._internal.cli import cmdoptions
    from pip._internal.cli.index_command import IndexGroupCommand
    from pip._internal.cli.status_codes import SUCCESS
    from pip._internal.exceptions import CommandError
    from pip._internal.metadata import BaseDistribution, get_environment
    from pip._internal.models.selection_prefs import SelectionPreferences
    from pip._internal.utils.compat import stdlib_pkgs
    from pip._internal.utils.misc import tabulate, write_output
        from pip._internal.index.package_finder import PackageFinder
        from pip._internal.network.session import PipSession
        class _DistWithLatestInfo(BaseDistribution):
    class ListCommand(IndexGroupCommand):
        def add_options(self) -> None:
        def handle_pip_version_check(self, options: Values) -> None:
        def _build_package_finder(
            from pip._internal.index.collector import LinkCollector
            from pip._internal.index.package_finder import PackageFinder
        def run(self, options: Values, args: List[str]) -> int:
        def get_outdated(
        def get_uptodate(
        def get_not_required(
        def iter_packages_latest_infos(
                def latest_info(
        def output_package_listing(
        def output_package_listing_columns(
    def format_for_columns(
    def format_for_json(packages: "_ProcessedDists", options: Values) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: search.py
    import logging
    import shutil
    import sys
    import textwrap
    import xmlrpc.client
    from collections import OrderedDict
    from optparse import Values
    from typing import TYPE_CHECKING, Dict, List, Optional, TypedDict
    from pip._vendor.packaging.version import parse as parse_version
    from pip._internal.cli.base_command import Command
    from pip._internal.cli.req_command import SessionCommandMixin
    from pip._internal.cli.status_codes import NO_MATCHES_FOUND, SUCCESS
    from pip._internal.exceptions import CommandError
    from pip._internal.metadata import get_default_environment
    from pip._internal.models.index import PyPI
    from pip._internal.network.xmlrpc import PipXmlrpcTransport
    from pip._internal.utils.logging import indent_log
    from pip._internal.utils.misc import write_output
        class TransformedHit(TypedDict):
    class SearchCommand(Command, SessionCommandMixin):
        def add_options(self) -> None:
        def run(self, options: Values, args: List[str]) -> int:
        def search(self, query: List[str], options: Values) -> List[Dict[str, str]]:
    def transform_hits(hits: List[Dict[str, str]]) -> List["TransformedHit"]:
    def print_dist_installation_info(name: str, latest: str) -> None:
    def print_results(
    def highest_version(versions: List[str]) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: show.py
    import logging
    from optparse import Values
    from typing import Generator, Iterable, Iterator, List, NamedTuple, Optional
    from pip._vendor.packaging.requirements import InvalidRequirement
    from pip._vendor.packaging.utils import canonicalize_name
    from pip._internal.cli.base_command import Command
    from pip._internal.cli.status_codes import ERROR, SUCCESS
    from pip._internal.metadata import BaseDistribution, get_default_environment
    from pip._internal.utils.misc import write_output
    class ShowCommand(Command):
        def add_options(self) -> None:
        def run(self, options: Values, args: List[str]) -> int:
    class _PackageInfo(NamedTuple):
    def search_packages_info(query: List[str]) -> Generator[_PackageInfo, None, None]:
        def _get_requiring_packages(current_dist: BaseDistribution) -> Iterator[str]:
    def print_results(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: uninstall.py
    import logging
    from optparse import Values
    from typing import List
    from pip._vendor.packaging.utils import canonicalize_name
    from pip._internal.cli import cmdoptions
    from pip._internal.cli.base_command import Command
    from pip._internal.cli.index_command import SessionCommandMixin
    from pip._internal.cli.status_codes import SUCCESS
    from pip._internal.exceptions import InstallationError
    from pip._internal.req import parse_requirements
    from pip._internal.req.constructors import (
    from pip._internal.utils.misc import (
    class UninstallCommand(Command, SessionCommandMixin):
        def add_options(self) -> None:
        def run(self, options: Values, args: List[str]) -> int:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: wheel.py
    import logging
    import os
    import shutil
    from optparse import Values
    from typing import List
    from pip._internal.cache import WheelCache
    from pip._internal.cli import cmdoptions
    from pip._internal.cli.req_command import RequirementCommand, with_cleanup
    from pip._internal.cli.status_codes import SUCCESS
    from pip._internal.exceptions import CommandError
    from pip._internal.operations.build.build_tracker import get_build_tracker
    from pip._internal.req.req_install import (
    from pip._internal.utils.misc import ensure_dir, normalize_path
    from pip._internal.utils.temp_dir import TempDirectory
    from pip._internal.wheel_builder import build, should_build_for_wheel_command
    class WheelCommand(RequirementCommand):
        def add_options(self) -> None:
        @with_cleanup
        def run(self, options: Values, args: List[str]) -> int:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    import importlib
    from collections import namedtuple
    from typing import Any, Dict, Optional
    from pip._internal.cli.base_command import Command
    def create_command(name: str, **kwargs: Any) -> Command:
    def get_similar_commands(name: str) -> Optional[str]:
        from difflib import get_close_matches

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\distributions

  ðŸ“„ Ð¤Ð°Ð¹Ð»: base.py
    import abc
    from typing import TYPE_CHECKING, Optional
    from pip._internal.metadata.base import BaseDistribution
    from pip._internal.req import InstallRequirement
        from pip._internal.index.package_finder import PackageFinder
    class AbstractDistribution(metaclass=abc.ABCMeta):
        def __init__(self, req: InstallRequirement) -> None:
        @abc.abstractproperty
        def build_tracker_id(self) -> Optional[str]:
        @abc.abstractmethod
        def get_metadata_distribution(self) -> BaseDistribution:
        @abc.abstractmethod
        def prepare_distribution_metadata(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: installed.py
    from typing import Optional
    from pip._internal.distributions.base import AbstractDistribution
    from pip._internal.index.package_finder import PackageFinder
    from pip._internal.metadata import BaseDistribution
    class InstalledDistribution(AbstractDistribution):
        @property
        def build_tracker_id(self) -> Optional[str]:
        def get_metadata_distribution(self) -> BaseDistribution:
        def prepare_distribution_metadata(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: sdist.py
    import logging
    from typing import TYPE_CHECKING, Iterable, Optional, Set, Tuple
    from pip._internal.build_env import BuildEnvironment
    from pip._internal.distributions.base import AbstractDistribution
    from pip._internal.exceptions import InstallationError
    from pip._internal.metadata import BaseDistribution
    from pip._internal.utils.subprocess import runner_with_spinner_message
        from pip._internal.index.package_finder import PackageFinder
    class SourceDistribution(AbstractDistribution):
        @property
        def build_tracker_id(self) -> Optional[str]:
        def get_metadata_distribution(self) -> BaseDistribution:
        def prepare_distribution_metadata(
        def _prepare_build_backend(self, finder: "PackageFinder") -> None:
        def _get_build_requires_wheel(self) -> Iterable[str]:
        def _get_build_requires_editable(self) -> Iterable[str]:
        def _install_build_reqs(self, finder: "PackageFinder") -> None:
        def _raise_conflicts(
        def _raise_missing_reqs(self, missing: Set[str]) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: wheel.py
    from typing import TYPE_CHECKING, Optional
    from pip._vendor.packaging.utils import canonicalize_name
    from pip._internal.distributions.base import AbstractDistribution
    from pip._internal.metadata import (
        from pip._internal.index.package_finder import PackageFinder
    class WheelDistribution(AbstractDistribution):
        @property
        def build_tracker_id(self) -> Optional[str]:
        def get_metadata_distribution(self) -> BaseDistribution:
        def prepare_distribution_metadata(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from pip._internal.distributions.base import AbstractDistribution
    from pip._internal.distributions.sdist import SourceDistribution
    from pip._internal.distributions.wheel import WheelDistribution
    from pip._internal.req.req_install import InstallRequirement
    def make_distribution_for_install_requirement(

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\index

  ðŸ“„ Ð¤Ð°Ð¹Ð»: collector.py
    import collections
    import email.message
    import functools
    import itertools
    import json
    import logging
    import os
    import urllib.parse
    import urllib.request
    from dataclasses import dataclass
    from html.parser import HTMLParser
    from optparse import Values
    from typing import (
    from pip._vendor import requests
    from pip._vendor.requests import Response
    from pip._vendor.requests.exceptions import RetryError, SSLError
    from pip._internal.exceptions import NetworkConnectionError
    from pip._internal.models.link import Link
    from pip._internal.models.search_scope import SearchScope
    from pip._internal.network.session import PipSession
    from pip._internal.network.utils import raise_for_status
    from pip._internal.utils.filetypes import is_archive_file
    from pip._internal.utils.misc import redact_auth_from_url
    from pip._internal.vcs import vcs
    from .sources import CandidatesFromPage, LinkSource, build_source
    def _match_vcs_scheme(url: str) -> Optional[str]:
    class _NotAPIContent(Exception):
        def __init__(self, content_type: str, request_desc: str) -> None:
    def _ensure_api_header(response: Response) -> None:
    class _NotHTTP(Exception):
    def _ensure_api_response(url: str, session: PipSession) -> None:
    def _get_simple_response(url: str, session: PipSession) -> Response:
    def _get_encoding_from_headers(headers: ResponseHeaders) -> Optional[str]:
    class CacheablePageContent:
        def __init__(self, page: "IndexContent") -> None:
        def __eq__(self, other: object) -> bool:
        def __hash__(self) -> int:
    class ParseLinks(Protocol):
        def __call__(self, page: "IndexContent") -> Iterable[Link]: ...
    def with_cached_index_content(fn: ParseLinks) -> ParseLinks:
        @functools.lru_cache(maxsize=None)
        def wrapper(cacheable_page: CacheablePageContent) -> List[Link]:
        @functools.wraps(fn)
        def wrapper_wrapper(page: "IndexContent") -> List[Link]:
    @with_cached_index_content
    def parse_links(page: "IndexContent") -> Iterable[Link]:
    @dataclass(frozen=True)
    class IndexContent:
        def __str__(self) -> str:
    class HTMLLinkParser(HTMLParser):
        def __init__(self, url: str) -> None:
        def handle_starttag(self, tag: str, attrs: List[Tuple[str, Optional[str]]]) -> None:
        def get_href(self, attrs: List[Tuple[str, Optional[str]]]) -> Optional[str]:
    def _handle_get_simple_fail(
    def _make_index_content(
    def _get_index_content(link: Link, *, session: PipSession) -> Optional["IndexContent"]:
    class CollectedSources(NamedTuple):
    class LinkCollector:
        def __init__(
        @classmethod
        def create(
        @property
        def find_links(self) -> List[str]:
        def fetch_response(self, location: Link) -> Optional[IndexContent]:
        def collect_sources(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: package_finder.py
    import enum
    import functools
    import itertools
    import logging
    import re
    from dataclasses import dataclass
    from typing import TYPE_CHECKING, FrozenSet, Iterable, List, Optional, Set, Tuple, Union
    from pip._vendor.packaging import specifiers
    from pip._vendor.packaging.tags import Tag
    from pip._vendor.packaging.utils import canonicalize_name
    from pip._vendor.packaging.version import InvalidVersion, _BaseVersion
    from pip._vendor.packaging.version import parse as parse_version
    from pip._internal.exceptions import (
    from pip._internal.index.collector import LinkCollector, parse_links
    from pip._internal.models.candidate import InstallationCandidate
    from pip._internal.models.format_control import FormatControl
    from pip._internal.models.link import Link
    from pip._internal.models.search_scope import SearchScope
    from pip._internal.models.selection_prefs import SelectionPreferences
    from pip._internal.models.target_python import TargetPython
    from pip._internal.models.wheel import Wheel
    from pip._internal.req import InstallRequirement
    from pip._internal.utils._log import getLogger
    from pip._internal.utils.filetypes import WHEEL_EXTENSION
    from pip._internal.utils.hashes import Hashes
    from pip._internal.utils.logging import indent_log
    from pip._internal.utils.misc import build_netloc
    from pip._internal.utils.packaging import check_requires_python
    from pip._internal.utils.unpacking import SUPPORTED_EXTENSIONS
        from pip._vendor.typing_extensions import TypeGuard
    def _check_link_requires_python(
    class LinkType(enum.Enum):
    class LinkEvaluator:
        def __init__(
        def evaluate_link(self, link: Link) -> Tuple[LinkType, str]:
    def filter_unallowed_hashes(
    @dataclass
    class CandidatePreferences:
    @dataclass(frozen=True)
    class BestCandidateResult:
        def __post_init__(self) -> None:
    class CandidateEvaluator:
        @classmethod
        def create(
        def __init__(
        def get_applicable_candidates(
        def _sort_key(self, candidate: InstallationCandidate) -> CandidateSortingKey:
        def sort_best_candidate(
        def compute_best_candidate(
    class PackageFinder:
        def __init__(
        @classmethod
        def create(
        @property
        def target_python(self) -> TargetPython:
        @property
        def search_scope(self) -> SearchScope:
        @search_scope.setter
        def search_scope(self, search_scope: SearchScope) -> None:
        @property
        def find_links(self) -> List[str]:
        @property
        def index_urls(self) -> List[str]:
        @property
        def proxy(self) -> Optional[str]:
        @property
        def trusted_hosts(self) -> Iterable[str]:
        @property
        def custom_cert(self) -> Optional[str]:
        @property
        def client_cert(self) -> Optional[str]:
        @property
        def allow_all_prereleases(self) -> bool:
        def set_allow_all_prereleases(self) -> None:
        @property
        def prefer_binary(self) -> bool:
        def set_prefer_binary(self) -> None:
        def requires_python_skipped_reasons(self) -> List[str]:
        def make_link_evaluator(self, project_name: str) -> LinkEvaluator:
        def _sort_links(self, links: Iterable[Link]) -> List[Link]:
        def _log_skipped_link(self, link: Link, result: LinkType, detail: str) -> None:
        def get_install_candidate(
        def evaluate_links(
        def process_project_url(
        @functools.lru_cache(maxsize=None)
        def find_all_candidates(self, project_name: str) -> List[InstallationCandidate]:
        def make_candidate_evaluator(
        @functools.lru_cache(maxsize=None)
        def find_best_candidate(
        def find_requirement(
            def _format_versions(cand_iter: Iterable[InstallationCandidate]) -> str:
            def _should_install_candidate(
    def _find_name_version_sep(fragment: str, canonical_name: str) -> int:
    def _extract_version_from_fragment(fragment: str, canonical_name: str) -> Optional[str]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: sources.py
    import logging
    import mimetypes
    import os
    from collections import defaultdict
    from typing import Callable, Dict, Iterable, List, Optional, Tuple
    from pip._vendor.packaging.utils import (
    from pip._internal.models.candidate import InstallationCandidate
    from pip._internal.models.link import Link
    from pip._internal.utils.urls import path_to_url, url_to_path
    from pip._internal.vcs import is_url
    class LinkSource:
        @property
        def link(self) -> Optional[Link]:
        def page_candidates(self) -> FoundCandidates:
        def file_links(self) -> FoundLinks:
    def _is_html_file(file_url: str) -> bool:
    class _FlatDirectoryToUrls:
        def __init__(self, path: str) -> None:
        def _scan_directory(self) -> None:
        @property
        def page_candidates(self) -> List[str]:
        @property
        def project_name_to_urls(self) -> Dict[str, List[str]]:
    class _FlatDirectorySource(LinkSource):
        def __init__(
        @property
        def link(self) -> Optional[Link]:
        def page_candidates(self) -> FoundCandidates:
        def file_links(self) -> FoundLinks:
    class _LocalFileSource(LinkSource):
        def __init__(
        @property
        def link(self) -> Optional[Link]:
        def page_candidates(self) -> FoundCandidates:
        def file_links(self) -> FoundLinks:
    class _RemoteFileSource(LinkSource):
        def __init__(
        @property
        def link(self) -> Optional[Link]:
        def page_candidates(self) -> FoundCandidates:
        def file_links(self) -> FoundLinks:
    class _IndexDirectorySource(LinkSource):
        def __init__(
        @property
        def link(self) -> Optional[Link]:
        def page_candidates(self) -> FoundCandidates:
        def file_links(self) -> FoundLinks:
    def build_source(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\locations

  ðŸ“„ Ð¤Ð°Ð¹Ð»: base.py
    import functools
    import os
    import site
    import sys
    import sysconfig
    import typing
    from pip._internal.exceptions import InstallationError
    from pip._internal.utils import appdirs
    from pip._internal.utils.virtualenv import running_under_virtualenv
    USER_CACHE_DIR = appdirs.user_cache_dir("pip")
    def get_major_minor_version() -> str:
    def change_root(new_root: str, pathname: str) -> str:
    def get_src_prefix() -> str:
    @functools.lru_cache(maxsize=None)
    def is_osx_framework() -> bool:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _distutils.py
    import logging
    import os
    import sys
    from distutils.cmd import Command as DistutilsCommand
    from distutils.command.install import SCHEME_KEYS
    from distutils.command.install import install as distutils_install_command
    from distutils.sysconfig import get_python_lib
    from typing import Dict, List, Optional, Union
    from pip._internal.models.scheme import Scheme
    from pip._internal.utils.compat import WINDOWS
    from pip._internal.utils.virtualenv import running_under_virtualenv
    from .base import get_major_minor_version
    def distutils_scheme(
        from distutils.dist import Distribution
    def get_scheme(
    def get_bin_prefix() -> str:
    def get_purelib() -> str:
    def get_platlib() -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _sysconfig.py
    import logging
    import os
    import sys
    import sysconfig
    import typing
    from pip._internal.exceptions import InvalidSchemeCombination, UserInstallationInvalid
    from pip._internal.models.scheme import SCHEME_KEYS, Scheme
    from pip._internal.utils.virtualenv import running_under_virtualenv
    from .base import change_root, get_major_minor_version, is_osx_framework
    _AVAILABLE_SCHEMES = set(sysconfig.get_scheme_names())
    _PREFERRED_SCHEME_API = getattr(sysconfig, "get_preferred_scheme", None)
    def _should_use_osx_framework_prefix() -> bool:
    def _infer_prefix() -> str:
    def _infer_user() -> str:
    def _infer_home() -> str:
    _HOME_KEYS = [
    def get_scheme(
    def get_bin_prefix() -> str:
    def get_purelib() -> str:
    def get_platlib() -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    import functools
    import logging
    import os
    import pathlib
    import sys
    import sysconfig
    from typing import Any, Dict, Generator, Optional, Tuple
    from pip._internal.models.scheme import SCHEME_KEYS, Scheme
    from pip._internal.utils.compat import WINDOWS
    from pip._internal.utils.deprecation import deprecated
    from pip._internal.utils.virtualenv import running_under_virtualenv
    from . import _sysconfig
    from .base import (
    _USE_SYSCONFIG_DEFAULT = sys.version_info >= (3, 10)
    def _should_use_sysconfig() -> bool:
    _USE_SYSCONFIG = _should_use_sysconfig()
        from . import _distutils
        _MISMATCH_LEVEL = logging.WARNING
        _MISMATCH_LEVEL = logging.DEBUG
    def _looks_like_bpo_44860() -> bool:
        from distutils.command.install import INSTALL_SCHEMES
    def _looks_like_red_hat_patched_platlib_purelib(scheme: Dict[str, str]) -> bool:
    @functools.lru_cache(maxsize=None)
    def _looks_like_red_hat_lib() -> bool:
        from distutils.command.install import INSTALL_SCHEMES
    @functools.lru_cache(maxsize=None)
    def _looks_like_debian_scheme() -> bool:
        from distutils.command.install import INSTALL_SCHEMES
    @functools.lru_cache(maxsize=None)
    def _looks_like_red_hat_scheme() -> bool:
        from distutils.command.install import install
        from distutils.dist import Distribution
    @functools.lru_cache(maxsize=None)
    def _looks_like_slackware_scheme() -> bool:
    @functools.lru_cache(maxsize=None)
    def _looks_like_msys2_mingw_scheme() -> bool:
    def _fix_abiflags(parts: Tuple[str]) -> Generator[str, None, None]:
    @functools.lru_cache(maxsize=None)
    def _warn_mismatched(old: pathlib.Path, new: pathlib.Path, *, key: str) -> None:
    def _warn_if_mismatch(old: pathlib.Path, new: pathlib.Path, *, key: str) -> bool:
    @functools.lru_cache(maxsize=None)
    def _log_context(
    def get_scheme(
    def get_bin_prefix() -> str:
    def get_bin_user() -> str:
    def _looks_like_deb_system_dist_packages(value: str) -> bool:
    def get_purelib() -> str:
    def get_platlib() -> str:
        from . import _distutils

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\metadata

  ðŸ“„ Ð¤Ð°Ð¹Ð»: base.py
    import csv
    import email.message
    import functools
    import json
    import logging
    import pathlib
    import re
    import zipfile
    from typing import (
    from pip._vendor.packaging.requirements import Requirement
    from pip._vendor.packaging.specifiers import InvalidSpecifier, SpecifierSet
    from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
    from pip._vendor.packaging.version import Version
    from pip._internal.exceptions import NoneMetadataError
    from pip._internal.locations import site_packages, user_site
    from pip._internal.models.direct_url import (
    from pip._internal.utils.compat import stdlib_pkgs  # TODO: Move definition here.
    from pip._internal.utils.egg_link import egg_link_path_from_sys_path
    from pip._internal.utils.misc import is_local, normalize_path
    from pip._internal.utils.urls import url_to_path
    from ._json import msg_to_json
    class BaseEntryPoint(Protocol):
        @property
        def name(self) -> str:
        @property
        def value(self) -> str:
        @property
        def group(self) -> str:
    def _convert_installed_files_path(
           from ``info``; if ``info`` is empty, start appending ``..`` instead.
    class RequiresEntry(NamedTuple):
    class BaseDistribution(Protocol):
        @classmethod
        def from_directory(cls, directory: str) -> "BaseDistribution":
        @classmethod
        def from_metadata_file_contents(
        @classmethod
        def from_wheel(cls, wheel: "Wheel", name: str) -> "BaseDistribution":
        def __repr__(self) -> str:
        def __str__(self) -> str:
        @property
        def location(self) -> Optional[str]:
        @property
        def editable_project_location(self) -> Optional[str]:
        @property
        def installed_location(self) -> Optional[str]:
        @property
        def info_location(self) -> Optional[str]:
        @property
        def installed_by_distutils(self) -> bool:
        @property
        def installed_as_egg(self) -> bool:
        @property
        def installed_with_setuptools_egg_info(self) -> bool:
        @property
        def installed_with_dist_info(self) -> bool:
        @property
        def canonical_name(self) -> NormalizedName:
        @property
        def version(self) -> Version:
        @property
        def raw_version(self) -> str:
        @property
        def setuptools_filename(self) -> str:
        @property
        def direct_url(self) -> Optional[DirectUrl]:
        @property
        def installer(self) -> str:
        @property
        def requested(self) -> bool:
        @property
        def editable(self) -> bool:
        @property
        def local(self) -> bool:
        @property
        def in_usersite(self) -> bool:
        @property
        def in_site_packages(self) -> bool:
        def is_file(self, path: InfoPath) -> bool:
        def iter_distutils_script_names(self) -> Iterator[str]:
        def read_text(self, path: InfoPath) -> str:
        def iter_entry_points(self) -> Iterable[BaseEntryPoint]:
        def _metadata_impl(self) -> email.message.Message:
        @functools.cached_property
        def metadata(self) -> email.message.Message:
        @property
        def metadata_dict(self) -> Dict[str, Any]:
        @property
        def metadata_version(self) -> Optional[str]:
        @property
        def raw_name(self) -> str:
        @property
        def requires_python(self) -> SpecifierSet:
        def iter_dependencies(self, extras: Collection[str] = ()) -> Iterable[Requirement]:
        def iter_raw_dependencies(self) -> Iterable[str]:
        def iter_provided_extras(self) -> Iterable[NormalizedName]:
        def _iter_declared_entries_from_record(self) -> Optional[Iterator[str]]:
        def _iter_declared_entries_from_legacy(self) -> Optional[Iterator[str]]:
        def iter_declared_entries(self) -> Optional[Iterator[str]]:
        def _iter_requires_txt_entries(self) -> Iterator[RequiresEntry]:
        def _iter_egg_info_extras(self) -> Iterable[str]:
        def _iter_egg_info_dependencies(self) -> Iterable[str]:
        def _add_egg_info_requires(self, metadata: email.message.Message) -> None:
    class BaseEnvironment:
        @classmethod
        def default(cls) -> "BaseEnvironment":
        @classmethod
        def from_paths(cls, paths: Optional[List[str]]) -> "BaseEnvironment":
        def get_distribution(self, name: str) -> Optional["BaseDistribution"]:
        def _iter_distributions(self) -> Iterator["BaseDistribution"]:
        def iter_all_distributions(self) -> Iterator[BaseDistribution]:
        def iter_installed_distributions(
    class Wheel(Protocol):
        def as_zipfile(self) -> zipfile.ZipFile:
    class FilesystemWheel(Wheel):
        def __init__(self, location: str) -> None:
        def as_zipfile(self) -> zipfile.ZipFile:
    class MemoryWheel(Wheel):
        def __init__(self, location: str, stream: IO[bytes]) -> None:
        def as_zipfile(self) -> zipfile.ZipFile:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: pkg_resources.py
    import email.message
    import email.parser
    import logging
    import os
    import zipfile
    from typing import (
    from pip._vendor import pkg_resources
    from pip._vendor.packaging.requirements import Requirement
    from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
    from pip._vendor.packaging.version import Version
    from pip._vendor.packaging.version import parse as parse_version
    from pip._internal.exceptions import InvalidWheel, NoneMetadataError, UnsupportedWheel
    from pip._internal.utils.egg_link import egg_link_path_from_location
    from pip._internal.utils.misc import display_path, normalize_path
    from pip._internal.utils.wheel import parse_wheel, read_wheel_metadata_file
    from .base import (
    NAME = "pkg_resources"
    class EntryPoint(NamedTuple):
    class InMemoryMetadata:
        def __init__(self, metadata: Mapping[str, bytes], wheel_name: str) -> None:
        def has_metadata(self, name: str) -> bool:
        def get_metadata(self, name: str) -> str:
        def get_metadata_lines(self, name: str) -> Iterable[str]:
        def metadata_isdir(self, name: str) -> bool:
        def metadata_listdir(self, name: str) -> List[str]:
        def run_script(self, script_name: str, namespace: str) -> None:
    class Distribution(BaseDistribution):
        def __init__(self, dist: pkg_resources.Distribution) -> None:
        @property
        def _extra_mapping(self) -> Mapping[NormalizedName, str]:
        @classmethod
        def from_directory(cls, directory: str) -> BaseDistribution:
        @classmethod
        def from_metadata_file_contents(
        @classmethod
        def from_wheel(cls, wheel: Wheel, name: str) -> BaseDistribution:
        @property
        def location(self) -> Optional[str]:
        @property
        def installed_location(self) -> Optional[str]:
        @property
        def info_location(self) -> Optional[str]:
        @property
        def installed_by_distutils(self) -> bool:
        @property
        def canonical_name(self) -> NormalizedName:
        @property
        def version(self) -> Version:
        @property
        def raw_version(self) -> str:
        def is_file(self, path: InfoPath) -> bool:
        def iter_distutils_script_names(self) -> Iterator[str]:
        def read_text(self, path: InfoPath) -> str:
        def iter_entry_points(self) -> Iterable[BaseEntryPoint]:
        def _metadata_impl(self) -> email.message.Message:
        def iter_dependencies(self, extras: Collection[str] = ()) -> Iterable[Requirement]:
        def iter_provided_extras(self) -> Iterable[NormalizedName]:
    class Environment(BaseEnvironment):
        def __init__(self, ws: pkg_resources.WorkingSet) -> None:
        @classmethod
        def default(cls) -> BaseEnvironment:
        @classmethod
        def from_paths(cls, paths: Optional[List[str]]) -> BaseEnvironment:
        def _iter_distributions(self) -> Iterator[BaseDistribution]:
        def _search_distribution(self, name: str) -> Optional[BaseDistribution]:
        def get_distribution(self, name: str) -> Optional[BaseDistribution]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _json.py
    from email.header import Header, decode_header, make_header
    from email.message import Message
    from typing import Any, Dict, List, Union, cast
    METADATA_FIELDS = [
    def json_name(field: str) -> str:
    def msg_to_json(msg: Message) -> Dict[str, Any]:
        def sanitise_header(h: Union[Header, str]) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    import contextlib
    import functools
    import os
    import sys
    from typing import TYPE_CHECKING, List, Optional, Type, cast
    from pip._internal.utils.misc import strtobool
    from .base import BaseDistribution, BaseEnvironment, FilesystemWheel, MemoryWheel, Wheel
        from typing import Literal, Protocol
    def _should_use_importlib_metadata() -> bool:
        import importlib.metadata
    class Backend(Protocol):
    @functools.lru_cache(maxsize=None)
    def select_backend() -> Backend:
            from . import importlib
        from . import pkg_resources
    def get_default_environment() -> BaseEnvironment:
    def get_environment(paths: Optional[List[str]]) -> BaseEnvironment:
    def get_directory_distribution(directory: str) -> BaseDistribution:
    def get_wheel_distribution(wheel: Wheel, canonical_name: str) -> BaseDistribution:
    def get_metadata_distribution(

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\metadata\importlib

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _compat.py
    import importlib.metadata
    import os
    from typing import Any, Optional, Protocol, Tuple, cast
    from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
    class BadMetadata(ValueError):
        def __init__(self, dist: importlib.metadata.Distribution, *, reason: str) -> None:
        def __str__(self) -> str:
    class BasePath(Protocol):
        @property
        def name(self) -> str:
        @property
        def parent(self) -> "BasePath":
    def get_info_location(d: importlib.metadata.Distribution) -> Optional[BasePath]:
    def parse_name_and_version_from_info_directory(
    def get_dist_canonical_name(dist: importlib.metadata.Distribution) -> NormalizedName:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _dists.py
    import email.message
    import importlib.metadata
    import pathlib
    import zipfile
    from os import PathLike
    from typing import (
    from pip._vendor.packaging.requirements import Requirement
    from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
    from pip._vendor.packaging.version import Version
    from pip._vendor.packaging.version import parse as parse_version
    from pip._internal.exceptions import InvalidWheel, UnsupportedWheel
    from pip._internal.metadata.base import (
    from pip._internal.utils.misc import normalize_path
    from pip._internal.utils.packaging import get_requirement
    from pip._internal.utils.temp_dir import TempDirectory
    from pip._internal.utils.wheel import parse_wheel, read_wheel_metadata_file
    from ._compat import (
    class WheelDistribution(importlib.metadata.Distribution):
        def __init__(
        @classmethod
        def from_zipfile(
        def iterdir(self, path: InfoPath) -> Iterator[pathlib.PurePosixPath]:
        def read_text(self, filename: str) -> Optional[str]:
        def locate_file(self, path: Union[str, "PathLike[str]"]) -> pathlib.Path:
    class Distribution(BaseDistribution):
        def __init__(
        @classmethod
        def from_directory(cls, directory: str) -> BaseDistribution:
        @classmethod
        def from_metadata_file_contents(
        @classmethod
        def from_wheel(cls, wheel: Wheel, name: str) -> BaseDistribution:
        @property
        def location(self) -> Optional[str]:
        @property
        def info_location(self) -> Optional[str]:
        @property
        def installed_location(self) -> Optional[str]:
        @property
        def canonical_name(self) -> NormalizedName:
        @property
        def version(self) -> Version:
        @property
        def raw_version(self) -> str:
        def is_file(self, path: InfoPath) -> bool:
        def iter_distutils_script_names(self) -> Iterator[str]:
        def read_text(self, path: InfoPath) -> str:
        def iter_entry_points(self) -> Iterable[BaseEntryPoint]:
        def _metadata_impl(self) -> email.message.Message:
        def iter_provided_extras(self) -> Iterable[NormalizedName]:
        def iter_dependencies(self, extras: Collection[str] = ()) -> Iterable[Requirement]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _envs.py
    import functools
    import importlib.metadata
    import logging
    import os
    import pathlib
    import sys
    import zipfile
    import zipimport
    from typing import Iterator, List, Optional, Sequence, Set, Tuple
    from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
    from pip._internal.metadata.base import BaseDistribution, BaseEnvironment
    from pip._internal.models.wheel import Wheel
    from pip._internal.utils.deprecation import deprecated
    from pip._internal.utils.filetypes import WHEEL_EXTENSION
    from ._compat import BadMetadata, BasePath, get_dist_canonical_name, get_info_location
    from ._dists import Distribution
    def _looks_like_wheel(location: str) -> bool:
    class _DistributionFinder:
        def __init__(self) -> None:
        def _find_impl(self, location: str) -> Iterator[FoundResult]:
        def find(self, location: str) -> Iterator[BaseDistribution]:
        def find_linked(self, location: str) -> Iterator[BaseDistribution]:
        def _find_eggs_in_dir(self, location: str) -> Iterator[BaseDistribution]:
            from pip._vendor.pkg_resources import find_distributions
            from pip._internal.metadata import pkg_resources as legacy
        def _find_eggs_in_zip(self, location: str) -> Iterator[BaseDistribution]:
            from pip._vendor.pkg_resources import find_eggs_in_zip
            from pip._internal.metadata import pkg_resources as legacy
        def find_eggs(self, location: str) -> Iterator[BaseDistribution]:
    @functools.lru_cache(maxsize=None)  # Warn a distribution exactly once.
    def _emit_egg_deprecation(location: Optional[str]) -> None:
    class Environment(BaseEnvironment):
        def __init__(self, paths: Sequence[str]) -> None:
        @classmethod
        def default(cls) -> BaseEnvironment:
        @classmethod
        def from_paths(cls, paths: Optional[List[str]]) -> BaseEnvironment:
        def _iter_distributions(self) -> Iterator[BaseDistribution]:
        def get_distribution(self, name: str) -> Optional[BaseDistribution]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from ._dists import Distribution
    from ._envs import Environment
    NAME = "importlib"

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\models

  ðŸ“„ Ð¤Ð°Ð¹Ð»: candidate.py
    from dataclasses import dataclass
    from pip._vendor.packaging.version import Version
    from pip._vendor.packaging.version import parse as parse_version
    from pip._internal.models.link import Link
    @dataclass(frozen=True)
    class InstallationCandidate:
        def __init__(self, name: str, version: str, link: Link) -> None:
        def __str__(self) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: direct_url.py
    import json
    import re
    import urllib.parse
    from dataclasses import dataclass
    from typing import Any, ClassVar, Dict, Iterable, Optional, Type, TypeVar, Union
    T = TypeVar("T")
    DIRECT_URL_METADATA_NAME = "direct_url.json"
    ENV_VAR_RE = re.compile(r"^\$\{[A-Za-z0-9-_]+\}(:\$\{[A-Za-z0-9-_]+\})?$")
    class DirectUrlValidationError(Exception):
    def _get(
    def _get_required(
    def _exactly_one_of(infos: Iterable[Optional["InfoType"]]) -> "InfoType":
    def _filter_none(**kwargs: Any) -> Dict[str, Any]:
    @dataclass
    class VcsInfo:
        @classmethod
        def _from_dict(cls, d: Optional[Dict[str, Any]]) -> Optional["VcsInfo"]:
        def _to_dict(self) -> Dict[str, Any]:
    class ArchiveInfo:
        def __init__(
        @property
        def hash(self) -> Optional[str]:
        @hash.setter
        def hash(self, value: Optional[str]) -> None:
        @classmethod
        def _from_dict(cls, d: Optional[Dict[str, Any]]) -> Optional["ArchiveInfo"]:
        def _to_dict(self) -> Dict[str, Any]:
    @dataclass
    class DirInfo:
        @classmethod
        def _from_dict(cls, d: Optional[Dict[str, Any]]) -> Optional["DirInfo"]:
        def _to_dict(self) -> Dict[str, Any]:
    @dataclass
    class DirectUrl:
        def _remove_auth_from_netloc(self, netloc: str) -> str:
        @property
        def redacted_url(self) -> str:
        def validate(self) -> None:
        @classmethod
        def from_dict(cls, d: Dict[str, Any]) -> "DirectUrl":
        def to_dict(self) -> Dict[str, Any]:
        @classmethod
        def from_json(cls, s: str) -> "DirectUrl":
        def to_json(self) -> str:
        def is_local_editable(self) -> bool:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: format_control.py
    from typing import FrozenSet, Optional, Set
    from pip._vendor.packaging.utils import canonicalize_name
    from pip._internal.exceptions import CommandError
    class FormatControl:
        def __init__(
        def __eq__(self, other: object) -> bool:
        def __repr__(self) -> str:
        @staticmethod
        def handle_mutual_excludes(value: str, target: Set[str], other: Set[str]) -> None:
        def get_allowed_formats(self, canonical_name: str) -> FrozenSet[str]:
        def disallow_binaries(self) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: index.py
    import urllib.parse
    class PackageIndex:
        def __init__(self, url: str, file_storage_domain: str) -> None:
        def _url_for_path(self, path: str) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: installation_report.py
    from typing import Any, Dict, Sequence
    from pip._vendor.packaging.markers import default_environment
    from pip import __version__
    from pip._internal.req.req_install import InstallRequirement
    class InstallationReport:
        def __init__(self, install_requirements: Sequence[InstallRequirement]):
        @classmethod
        def _install_req_to_dict(cls, ireq: InstallRequirement) -> Dict[str, Any]:
        def to_dict(self) -> Dict[str, Any]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: link.py
    import functools
    import itertools
    import logging
    import os
    import posixpath
    import re
    import urllib.parse
    from dataclasses import dataclass
    from typing import (
    from pip._internal.utils.deprecation import deprecated
    from pip._internal.utils.filetypes import WHEEL_EXTENSION
    from pip._internal.utils.hashes import Hashes
    from pip._internal.utils.misc import (
    from pip._internal.utils.urls import path_to_url, url_to_path
        from pip._internal.index.collector import IndexContent
    _SUPPORTED_HASHES = ("sha512", "sha384", "sha256", "sha224", "sha1", "md5")
    @dataclass(frozen=True)
    class LinkHash:
        def __post_init__(self) -> None:
        @classmethod
        @functools.lru_cache(maxsize=None)
        def find_hash_url_fragment(cls, url: str) -> Optional["LinkHash"]:
        def as_dict(self) -> Dict[str, str]:
        def as_hashes(self) -> Hashes:
        def is_hash_allowed(self, hashes: Optional[Hashes]) -> bool:
    @dataclass(frozen=True)
    class MetadataFile:
        def __post_init__(self) -> None:
    def supported_hashes(hashes: Optional[Dict[str, str]]) -> Optional[Dict[str, str]]:
    def _clean_url_path_part(part: str) -> str:
    def _clean_file_url_path(part: str) -> str:
    def _clean_url_path(path: str, is_local_path: bool) -> str:
    def _ensure_quoted_url(url: str) -> str:
    def _absolute_link_url(base_url: str, url: str) -> str:
    @functools.total_ordering
    class Link:
        def __init__(
        @classmethod
        def from_json(
        @classmethod
        def from_element(
        def __str__(self) -> str:
        def __repr__(self) -> str:
        def __hash__(self) -> int:
        def __eq__(self, other: Any) -> bool:
        def __lt__(self, other: Any) -> bool:
        @property
        def url(self) -> str:
        @property
        def filename(self) -> str:
        @property
        def file_path(self) -> str:
        @property
        def scheme(self) -> str:
        @property
        def netloc(self) -> str:
        @property
        def path(self) -> str:
        def splitext(self) -> Tuple[str, str]:
        @property
        def ext(self) -> str:
        @property
        def url_without_fragment(self) -> str:
        def _egg_fragment(self) -> Optional[str]:
        @property
        def subdirectory_fragment(self) -> Optional[str]:
        def metadata_link(self) -> Optional["Link"]:
        def as_hashes(self) -> Hashes:
        @property
        def hash(self) -> Optional[str]:
        @property
        def hash_name(self) -> Optional[str]:
        @property
        def show_url(self) -> str:
        @property
        def is_file(self) -> bool:
        def is_existing_dir(self) -> bool:
        @property
        def is_wheel(self) -> bool:
        @property
        def is_vcs(self) -> bool:
            from pip._internal.vcs import vcs
        @property
        def is_yanked(self) -> bool:
        @property
        def has_hash(self) -> bool:
        def is_hash_allowed(self, hashes: Optional[Hashes]) -> bool:
    class _CleanResult(NamedTuple):
    def _clean_link(link: Link) -> _CleanResult:
    @functools.lru_cache(maxsize=None)
    def links_equivalent(link1: Link, link2: Link) -> bool:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: scheme.py
    from dataclasses import dataclass
    SCHEME_KEYS = ["platlib", "purelib", "headers", "scripts", "data"]
    @dataclass(frozen=True)
    class Scheme:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: search_scope.py
    import itertools
    import logging
    import os
    import posixpath
    import urllib.parse
    from dataclasses import dataclass
    from typing import List
    from pip._vendor.packaging.utils import canonicalize_name
    from pip._internal.models.index import PyPI
    from pip._internal.utils.compat import has_tls
    from pip._internal.utils.misc import normalize_path, redact_auth_from_url
    @dataclass(frozen=True)
    class SearchScope:
        @classmethod
        def create(
        def get_formatted_locations(self) -> str:
        def get_index_urls_locations(self, project_name: str) -> List[str]:
            def mkurl_pypi_url(url: str) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: selection_prefs.py
    from typing import Optional
    from pip._internal.models.format_control import FormatControl
    class SelectionPreferences:
        def __init__(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: target_python.py
    import sys
    from typing import List, Optional, Set, Tuple
    from pip._vendor.packaging.tags import Tag
    from pip._internal.utils.compatibility_tags import get_supported, version_info_to_nodot
    from pip._internal.utils.misc import normalize_version_info
    class TargetPython:
        def __init__(
        def format_given(self) -> str:
        def get_sorted_tags(self) -> List[Tag]:
        def get_unsorted_tags(self) -> Set[Tag]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: wheel.py
    import re
    from typing import Dict, Iterable, List
    from pip._vendor.packaging.tags import Tag
    from pip._vendor.packaging.utils import (
    from pip._vendor.packaging.utils import parse_wheel_filename
    from pip._internal.exceptions import InvalidWheelFilename
    from pip._internal.utils.deprecation import deprecated
    class Wheel:
        def __init__(self, filename: str) -> None:
        def get_formatted_file_tags(self) -> List[str]:
        def support_index_min(self, tags: List[Tag]) -> int:
        def find_most_preferred_tag(
        def supported(self, tags: Iterable[Tag]) -> bool:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\network

  ðŸ“„ Ð¤Ð°Ð¹Ð»: auth.py
    import logging
    import os
    import shutil
    import subprocess
    import sysconfig
    import typing
    import urllib.parse
    from abc import ABC, abstractmethod
    from functools import lru_cache
    from os.path import commonprefix
    from pathlib import Path
    from typing import Any, Dict, List, NamedTuple, Optional, Tuple
    from pip._vendor.requests.auth import AuthBase, HTTPBasicAuth
    from pip._vendor.requests.models import Request, Response
    from pip._vendor.requests.utils import get_netrc_auth
    from pip._internal.utils.logging import getLogger
    from pip._internal.utils.misc import (
    from pip._internal.vcs.versioncontrol import AuthInfo
    KEYRING_DISABLED = False
    class Credentials(NamedTuple):
    class KeyRingBaseProvider(ABC):
        @abstractmethod
        def get_auth_info(
        @abstractmethod
        def save_auth_info(self, url: str, username: str, password: str) -> None: ...
    class KeyRingNullProvider(KeyRingBaseProvider):
        def get_auth_info(self, url: str, username: Optional[str]) -> Optional[AuthInfo]:
        def save_auth_info(self, url: str, username: str, password: str) -> None:
    class KeyRingPythonProvider(KeyRingBaseProvider):
        def __init__(self) -> None:
            import keyring
        def get_auth_info(self, url: str, username: Optional[str]) -> Optional[AuthInfo]:
        def save_auth_info(self, url: str, username: str, password: str) -> None:
    class KeyRingCliProvider(KeyRingBaseProvider):
        def __init__(self, cmd: str) -> None:
        def get_auth_info(self, url: str, username: Optional[str]) -> Optional[AuthInfo]:
        def save_auth_info(self, url: str, username: str, password: str) -> None:
        def _get_password(self, service_name: str, username: str) -> Optional[str]:
        def _set_password(self, service_name: str, username: str, password: str) -> None:
    @lru_cache(maxsize=None)
    def get_keyring_provider(provider: str) -> KeyRingBaseProvider:
                @typing.no_type_check
                def PATH_as_shutil_which_determines_it() -> str:
    class MultiDomainBasicAuth(AuthBase):
        def __init__(
        @property
        def keyring_provider(self) -> KeyRingBaseProvider:
        @keyring_provider.setter
        def keyring_provider(self, provider: str) -> None:
        @property
        def use_keyring(self) -> bool:
        def _get_keyring_auth(
                KEYRING_DISABLED = True
        def _get_index_url(self, url: str) -> Optional[str]:
        def _get_new_credentials(
        def _get_url_and_credentials(
        def __call__(self, req: Request) -> Request:
        def _prompt_for_password(
        def _should_save_password_to_keyring(self) -> bool:
        def handle_401(self, resp: Response, **kwargs: Any) -> Response:
            _ = resp.content
        def warn_on_401(self, resp: Response, **kwargs: Any) -> None:
        def save_credentials(self, resp: Response, **kwargs: Any) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: cache.py
    import os
    from contextlib import contextmanager
    from datetime import datetime
    from typing import BinaryIO, Generator, Optional, Union
    from pip._vendor.cachecontrol.cache import SeparateBodyBaseCache
    from pip._vendor.cachecontrol.caches import SeparateBodyFileCache
    from pip._vendor.requests.models import Response
    from pip._internal.utils.filesystem import adjacent_tmp_file, replace
    from pip._internal.utils.misc import ensure_dir
    def is_from_cache(response: Response) -> bool:
    @contextmanager
    def suppressed_cache_errors() -> Generator[None, None, None]:
    class SafeFileCache(SeparateBodyBaseCache):
        def __init__(self, directory: str) -> None:
        def _get_cache_path(self, name: str) -> str:
        def get(self, key: str) -> Optional[bytes]:
        def _write(self, path: str, data: bytes) -> None:
        def set(
        def delete(self, key: str) -> None:
        def get_body(self, key: str) -> Optional[BinaryIO]:
        def set_body(self, key: str, body: bytes) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: download.py
    import email.message
    import logging
    import mimetypes
    import os
    from typing import Iterable, Optional, Tuple
    from pip._vendor.requests.models import Response
    from pip._internal.cli.progress_bars import get_download_progress_renderer
    from pip._internal.exceptions import NetworkConnectionError
    from pip._internal.models.index import PyPI
    from pip._internal.models.link import Link
    from pip._internal.network.cache import is_from_cache
    from pip._internal.network.session import PipSession
    from pip._internal.network.utils import HEADERS, raise_for_status, response_chunks
    from pip._internal.utils.misc import format_size, redact_auth_from_url, splitext
    def _get_http_response_size(resp: Response) -> Optional[int]:
    def _prepare_download(
    def sanitize_content_filename(filename: str) -> str:
    def parse_content_disposition(content_disposition: str, default_filename: str) -> str:
    def _get_http_response_filename(resp: Response, link: Link) -> str:
    def _http_get_download(session: PipSession, link: Link) -> Response:
    class Downloader:
        def __init__(
        def __call__(self, link: Link, location: str) -> Tuple[str, str]:
    class BatchDownloader:
        def __init__(
        def __call__(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: lazy_wheel.py
    from bisect import bisect_left, bisect_right
    from contextlib import contextmanager
    from tempfile import NamedTemporaryFile
    from typing import Any, Dict, Generator, List, Optional, Tuple
    from zipfile import BadZipFile, ZipFile
    from pip._vendor.packaging.utils import canonicalize_name
    from pip._vendor.requests.models import CONTENT_CHUNK_SIZE, Response
    from pip._internal.metadata import BaseDistribution, MemoryWheel, get_wheel_distribution
    from pip._internal.network.session import PipSession
    from pip._internal.network.utils import HEADERS, raise_for_status, response_chunks
    class HTTPRangeRequestUnsupported(Exception):
    def dist_from_wheel_url(name: str, url: str, session: PipSession) -> BaseDistribution:
    class LazyZipOverHTTP:
        def __init__(
        @property
        def mode(self) -> str:
        @property
        def name(self) -> str:
        def seekable(self) -> bool:
        def close(self) -> None:
        @property
        def closed(self) -> bool:
        def read(self, size: int = -1) -> bytes:
        def readable(self) -> bool:
        def seek(self, offset: int, whence: int = 0) -> int:
        def tell(self) -> int:
        def truncate(self, size: Optional[int] = None) -> int:
        def writable(self) -> bool:
        def __enter__(self) -> "LazyZipOverHTTP":
        def __exit__(self, *exc: Any) -> None:
        @contextmanager
        def _stay(self) -> Generator[None, None, None]:
        def _check_zip(self) -> None:
        def _stream_response(
        def _merge(
        def _download(self, start: int, end: int) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: session.py
    import email.utils
    import functools
    import io
    import ipaddress
    import json
    import logging
    import mimetypes
    import os
    import platform
    import shutil
    import subprocess
    import sys
    import urllib.parse
    import warnings
    from typing import (
    from pip._vendor import requests, urllib3
    from pip._vendor.cachecontrol import CacheControlAdapter as _BaseCacheControlAdapter
    from pip._vendor.requests.adapters import DEFAULT_POOLBLOCK, BaseAdapter
    from pip._vendor.requests.adapters import HTTPAdapter as _BaseHTTPAdapter
    from pip._vendor.requests.models import PreparedRequest, Response
    from pip._vendor.requests.structures import CaseInsensitiveDict
    from pip._vendor.urllib3.connectionpool import ConnectionPool
    from pip._vendor.urllib3.exceptions import InsecureRequestWarning
    from pip import __version__
    from pip._internal.metadata import get_default_environment
    from pip._internal.models.link import Link
    from pip._internal.network.auth import MultiDomainBasicAuth
    from pip._internal.network.cache import SafeFileCache
    from pip._internal.utils.compat import has_tls
    from pip._internal.utils.glibc import libc_ver
    from pip._internal.utils.misc import build_url_from_netloc, parse_netloc
    from pip._internal.utils.urls import url_to_path
        from ssl import SSLContext
        from pip._vendor.urllib3.poolmanager import PoolManager
    CI_ENVIRONMENT_VARIABLES = (
    def looks_like_ci() -> bool:
    @functools.lru_cache(maxsize=1)
    def user_agent() -> str:
            from pip._vendor import distro
            import _ssl as ssl
    class LocalFSAdapter(BaseAdapter):
        def send(
        def close(self) -> None:
    class _SSLContextAdapterMixin:
        def __init__(
        def init_poolmanager(
    class HTTPAdapter(_SSLContextAdapterMixin, _BaseHTTPAdapter):
    class CacheControlAdapter(_SSLContextAdapterMixin, _BaseCacheControlAdapter):
    class InsecureHTTPAdapter(HTTPAdapter):
        def cert_verify(
    class InsecureCacheControlAdapter(CacheControlAdapter):
        def cert_verify(
    class PipSession(requests.Session):
        def __init__(
        def update_index_urls(self, new_index_urls: List[str]) -> None:
        def add_trusted_host(
        def iter_secure_origins(self) -> Generator[SecureOrigin, None, None]:
        def is_secure_origin(self, location: Link) -> bool:
        def request(self, method: str, url: str, *args: Any, **kwargs: Any) -> Response:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: utils.py
    from typing import Dict, Generator
    from pip._vendor.requests.models import Response
    from pip._internal.exceptions import NetworkConnectionError
    DOWNLOAD_CHUNK_SIZE = 256 * 1024
    def raise_for_status(resp: Response) -> None:
    def response_chunks(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: xmlrpc.py
    import logging
    import urllib.parse
    import xmlrpc.client
    from typing import TYPE_CHECKING, Tuple
    from pip._internal.exceptions import NetworkConnectionError
    from pip._internal.network.session import PipSession
    from pip._internal.network.utils import raise_for_status
        from xmlrpc.client import _HostType, _Marshallable
        from _typeshed import SizedBuffer
    class PipXmlrpcTransport(xmlrpc.client.Transport):
        def __init__(
        def request(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\operations

  ðŸ“„ Ð¤Ð°Ð¹Ð»: check.py
    import logging
    from contextlib import suppress
    from email.parser import Parser
    from functools import reduce
    from typing import (
    from pip._vendor.packaging.requirements import Requirement
    from pip._vendor.packaging.tags import Tag, parse_tag
    from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
    from pip._vendor.packaging.version import Version
    from pip._internal.distributions import make_distribution_for_install_requirement
    from pip._internal.metadata import get_default_environment
    from pip._internal.metadata.base import BaseDistribution
    from pip._internal.req.req_install import InstallRequirement
    class PackageDetails(NamedTuple):
    def create_package_set_from_installed() -> Tuple[PackageSet, bool]:
    def check_package_set(
    def check_install_conflicts(to_install: List[InstallRequirement]) -> ConflictDetails:
    def check_unsupported(
    def _simulate_installation_of(
    def _create_whitelist(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: freeze.py
    import collections
    import logging
    import os
    from dataclasses import dataclass, field
    from typing import Container, Dict, Generator, Iterable, List, NamedTuple, Optional, Set
    from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
    from pip._vendor.packaging.version import InvalidVersion
    from pip._internal.exceptions import BadCommand, InstallationError
    from pip._internal.metadata import BaseDistribution, get_environment
    from pip._internal.req.constructors import (
    from pip._internal.req.req_file import COMMENT_RE
    from pip._internal.utils.direct_url_helpers import direct_url_as_pep440_direct_reference
    class _EditableInfo(NamedTuple):
    def freeze(
    def _format_as_name_version(dist: BaseDistribution) -> str:
    def _get_editable_info(dist: BaseDistribution) -> _EditableInfo:
        from pip._internal.vcs import RemoteNotFoundError, RemoteNotValidError, vcs
    @dataclass(frozen=True)
    class FrozenRequirement:
        @property
        def canonical_name(self) -> NormalizedName:
        @classmethod
        def from_dist(cls, dist: BaseDistribution) -> "FrozenRequirement":
        def __str__(self) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: prepare.py
    import mimetypes
    import os
    import shutil
    from dataclasses import dataclass
    from pathlib import Path
    from typing import Dict, Iterable, List, Optional
    from pip._vendor.packaging.utils import canonicalize_name
    from pip._internal.distributions import make_distribution_for_install_requirement
    from pip._internal.distributions.installed import InstalledDistribution
    from pip._internal.exceptions import (
    from pip._internal.index.package_finder import PackageFinder
    from pip._internal.metadata import BaseDistribution, get_metadata_distribution
    from pip._internal.models.direct_url import ArchiveInfo
    from pip._internal.models.link import Link
    from pip._internal.models.wheel import Wheel
    from pip._internal.network.download import BatchDownloader, Downloader
    from pip._internal.network.lazy_wheel import (
    from pip._internal.network.session import PipSession
    from pip._internal.operations.build.build_tracker import BuildTracker
    from pip._internal.req.req_install import InstallRequirement
    from pip._internal.utils._log import getLogger
    from pip._internal.utils.direct_url_helpers import (
    from pip._internal.utils.hashes import Hashes, MissingHashes
    from pip._internal.utils.logging import indent_log
    from pip._internal.utils.misc import (
    from pip._internal.utils.temp_dir import TempDirectory
    from pip._internal.utils.unpacking import unpack_file
    from pip._internal.vcs import vcs
    def _get_prepared_distribution(
    def unpack_vcs_link(link: Link, location: str, verbosity: int) -> None:
    @dataclass
    class File:
        def __post_init__(self) -> None:
    def get_http_url(
    def get_file_url(
    def unpack_url(
    def _check_download_dir(
    class RequirementPreparer:
        def __init__(
        def _log_preparing_link(self, req: InstallRequirement) -> None:
        def _ensure_link_req_src_dir(
        def _get_linked_req_hashes(self, req: InstallRequirement) -> Hashes:
        def _fetch_metadata_only(
        def _fetch_metadata_using_link_data_attr(
        def _fetch_metadata_using_lazy_wheel(
        def _complete_partial_requirements(
        def prepare_linked_requirement(
        def prepare_linked_requirements_more(
        def _prepare_linked_requirement(
        def save_linked_requirement(self, req: InstallRequirement) -> None:
        def prepare_editable_requirement(
        def prepare_installed_requirement(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\operations\build

  ðŸ“„ Ð¤Ð°Ð¹Ð»: build_tracker.py
    import contextlib
    import hashlib
    import logging
    import os
    from types import TracebackType
    from typing import Dict, Generator, Optional, Type, Union
    from pip._internal.req.req_install import InstallRequirement
    from pip._internal.utils.temp_dir import TempDirectory
    @contextlib.contextmanager
    def update_env_context_manager(**changes: str) -> Generator[None, None, None]:
    @contextlib.contextmanager
    def get_build_tracker() -> Generator["BuildTracker", None, None]:
    class TrackerId(str):
    class BuildTracker:
        def __init__(self, root: str) -> None:
        def __enter__(self) -> "BuildTracker":
        def __exit__(
        def _entry_path(self, key: TrackerId) -> str:
        def add(self, req: InstallRequirement, key: TrackerId) -> None:
        def remove(self, req: InstallRequirement, key: TrackerId) -> None:
        def cleanup(self) -> None:
        @contextlib.contextmanager
        def track(self, req: InstallRequirement, key: str) -> Generator[None, None, None]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: metadata.py
    import os
    from pip._vendor.pyproject_hooks import BuildBackendHookCaller
    from pip._internal.build_env import BuildEnvironment
    from pip._internal.exceptions import (
    from pip._internal.utils.subprocess import runner_with_spinner_message
    from pip._internal.utils.temp_dir import TempDirectory
    def generate_metadata(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: metadata_editable.py
    import os
    from pip._vendor.pyproject_hooks import BuildBackendHookCaller
    from pip._internal.build_env import BuildEnvironment
    from pip._internal.exceptions import (
    from pip._internal.utils.subprocess import runner_with_spinner_message
    from pip._internal.utils.temp_dir import TempDirectory
    def generate_editable_metadata(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: metadata_legacy.py
    import logging
    import os
    from pip._internal.build_env import BuildEnvironment
    from pip._internal.cli.spinners import open_spinner
    from pip._internal.exceptions import (
    from pip._internal.utils.setuptools_build import make_setuptools_egg_info_args
    from pip._internal.utils.subprocess import call_subprocess
    from pip._internal.utils.temp_dir import TempDirectory
    def _find_egg_info(directory: str) -> str:
    def generate_metadata(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: wheel.py
    import logging
    import os
    from typing import Optional
    from pip._vendor.pyproject_hooks import BuildBackendHookCaller
    from pip._internal.utils.subprocess import runner_with_spinner_message
    def build_wheel_pep517(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: wheel_editable.py
    import logging
    import os
    from typing import Optional
    from pip._vendor.pyproject_hooks import BuildBackendHookCaller, HookMissing
    from pip._internal.utils.subprocess import runner_with_spinner_message
    def build_wheel_editable(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: wheel_legacy.py
    import logging
    import os.path
    from typing import List, Optional
    from pip._internal.cli.spinners import open_spinner
    from pip._internal.utils.setuptools_build import make_setuptools_bdist_wheel_args
    from pip._internal.utils.subprocess import call_subprocess, format_command_args
    def format_command_result(
    def get_legacy_build_wheel_path(
    def build_wheel_legacy(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\operations\install

  ðŸ“„ Ð¤Ð°Ð¹Ð»: editable_legacy.py
    import logging
    from typing import Optional, Sequence
    from pip._internal.build_env import BuildEnvironment
    from pip._internal.utils.logging import indent_log
    from pip._internal.utils.setuptools_build import make_setuptools_develop_args
    from pip._internal.utils.subprocess import call_subprocess
    def install_editable(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: wheel.py
    import collections
    import compileall
    import contextlib
    import csv
    import importlib
    import logging
    import os.path
    import re
    import shutil
    import sys
    import warnings
    from base64 import urlsafe_b64encode
    from email.message import Message
    from itertools import chain, filterfalse, starmap
    from typing import (
    from zipfile import ZipFile, ZipInfo
    from pip._vendor.distlib.scripts import ScriptMaker
    from pip._vendor.distlib.util import get_export_entry
    from pip._vendor.packaging.utils import canonicalize_name
    from pip._internal.exceptions import InstallationError
    from pip._internal.locations import get_major_minor_version
    from pip._internal.metadata import (
    from pip._internal.models.direct_url import DIRECT_URL_METADATA_NAME, DirectUrl
    from pip._internal.models.scheme import SCHEME_KEYS, Scheme
    from pip._internal.utils.filesystem import adjacent_tmp_file, replace
    from pip._internal.utils.misc import StreamWrapper, ensure_dir, hash_file, partition
    from pip._internal.utils.unpacking import (
    from pip._internal.utils.wheel import parse_wheel
        class File(Protocol):
            def save(self) -> None:
    def rehash(path: str, blocksize: int = 1 << 20) -> Tuple[str, str]:
    def csv_io_kwargs(mode: str) -> Dict[str, Any]:
    def fix_script(path: str) -> bool:
    def wheel_root_is_purelib(metadata: Message) -> bool:
    def get_entrypoints(dist: BaseDistribution) -> Tuple[Dict[str, str], Dict[str, str]]:
    def message_about_scripts_not_on_PATH(scripts: Sequence[str]) -> Optional[str]:
    def _normalized_outrows(
    def _record_to_fs_path(record_path: RecordPath, lib_dir: str) -> str:
    def _fs_to_record_path(path: str, lib_dir: str) -> RecordPath:
    def get_csv_rows_for_installed(
    def get_console_script_specs(console: Dict[str, str]) -> List[str]:
    class ZipBackedFile:
        def __init__(
        def _getinfo(self) -> ZipInfo:
        def save(self) -> None:
    class ScriptFile:
        def __init__(self, file: "File") -> None:
        def save(self) -> None:
    class MissingCallableSuffix(InstallationError):
        def __init__(self, entry_point: str) -> None:
    def _raise_for_invalid_entrypoint(specification: str) -> None:
    class PipScriptMaker(ScriptMaker):
        def make(
    def _install_wheel(  # noqa: C901, PLR0915 function is too long
        def record_installed(
        def is_dir_path(path: RecordPath) -> bool:
        def assert_no_path_traversal(dest_dir_path: str, target_path: str) -> None:
        def root_scheme_file_maker(
            def make_root_scheme_file(record_path: RecordPath) -> "File":
        def data_scheme_file_maker(
            def make_data_scheme_file(record_path: RecordPath) -> "File":
        def is_data_scheme_path(path: RecordPath) -> bool:
        def is_script_scheme_path(path: RecordPath) -> bool:
        def is_entrypoint_wrapper(file: "File") -> bool:
        def pyc_source_file_paths() -> Generator[str, None, None]:
        def pyc_output_path(path: str) -> str:
        @contextlib.contextmanager
        def _generate_file(path: str, **kwargs: Any) -> Generator[BinaryIO, None, None]:
    @contextlib.contextmanager
    def req_error_context(req_description: str) -> Generator[None, None, None]:
    def install_wheel(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\req

  ðŸ“„ Ð¤Ð°Ð¹Ð»: constructors.py
    import copy
    import logging
    import os
    import re
    from dataclasses import dataclass
    from typing import Collection, Dict, List, Optional, Set, Tuple, Union
    from pip._vendor.packaging.markers import Marker
    from pip._vendor.packaging.requirements import InvalidRequirement, Requirement
    from pip._vendor.packaging.specifiers import Specifier
    from pip._internal.exceptions import InstallationError
    from pip._internal.models.index import PyPI, TestPyPI
    from pip._internal.models.link import Link
    from pip._internal.models.wheel import Wheel
    from pip._internal.req.req_file import ParsedRequirement
    from pip._internal.req.req_install import InstallRequirement
    from pip._internal.utils.filetypes import is_archive_file
    from pip._internal.utils.misc import is_installable_dir
    from pip._internal.utils.packaging import get_requirement
    from pip._internal.utils.urls import path_to_url
    from pip._internal.vcs import is_url, vcs
    def _strip_extras(path: str) -> Tuple[str, Optional[str]]:
    def convert_extras(extras: Optional[str]) -> Set[str]:
    def _set_requirement_extras(req: Requirement, new_extras: Set[str]) -> Requirement:
    def parse_editable(editable_req: str) -> Tuple[Optional[str], str, Set[str]]:
    def check_first_requirement_in_file(filename: str) -> None:
    def deduce_helpful_msg(req: str) -> str:
    @dataclass(frozen=True)
    class RequirementParts:
    def parse_req_from_editable(editable_req: str) -> RequirementParts:
    def install_req_from_editable(
    def _looks_like_path(name: str) -> bool:
    def _get_url_from_path(path: str, name: str) -> Optional[str]:
    def parse_req_from_line(name: str, line_source: Optional[str]) -> RequirementParts:
        def with_source(text: str) -> str:
        def _parse_req_string(req_as_string: str) -> Requirement:
    def install_req_from_line(
    def install_req_from_req_string(
    def install_req_from_parsed_requirement(
    def install_req_from_link_and_ireq(
    def install_req_drop_extras(ireq: InstallRequirement) -> InstallRequirement:
    def install_req_extend_extras(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: req_file.py
    import codecs
    import locale
    import logging
    import optparse
    import os
    import re
    import shlex
    import sys
    import urllib.parse
    from dataclasses import dataclass
    from optparse import Values
    from typing import (
    from pip._internal.cli import cmdoptions
    from pip._internal.exceptions import InstallationError, RequirementsFileParseError
    from pip._internal.models.search_scope import SearchScope
        from pip._internal.index.package_finder import PackageFinder
        from pip._internal.network.session import PipSession
    SCHEME_RE = re.compile(r"^(http|https|file):", re.I)
    COMMENT_RE = re.compile(r"(^|\s+)#.*$")
    ENV_VAR_RE = re.compile(r"(?P<var>\$\{(?P<name>[A-Z0-9_]+)\})")
    SUPPORTED_OPTIONS_REQ_DEST = [str(o().dest) for o in SUPPORTED_OPTIONS_REQ]
    SUPPORTED_OPTIONS_EDITABLE_REQ_DEST = [
    DEFAULT_ENCODING = "utf-8"
    @dataclass(frozen=True)
    class ParsedRequirement:
    @dataclass(frozen=True)
    class ParsedLine:
        @property
        def is_editable(self) -> bool:
        @property
        def requirement(self) -> Optional[str]:
    def parse_requirements(
    def preprocess(content: str) -> ReqFileLines:
    def handle_requirement_line(
    def handle_option_line(
    def handle_line(
    class RequirementsFileParser:
        def __init__(
        def parse(
        def _parse_and_recurse(
        def _parse_file(
    def get_line_parser(finder: Optional["PackageFinder"]) -> LineParser:
        def parse_line(line: str) -> Tuple[str, Values]:
    def break_args_options(line: str) -> Tuple[str, str]:
    class OptionParsingError(Exception):
        def __init__(self, msg: str) -> None:
    def build_parser() -> optparse.OptionParser:
        def parser_exit(self: Any, msg: str) -> "NoReturn":
    def join_lines(lines_enum: ReqFileLines) -> ReqFileLines:
    def ignore_comments(lines_enum: ReqFileLines) -> ReqFileLines:
    def expand_env_variables(lines_enum: ReqFileLines) -> ReqFileLines:
    def get_file_content(url: str, session: "PipSession") -> Tuple[str, str]:
            from pip._internal.network.utils import raise_for_status
    def _decode_req_file(data: bytes, url: str) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: req_install.py
    import functools
    import logging
    import os
    import shutil
    import sys
    import uuid
    import zipfile
    from optparse import Values
    from pathlib import Path
    from typing import Any, Collection, Dict, Iterable, List, Optional, Sequence, Union
    from pip._vendor.packaging.markers import Marker
    from pip._vendor.packaging.requirements import Requirement
    from pip._vendor.packaging.specifiers import SpecifierSet
    from pip._vendor.packaging.utils import canonicalize_name
    from pip._vendor.packaging.version import Version
    from pip._vendor.packaging.version import parse as parse_version
    from pip._vendor.pyproject_hooks import BuildBackendHookCaller
    from pip._internal.build_env import BuildEnvironment, NoOpBuildEnvironment
    from pip._internal.exceptions import InstallationError, PreviousBuildDirError
    from pip._internal.locations import get_scheme
    from pip._internal.metadata import (
    from pip._internal.metadata.base import FilesystemWheel
    from pip._internal.models.direct_url import DirectUrl
    from pip._internal.models.link import Link
    from pip._internal.operations.build.metadata import generate_metadata
    from pip._internal.operations.build.metadata_editable import generate_editable_metadata
    from pip._internal.operations.build.metadata_legacy import (
    from pip._internal.operations.install.editable_legacy import (
    from pip._internal.operations.install.wheel import install_wheel
    from pip._internal.pyproject import load_pyproject_toml, make_pyproject_path
    from pip._internal.req.req_uninstall import UninstallPathSet
    from pip._internal.utils.deprecation import deprecated
    from pip._internal.utils.hashes import Hashes
    from pip._internal.utils.misc import (
    from pip._internal.utils.packaging import get_requirement
    from pip._internal.utils.subprocess import runner_with_spinner_message
    from pip._internal.utils.temp_dir import TempDirectory, tempdir_kinds
    from pip._internal.utils.unpacking import unpack_file
    from pip._internal.utils.virtualenv import running_under_virtualenv
    from pip._internal.vcs import vcs
    class InstallRequirement:
        def __init__(
        def __str__(self) -> str:
        def __repr__(self) -> str:
        def format_debug(self) -> str:
        @property
        def name(self) -> Optional[str]:
        @functools.cached_property
        def supports_pyproject_editable(self) -> bool:
        @property
        def specifier(self) -> SpecifierSet:
        @property
        def is_direct(self) -> bool:
        @property
        def is_pinned(self) -> bool:
        def match_markers(self, extras_requested: Optional[Iterable[str]] = None) -> bool:
        @property
        def has_hash_options(self) -> bool:
        def hashes(self, trust_internet: bool = True) -> Hashes:
        def from_path(self) -> Optional[str]:
        def ensure_build_location(
        def _set_requirement(self) -> None:
        def warn_on_mismatching_name(self) -> None:
        def check_if_exists(self, use_user_site: bool) -> None:
        @property
        def is_wheel(self) -> bool:
        @property
        def is_wheel_from_cache(self) -> bool:
        @property
        def unpacked_source_directory(self) -> str:
        @property
        def setup_py_path(self) -> str:
        @property
        def setup_cfg_path(self) -> str:
        @property
        def pyproject_toml_path(self) -> str:
        def load_pyproject_toml(self) -> None:
        def isolated_editable_sanity_check(self) -> None:
        def prepare_metadata(self) -> None:
        @property
        def metadata(self) -> Any:
        def get_dist(self) -> BaseDistribution:
        def assert_source_matches_version(self) -> None:
        def ensure_has_source_dir(
        def needs_unpacked_archive(self, archive_source: Path) -> None:
        def ensure_pristine_source_checkout(self) -> None:
        def update_editable(self) -> None:
        def uninstall(
        def _get_archive_name(self, path: str, parentdir: str, rootdir: str) -> str:
            def _clean_zip_name(name: str, prefix: str) -> str:
        def archive(self, build_dir: Optional[str]) -> None:
        def install(
    def check_invalid_constraint_type(req: InstallRequirement) -> str:
    def _has_option(options: Values, reqs: List[InstallRequirement], option: str) -> bool:
    def check_legacy_setup_py_options(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: req_set.py
    import logging
    from collections import OrderedDict
    from typing import Dict, List
    from pip._vendor.packaging.utils import canonicalize_name
    from pip._internal.req.req_install import InstallRequirement
    class RequirementSet:
        def __init__(self, check_supported_wheels: bool = True) -> None:
        def __str__(self) -> str:
        def __repr__(self) -> str:
        def add_unnamed_requirement(self, install_req: InstallRequirement) -> None:
        def add_named_requirement(self, install_req: InstallRequirement) -> None:
        def has_requirement(self, name: str) -> bool:
        def get_requirement(self, name: str) -> InstallRequirement:
        @property
        def all_requirements(self) -> List[InstallRequirement]:
        @property
        def requirements_to_install(self) -> List[InstallRequirement]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: req_uninstall.py
    import functools
    import os
    import sys
    import sysconfig
    from importlib.util import cache_from_source
    from typing import Any, Callable, Dict, Generator, Iterable, List, Optional, Set, Tuple
    from pip._internal.exceptions import LegacyDistutilsInstall, UninstallMissingRecord
    from pip._internal.locations import get_bin_prefix, get_bin_user
    from pip._internal.metadata import BaseDistribution
    from pip._internal.utils.compat import WINDOWS
    from pip._internal.utils.egg_link import egg_link_path_from_location
    from pip._internal.utils.logging import getLogger, indent_log
    from pip._internal.utils.misc import ask, normalize_path, renames, rmtree
    from pip._internal.utils.temp_dir import AdjacentTempDirectory, TempDirectory
    from pip._internal.utils.virtualenv import running_under_virtualenv
    def _script_names(
    def _unique(
        @functools.wraps(fn)
        def unique(*args: Any, **kw: Any) -> Generator[Any, None, None]:
    @_unique
    def uninstallation_paths(dist: BaseDistribution) -> Generator[str, None, None]:
    def compact(paths: Iterable[str]) -> Set[str]:
    def compress_for_rename(paths: Iterable[str]) -> Set[str]:
        def norm_join(*a: str) -> str:
    def compress_for_output_listing(paths: Iterable[str]) -> Tuple[Set[str], Set[str]]:
    class StashedUninstallPathSet:
        def __init__(self) -> None:
        def _get_directory_stash(self, path: str) -> str:
        def _get_file_stash(self, path: str) -> str:
        def stash(self, path: str) -> str:
        def commit(self) -> None:
        def rollback(self) -> None:
        @property
        def can_rollback(self) -> bool:
    class UninstallPathSet:
        def __init__(self, dist: BaseDistribution) -> None:
        def _permitted(self, path: str) -> bool:
        def add(self, path: str) -> None:
        def add_pth(self, pth_file: str, entry: str) -> None:
        def remove(self, auto_confirm: bool = False, verbose: bool = False) -> None:
        def _allowed_to_proceed(self, verbose: bool) -> bool:
            def _display(msg: str, paths: Iterable[str]) -> None:
        def rollback(self) -> None:
        def commit(self) -> None:
        @classmethod
        def from_dist(cls, dist: BaseDistribution) -> "UninstallPathSet":
            def iter_scripts_to_remove(
    class UninstallPthEntries:
        def __init__(self, pth_file: str) -> None:
        def add(self, entry: str) -> None:
        def remove(self) -> None:
        def rollback(self) -> bool:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    import collections
    import logging
    from dataclasses import dataclass
    from typing import Generator, List, Optional, Sequence, Tuple
    from pip._internal.utils.logging import indent_log
    from .req_file import parse_requirements
    from .req_install import InstallRequirement
    from .req_set import RequirementSet
    @dataclass(frozen=True)
    class InstallationResult:
    def _validate_requirements(
    def install_given_reqs(

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\resolution

  ðŸ“„ Ð¤Ð°Ð¹Ð»: base.py
    from typing import Callable, List, Optional
    from pip._internal.req.req_install import InstallRequirement
    from pip._internal.req.req_set import RequirementSet
    class BaseResolver:
        def resolve(
        def get_installation_order(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\resolution\legacy

  ðŸ“„ Ð¤Ð°Ð¹Ð»: resolver.py
    import logging
    import sys
    from collections import defaultdict
    from itertools import chain
    from typing import DefaultDict, Iterable, List, Optional, Set, Tuple
    from pip._vendor.packaging import specifiers
    from pip._vendor.packaging.requirements import Requirement
    from pip._internal.cache import WheelCache
    from pip._internal.exceptions import (
    from pip._internal.index.package_finder import PackageFinder
    from pip._internal.metadata import BaseDistribution
    from pip._internal.models.link import Link
    from pip._internal.models.wheel import Wheel
    from pip._internal.operations.prepare import RequirementPreparer
    from pip._internal.req.req_install import (
    from pip._internal.req.req_set import RequirementSet
    from pip._internal.resolution.base import BaseResolver, InstallRequirementProvider
    from pip._internal.utils import compatibility_tags
    from pip._internal.utils.compatibility_tags import get_supported
    from pip._internal.utils.direct_url_helpers import direct_url_from_link
    from pip._internal.utils.logging import indent_log
    from pip._internal.utils.misc import normalize_version_info
    from pip._internal.utils.packaging import check_requires_python
    def _check_dist_requires_python(
    class Resolver(BaseResolver):
        def __init__(
        def resolve(
        def _add_requirement_to_set(
        def _is_upgrade_allowed(self, req: InstallRequirement) -> bool:
        def _set_req_to_reinstall(self, req: InstallRequirement) -> None:
        def _check_skip_installed(
        def _find_requirement_link(self, req: InstallRequirement) -> Optional[Link]:
        def _populate_link(self, req: InstallRequirement) -> None:
        def _get_dist_for(self, req: InstallRequirement) -> BaseDistribution:
        def _resolve_one(
            def add_req(subreq: Requirement, extras_requested: Iterable[str]) -> None:
        def get_installation_order(
            def schedule(req: InstallRequirement) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\resolution\resolvelib

  ðŸ“„ Ð¤Ð°Ð¹Ð»: base.py
    from dataclasses import dataclass
    from typing import FrozenSet, Iterable, Optional, Tuple
    from pip._vendor.packaging.specifiers import SpecifierSet
    from pip._vendor.packaging.utils import NormalizedName
    from pip._vendor.packaging.version import Version
    from pip._internal.models.link import Link, links_equivalent
    from pip._internal.req.req_install import InstallRequirement
    from pip._internal.utils.hashes import Hashes
    def format_name(project: NormalizedName, extras: FrozenSet[NormalizedName]) -> str:
    @dataclass(frozen=True)
    class Constraint:
        @classmethod
        def empty(cls) -> "Constraint":
        @classmethod
        def from_ireq(cls, ireq: InstallRequirement) -> "Constraint":
        def __bool__(self) -> bool:
        def __and__(self, other: InstallRequirement) -> "Constraint":
        def is_satisfied_by(self, candidate: "Candidate") -> bool:
    class Requirement:
        @property
        def project_name(self) -> NormalizedName:
        @property
        def name(self) -> str:
        def is_satisfied_by(self, candidate: "Candidate") -> bool:
        def get_candidate_lookup(self) -> CandidateLookup:
        def format_for_error(self) -> str:
    def _match_link(link: Link, candidate: "Candidate") -> bool:
    class Candidate:
        @property
        def project_name(self) -> NormalizedName:
        @property
        def name(self) -> str:
        @property
        def version(self) -> Version:
        @property
        def is_installed(self) -> bool:
        @property
        def is_editable(self) -> bool:
        @property
        def source_link(self) -> Optional[Link]:
        def iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:
        def get_install_requirement(self) -> Optional[InstallRequirement]:
        def format_for_error(self) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: candidates.py
    import logging
    import sys
    from typing import TYPE_CHECKING, Any, FrozenSet, Iterable, Optional, Tuple, Union, cast
    from pip._vendor.packaging.requirements import InvalidRequirement
    from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
    from pip._vendor.packaging.version import Version
    from pip._internal.exceptions import (
    from pip._internal.metadata import BaseDistribution
    from pip._internal.models.link import Link, links_equivalent
    from pip._internal.models.wheel import Wheel
    from pip._internal.req.constructors import (
    from pip._internal.req.req_install import InstallRequirement
    from pip._internal.utils.direct_url_helpers import direct_url_from_link
    from pip._internal.utils.misc import normalize_version_info
    from .base import Candidate, Requirement, format_name
        from .factory import Factory
    REQUIRES_PYTHON_IDENTIFIER = cast(NormalizedName, "<Python from Requires-Python>")
    def as_base_candidate(candidate: Candidate) -> Optional[BaseCandidate]:
    def make_install_req_from_link(
    def make_install_req_from_editable(
    def _make_install_req_from_dist(
    class _InstallRequirementBackedCandidate(Candidate):
        class exposes appropriate information to the resolver.
        def __init__(
        def __str__(self) -> str:
        def __repr__(self) -> str:
        def __hash__(self) -> int:
        def __eq__(self, other: Any) -> bool:
        @property
        def source_link(self) -> Optional[Link]:
        @property
        def project_name(self) -> NormalizedName:
        @property
        def name(self) -> str:
        @property
        def version(self) -> Version:
        def format_for_error(self) -> str:
        def _prepare_distribution(self) -> BaseDistribution:
        def _check_metadata_consistency(self, dist: BaseDistribution) -> None:
        def _prepare(self) -> BaseDistribution:
        def iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:
        def get_install_requirement(self) -> Optional[InstallRequirement]:
    class LinkCandidate(_InstallRequirementBackedCandidate):
        def __init__(
        def _prepare_distribution(self) -> BaseDistribution:
    class EditableCandidate(_InstallRequirementBackedCandidate):
        def __init__(
        def _prepare_distribution(self) -> BaseDistribution:
    class AlreadyInstalledCandidate(Candidate):
        def __init__(
        def __str__(self) -> str:
        def __repr__(self) -> str:
        def __eq__(self, other: object) -> bool:
        def __hash__(self) -> int:
        @property
        def project_name(self) -> NormalizedName:
        @property
        def name(self) -> str:
        @property
        def version(self) -> Version:
        @property
        def is_editable(self) -> bool:
        def format_for_error(self) -> str:
        def iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:
        def get_install_requirement(self) -> Optional[InstallRequirement]:
    class ExtrasCandidate(Candidate):
        def __init__(
        def __str__(self) -> str:
        def __repr__(self) -> str:
        def __hash__(self) -> int:
        def __eq__(self, other: Any) -> bool:
        @property
        def project_name(self) -> NormalizedName:
        @property
        def name(self) -> str:
        @property
        def version(self) -> Version:
        def format_for_error(self) -> str:
        @property
        def is_installed(self) -> bool:
        @property
        def is_editable(self) -> bool:
        @property
        def source_link(self) -> Optional[Link]:
        def iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:
        def get_install_requirement(self) -> Optional[InstallRequirement]:
    class RequiresPythonCandidate(Candidate):
        def __init__(self, py_version_info: Optional[Tuple[int, ...]]) -> None:
        def __str__(self) -> str:
        @property
        def project_name(self) -> NormalizedName:
        @property
        def name(self) -> str:
        @property
        def version(self) -> Version:
        def format_for_error(self) -> str:
        def iter_dependencies(self, with_requires: bool) -> Iterable[Optional[Requirement]]:
        def get_install_requirement(self) -> Optional[InstallRequirement]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: factory.py
    import contextlib
    import functools
    import logging
    from typing import (
    from pip._vendor.packaging.requirements import InvalidRequirement
    from pip._vendor.packaging.specifiers import SpecifierSet
    from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
    from pip._vendor.packaging.version import InvalidVersion, Version
    from pip._vendor.resolvelib import ResolutionImpossible
    from pip._internal.cache import CacheEntry, WheelCache
    from pip._internal.exceptions import (
    from pip._internal.index.package_finder import PackageFinder
    from pip._internal.metadata import BaseDistribution, get_default_environment
    from pip._internal.models.link import Link
    from pip._internal.models.wheel import Wheel
    from pip._internal.operations.prepare import RequirementPreparer
    from pip._internal.req.constructors import (
    from pip._internal.req.req_install import (
    from pip._internal.resolution.base import InstallRequirementProvider
    from pip._internal.utils.compatibility_tags import get_supported
    from pip._internal.utils.hashes import Hashes
    from pip._internal.utils.packaging import get_requirement
    from pip._internal.utils.virtualenv import running_under_virtualenv
    from .base import Candidate, Constraint, Requirement
    from .candidates import (
    from .found_candidates import FoundCandidates, IndexCandidateInfo
    from .requirements import (
        class ConflictCause(Protocol):
    C = TypeVar("C")
    class CollectedRootRequirements(NamedTuple):
    class Factory:
        def __init__(
        @property
        def force_reinstall(self) -> bool:
        def _fail_if_link_is_unsupported_wheel(self, link: Link) -> None:
        def _make_extras_candidate(
        def _make_candidate_from_dist(
        def _make_candidate_from_link(
        def _make_base_candidate_from_link(
        def _iter_found_candidates(
            def _get_installed_candidate() -> Optional[Candidate]:
            def iter_index_candidate_infos() -> Iterator[IndexCandidateInfo]:
                def is_pinned(specifier: SpecifierSet) -> bool:
        def _iter_explicit_candidates_from_base(
        def _iter_candidates_from_constraints(
        def find_candidates(
        def _make_requirements_from_install_req(
        def collect_root_requirements(
        def make_requirement_from_candidate(
        def make_requirements_from_spec(
        def make_requires_python_requirement(
        def get_wheel_cache_entry(
        def get_dist_to_uninstall(self, candidate: Candidate) -> Optional[BaseDistribution]:
        def _report_requires_python_error(
        def _report_single_requirement_conflict(
        def get_installation_error(
            def text_join(parts: List[str]) -> str:
            def describe_trigger(parent: Candidate) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: found_candidates.py
    import functools
    import logging
    from collections.abc import Sequence
    from typing import TYPE_CHECKING, Any, Callable, Iterator, Optional, Set, Tuple
    from pip._vendor.packaging.version import _BaseVersion
    from pip._internal.exceptions import MetadataInvalid
    from .base import Candidate
    def _iter_built(infos: Iterator[IndexCandidateInfo]) -> Iterator[Candidate]:
        from index come later in their normal ordering.
    def _iter_built_with_prepended(
    def _iter_built_with_inserted(
    class FoundCandidates(SequenceCandidate):
        def __init__(
        def __getitem__(self, index: Any) -> Any:
        def __iter__(self) -> Iterator[Candidate]:
        def __len__(self) -> int:
        @functools.lru_cache(maxsize=1)
        def __bool__(self) -> bool:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: provider.py
    import collections
    import math
    from functools import lru_cache
    from typing import (
    from pip._vendor.resolvelib.providers import AbstractProvider
    from .base import Candidate, Constraint, Requirement
    from .candidates import REQUIRES_PYTHON_IDENTIFIER
    from .factory import Factory
        from pip._vendor.resolvelib.providers import Preference
        from pip._vendor.resolvelib.resolvers import RequirementInformation
    D = TypeVar("D")
    V = TypeVar("V")
    def _get_with_identifier(
    class PipProvider(_ProviderBase):
        def __init__(
        def identify(self, requirement_or_candidate: Union[Requirement, Candidate]) -> str:
        def get_preference(
        def find_matches(
            def _eligible_for_upgrade(identifier: str) -> bool:
        @lru_cache(maxsize=None)
        def is_satisfied_by(self, requirement: Requirement, candidate: Candidate) -> bool:
        def get_dependencies(self, candidate: Candidate) -> Sequence[Requirement]:
        @staticmethod
        def is_backtrack_cause(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: reporter.py
    from collections import defaultdict
    from logging import getLogger
    from typing import Any, DefaultDict
    from pip._vendor.resolvelib.reporters import BaseReporter
    from .base import Candidate, Requirement
    class PipReporter(BaseReporter):
        def __init__(self) -> None:
        def rejecting_candidate(self, criterion: Any, candidate: Candidate) -> None:
    class PipDebuggingReporter(BaseReporter):
        def starting(self) -> None:
        def starting_round(self, index: int) -> None:
        def ending_round(self, index: int, state: Any) -> None:
        def ending(self, state: Any) -> None:
        def adding_requirement(self, requirement: Requirement, parent: Candidate) -> None:
        def rejecting_candidate(self, criterion: Any, candidate: Candidate) -> None:
        def pinning(self, candidate: Candidate) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: requirements.py
    from typing import Any, Optional
    from pip._vendor.packaging.specifiers import SpecifierSet
    from pip._vendor.packaging.utils import NormalizedName, canonicalize_name
    from pip._internal.req.constructors import install_req_drop_extras
    from pip._internal.req.req_install import InstallRequirement
    from .base import Candidate, CandidateLookup, Requirement, format_name
    class ExplicitRequirement(Requirement):
        def __init__(self, candidate: Candidate) -> None:
        def __str__(self) -> str:
        def __repr__(self) -> str:
        def __hash__(self) -> int:
        def __eq__(self, other: Any) -> bool:
        @property
        def project_name(self) -> NormalizedName:
        @property
        def name(self) -> str:
        def format_for_error(self) -> str:
        def get_candidate_lookup(self) -> CandidateLookup:
        def is_satisfied_by(self, candidate: Candidate) -> bool:
    class SpecifierRequirement(Requirement):
        def __init__(self, ireq: InstallRequirement) -> None:
        @property
        def _equal(self) -> str:
        def __str__(self) -> str:
        def __repr__(self) -> str:
        def __eq__(self, other: object) -> bool:
        def __hash__(self) -> int:
        @property
        def project_name(self) -> NormalizedName:
        @property
        def name(self) -> str:
        def format_for_error(self) -> str:
        def get_candidate_lookup(self) -> CandidateLookup:
        def is_satisfied_by(self, candidate: Candidate) -> bool:
    class SpecifierWithoutExtrasRequirement(SpecifierRequirement):
        def __init__(self, ireq: InstallRequirement) -> None:
        @property
        def _equal(self) -> str:
        def __eq__(self, other: object) -> bool:
        def __hash__(self) -> int:
    class RequiresPythonRequirement(Requirement):
        def __init__(self, specifier: SpecifierSet, match: Candidate) -> None:
        def __str__(self) -> str:
        def __repr__(self) -> str:
        def __hash__(self) -> int:
        def __eq__(self, other: Any) -> bool:
        @property
        def project_name(self) -> NormalizedName:
        @property
        def name(self) -> str:
        def format_for_error(self) -> str:
        def get_candidate_lookup(self) -> CandidateLookup:
        def is_satisfied_by(self, candidate: Candidate) -> bool:
    class UnsatisfiableRequirement(Requirement):
        def __init__(self, name: NormalizedName) -> None:
        def __str__(self) -> str:
        def __repr__(self) -> str:
        def __eq__(self, other: object) -> bool:
        def __hash__(self) -> int:
        @property
        def project_name(self) -> NormalizedName:
        @property
        def name(self) -> str:
        def format_for_error(self) -> str:
        def get_candidate_lookup(self) -> CandidateLookup:
        def is_satisfied_by(self, candidate: Candidate) -> bool:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: resolver.py
    import contextlib
    import functools
    import logging
    import os
    from typing import TYPE_CHECKING, Dict, List, Optional, Set, Tuple, cast
    from pip._vendor.packaging.utils import canonicalize_name
    from pip._vendor.resolvelib import BaseReporter, ResolutionImpossible
    from pip._vendor.resolvelib import Resolver as RLResolver
    from pip._vendor.resolvelib.structs import DirectedGraph
    from pip._internal.cache import WheelCache
    from pip._internal.index.package_finder import PackageFinder
    from pip._internal.operations.prepare import RequirementPreparer
    from pip._internal.req.constructors import install_req_extend_extras
    from pip._internal.req.req_install import InstallRequirement
    from pip._internal.req.req_set import RequirementSet
    from pip._internal.resolution.base import BaseResolver, InstallRequirementProvider
    from pip._internal.resolution.resolvelib.provider import PipProvider
    from pip._internal.resolution.resolvelib.reporter import (
    from pip._internal.utils.packaging import get_requirement
    from .base import Candidate, Requirement
    from .factory import Factory
        from pip._vendor.resolvelib.resolvers import Result as RLResult
    class Resolver(BaseResolver):
        def __init__(
        def resolve(
        def get_installation_order(
    def get_topological_weights(
        def visit(node: Optional[str]) -> None:
    def _req_set_item_sorter(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\utils

  ðŸ“„ Ð¤Ð°Ð¹Ð»: appdirs.py
    import os
    import sys
    from typing import List
    from pip._vendor import platformdirs as _appdirs
    def user_cache_dir(appname: str) -> str:
    def _macos_user_config_dir(appname: str, roaming: bool = True) -> str:
    def user_config_dir(appname: str, roaming: bool = True) -> str:
    def site_config_dirs(appname: str) -> List[str]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: compat.py
    import importlib.resources
    import logging
    import os
    import sys
    from typing import IO
    def has_tls() -> bool:
            import _ssl  # noqa: F401  # ignore unused
        from pip._vendor.urllib3.util import IS_PYOPENSSL
    def get_path_uid(path: str) -> int:
        def open_text_resource(
    WINDOWS = sys.platform.startswith("win") or (sys.platform == "cli" and os.name == "nt")

  ðŸ“„ Ð¤Ð°Ð¹Ð»: compatibility_tags.py
    import re
    from typing import List, Optional, Tuple
    from pip._vendor.packaging.tags import (
    def version_info_to_nodot(version_info: Tuple[int, ...]) -> str:
    def _mac_platforms(arch: str) -> List[str]:
    def _ios_platforms(arch: str) -> List[str]:
    def _custom_manylinux_platforms(arch: str) -> List[str]:
    def _get_custom_platforms(arch: str) -> List[str]:
    def _expand_allowed_platforms(platforms: Optional[List[str]]) -> Optional[List[str]]:
    def _get_python_version(version: str) -> PythonVersion:
    def _get_custom_interpreter(
    def get_supported(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: datetime.py
    import datetime
    def today_is_later_than(year: int, month: int, day: int) -> bool:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: deprecation.py
    import logging
    import warnings
    from typing import Any, Optional, TextIO, Type, Union
    from pip._vendor.packaging.version import parse
    from pip import __version__ as current_version  # NOTE: tests patch this name.
    DEPRECATION_MSG_PREFIX = "DEPRECATION: "
    class PipDeprecationWarning(Warning):
    def _showwarning(
    def install_warning_logger() -> None:
    def deprecated(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: direct_url_helpers.py
    from typing import Optional
    from pip._internal.models.direct_url import ArchiveInfo, DirectUrl, DirInfo, VcsInfo
    from pip._internal.models.link import Link
    from pip._internal.utils.urls import path_to_url
    from pip._internal.vcs import vcs
    def direct_url_as_pep440_direct_reference(direct_url: DirectUrl, name: str) -> str:
    def direct_url_for_editable(source_dir: str) -> DirectUrl:
    def direct_url_from_link(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: egg_link.py
    import os
    import re
    import sys
    from typing import List, Optional
    from pip._internal.locations import site_packages, user_site
    from pip._internal.utils.virtualenv import (
    def _egg_link_names(raw_name: str) -> List[str]:
    def egg_link_path_from_sys_path(raw_name: str) -> Optional[str]:
    def egg_link_path_from_location(raw_name: str) -> Optional[str]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: entrypoints.py
    import itertools
    import os
    import shutil
    import sys
    from typing import List, Optional
    from pip._internal.cli.main import main
    from pip._internal.utils.compat import WINDOWS
    _EXECUTABLE_NAMES = [
        _EXECUTABLE_NAMES = [
    def _wrapper(args: Optional[List[str]] = None) -> int:
    def get_best_invocation_for_this_pip() -> str:
    def get_best_invocation_for_this_python() -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: filesystem.py
    import fnmatch
    import os
    import os.path
    import random
    import sys
    from contextlib import contextmanager
    from tempfile import NamedTemporaryFile
    from typing import Any, BinaryIO, Generator, List, Union, cast
    from pip._internal.utils.compat import get_path_uid
    from pip._internal.utils.misc import format_size
    from pip._internal.utils.retry import retry
    def check_path_owner(path: str) -> bool:
    @contextmanager
    def adjacent_tmp_file(path: str, **kwargs: Any) -> Generator[BinaryIO, None, None]:
    def test_writable_dir(path: str) -> bool:
    def _test_writable_dir_win(path: str) -> bool:
    def find_files(path: str, pattern: str) -> List[str]:
    def file_size(path: str) -> Union[int, float]:
    def format_file_size(path: str) -> str:
    def directory_size(path: str) -> Union[int, float]:
    def format_directory_size(path: str) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: filetypes.py
    from typing import Tuple
    from pip._internal.utils.misc import splitext
    WHEEL_EXTENSION = ".whl"
    ARCHIVE_EXTENSIONS = ZIP_EXTENSIONS + BZ2_EXTENSIONS + TAR_EXTENSIONS + XZ_EXTENSIONS
    def is_archive_file(name: str) -> bool:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: glibc.py
    import os
    import sys
    from typing import Optional, Tuple
    def glibc_version_string() -> Optional[str]:
    def glibc_version_string_confstr() -> Optional[str]:
    def glibc_version_string_ctypes() -> Optional[str]:
            import ctypes
    def libc_ver() -> Tuple[str, str]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: hashes.py
    import hashlib
    from typing import TYPE_CHECKING, BinaryIO, Dict, Iterable, List, NoReturn, Optional
    from pip._internal.exceptions import HashMismatch, HashMissing, InstallationError
    from pip._internal.utils.misc import read_chunks
        from hashlib import _Hash
    FAVORITE_HASH = "sha256"
    STRONG_HASHES = ["sha256", "sha384", "sha512"]
    class Hashes:
        def __init__(self, hashes: Optional[Dict[str, List[str]]] = None) -> None:
        def __and__(self, other: "Hashes") -> "Hashes":
        @property
        def digest_count(self) -> int:
        def is_hash_allowed(self, hash_name: str, hex_digest: str) -> bool:
        def check_against_chunks(self, chunks: Iterable[bytes]) -> None:
        def _raise(self, gots: Dict[str, "_Hash"]) -> "NoReturn":
        def check_against_file(self, file: BinaryIO) -> None:
        def check_against_path(self, path: str) -> None:
        def has_one_of(self, hashes: Dict[str, str]) -> bool:
        def __bool__(self) -> bool:
        def __eq__(self, other: object) -> bool:
        def __hash__(self) -> int:
    class MissingHashes(Hashes):
        def __init__(self) -> None:
        def _raise(self, gots: Dict[str, "_Hash"]) -> "NoReturn":

  ðŸ“„ Ð¤Ð°Ð¹Ð»: logging.py
    import contextlib
    import errno
    import logging
    import logging.handlers
    import os
    import sys
    import threading
    from dataclasses import dataclass
    from io import TextIOWrapper
    from logging import Filter
    from typing import Any, ClassVar, Generator, List, Optional, TextIO, Type
    from pip._vendor.rich.console import (
    from pip._vendor.rich.highlighter import NullHighlighter
    from pip._vendor.rich.logging import RichHandler
    from pip._vendor.rich.segment import Segment
    from pip._vendor.rich.style import Style
    from pip._internal.utils._log import VERBOSE, getLogger
    from pip._internal.utils.compat import WINDOWS
    from pip._internal.utils.deprecation import DEPRECATION_MSG_PREFIX
    from pip._internal.utils.misc import ensure_dir
    class BrokenStdoutLoggingError(Exception):
    def _is_broken_pipe_error(exc_class: Type[BaseException], exc: BaseException) -> bool:
    @contextlib.contextmanager
    def indent_log(num: int = 2) -> Generator[None, None, None]:
    def get_indentation() -> int:
    class IndentingFormatter(logging.Formatter):
        def __init__(
        def get_message_start(self, formatted: str, levelno: int) -> str:
        def format(self, record: logging.LogRecord) -> str:
    @dataclass
    class IndentedRenderable:
        def __rich_console__(
    class PipConsole(Console):
        def on_broken_pipe(self) -> None:
    class RichPipStreamHandler(RichHandler):
        def __init__(self, stream: Optional[TextIO], no_color: bool) -> None:
        def emit(self, record: logging.LogRecord) -> None:
        def handleError(self, record: logging.LogRecord) -> None:
    class BetterRotatingFileHandler(logging.handlers.RotatingFileHandler):
        def _open(self) -> TextIOWrapper:
    class MaxLevelFilter(Filter):
        def __init__(self, level: int) -> None:
        def filter(self, record: logging.LogRecord) -> bool:
    class ExcludeLoggerFilter(Filter):
        def filter(self, record: logging.LogRecord) -> bool:
    def setup_logging(verbosity: int, no_color: bool, user_log_file: Optional[str]) -> int:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: misc.py
    import errno
    import getpass
    import hashlib
    import logging
    import os
    import posixpath
    import shutil
    import stat
    import sys
    import sysconfig
    import urllib.parse
    from dataclasses import dataclass
    from functools import partial
    from io import StringIO
    from itertools import filterfalse, tee, zip_longest
    from pathlib import Path
    from types import FunctionType, TracebackType
    from typing import (
    from pip._vendor.packaging.requirements import Requirement
    from pip._vendor.pyproject_hooks import BuildBackendHookCaller
    from pip import __version__
    from pip._internal.exceptions import CommandError, ExternallyManagedEnvironment
    from pip._internal.locations import get_major_minor_version
    from pip._internal.utils.compat import WINDOWS
    from pip._internal.utils.retry import retry
    from pip._internal.utils.virtualenv import running_under_virtualenv
    T = TypeVar("T")
    FILE_CHUNK_SIZE = 1024 * 1024
    def get_pip_version() -> str:
    def normalize_version_info(py_version_info: Tuple[int, ...]) -> Tuple[int, int, int]:
    def ensure_dir(path: str) -> None:
    def get_prog() -> str:
    @retry(stop_after_delay=3, wait=0.5)
    def rmtree(
    def _onerror_ignore(*_args: Any) -> None:
    def _onerror_reraise(*_args: Any) -> None:
    def rmtree_errorhandler(
    def display_path(path: str) -> str:
    def backup_dir(dir: str, ext: str = ".bak") -> str:
    def ask_path_exists(message: str, options: Iterable[str]) -> str:
    def _check_no_input(message: str) -> None:
    def ask(message: str, options: Iterable[str]) -> str:
    def ask_input(message: str) -> str:
    def ask_password(message: str) -> str:
    def strtobool(val: str) -> int:
    def format_size(bytes: float) -> str:
    def tabulate(rows: Iterable[Iterable[Any]]) -> Tuple[List[str], List[int]]:
    def is_installable_dir(path: str) -> bool:
    def read_chunks(
    def normalize_path(path: str, resolve_symlinks: bool = True) -> str:
    def splitext(path: str) -> Tuple[str, str]:
    def renames(old: str, new: str) -> None:
    def is_local(path: str) -> bool:
    def write_output(msg: Any, *args: Any) -> None:
    class StreamWrapper(StringIO):
        @classmethod
        def from_stream(cls, orig_stream: TextIO) -> "StreamWrapper":
        @property
        def encoding(self) -> str:  # type: ignore
    def enum(*sequential: Any, **named: Any) -> Type[Any]:
    def build_netloc(host: str, port: Optional[int]) -> str:
    def build_url_from_netloc(netloc: str, scheme: str = "https") -> str:
    def parse_netloc(netloc: str) -> Tuple[Optional[str], Optional[int]]:
    def split_auth_from_netloc(netloc: str) -> NetlocTuple:
    def redact_netloc(netloc: str) -> str:
    def _transform_url(
    def _get_netloc(netloc: str) -> NetlocTuple:
    def _redact_netloc(netloc: str) -> Tuple[str]:
    def split_auth_netloc_from_url(
    def remove_auth_from_url(url: str) -> str:
    def redact_auth_from_url(url: str) -> str:
    def redact_auth_from_requirement(req: Requirement) -> str:
    @dataclass(frozen=True)
    class HiddenText:
        def __repr__(self) -> str:
        def __str__(self) -> str:
        def __eq__(self, other: Any) -> bool:
    def hide_value(value: str) -> HiddenText:
    def hide_url(url: str) -> HiddenText:
    def protect_pip_from_modification_on_windows(modifying_pip: bool) -> None:
    def check_externally_managed() -> None:
    def is_console_interactive() -> bool:
    def hash_file(path: str, blocksize: int = 1 << 20) -> Tuple[Any, int]:
    def pairwise(iterable: Iterable[Any]) -> Iterator[Tuple[Any, Any]]:
    def partition(
    class ConfiguredBuildBackendHookCaller(BuildBackendHookCaller):
        def __init__(
        def build_wheel(
        def build_sdist(
        def build_editable(
        def get_requires_for_build_wheel(
        def get_requires_for_build_sdist(
        def get_requires_for_build_editable(
        def prepare_metadata_for_build_wheel(
        def prepare_metadata_for_build_editable(
    def warn_if_run_as_root() -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: packaging.py
    import functools
    import logging
    import re
    from typing import NewType, Optional, Tuple, cast
    from pip._vendor.packaging import specifiers, version
    from pip._vendor.packaging.requirements import Requirement
    @functools.lru_cache(maxsize=32)
    def check_requires_python(
    @functools.lru_cache(maxsize=2048)
    def get_requirement(req_string: str) -> Requirement:
    def safe_extra(extra: str) -> NormalizedExtra:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: retry.py
    import functools
    from time import perf_counter, sleep
    from typing import Callable, TypeVar
    from pip._vendor.typing_extensions import ParamSpec
    T = TypeVar("T")
    P = ParamSpec("P")
    def retry(
        def wrapper(func: Callable[P, T]) -> Callable[P, T]:
            @functools.wraps(func)
            def retry_wrapped(*args: P.args, **kwargs: P.kwargs) -> T:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: setuptools_build.py
    import sys
    import textwrap
    from typing import List, Optional, Sequence
    _SETUPTOOLS_SHIM = textwrap.dedent(
        import os, sys, tokenize
            import setuptools
    def make_setuptools_shim_args(
    def make_setuptools_bdist_wheel_args(
    def make_setuptools_clean_args(
    def make_setuptools_develop_args(
    def make_setuptools_egg_info_args(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: subprocess.py
    import logging
    import os
    import shlex
    import subprocess
    from typing import Any, Callable, Iterable, List, Literal, Mapping, Optional, Union
    from pip._vendor.rich.markup import escape
    from pip._internal.cli.spinners import SpinnerInterface, open_spinner
    from pip._internal.exceptions import InstallationSubprocessError
    from pip._internal.utils.logging import VERBOSE, subprocess_logger
    from pip._internal.utils.misc import HiddenText
    def make_command(*args: Union[str, HiddenText, CommandArgs]) -> CommandArgs:
    def format_command_args(args: Union[List[str], CommandArgs]) -> str:
    def reveal_command_args(args: Union[List[str], CommandArgs]) -> List[str]:
    def call_subprocess(
    def runner_with_spinner_message(message: str) -> Callable[..., None]:
        def runner(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: temp_dir.py
    import errno
    import itertools
    import logging
    import os.path
    import tempfile
    import traceback
    from contextlib import ExitStack, contextmanager
    from pathlib import Path
    from typing import (
    from pip._internal.utils.misc import enum, rmtree
    _T = TypeVar("_T", bound="TempDirectory")
        BUILD_ENV="build-env",
        EPHEM_WHEEL_CACHE="ephem-wheel-cache",
        REQ_BUILD="req-build",
    @contextmanager
    def global_tempdir_manager() -> Generator[None, None, None]:
    class TempDirectoryTypeRegistry:
        def __init__(self) -> None:
        def set_delete(self, kind: str, value: bool) -> None:
        def get_delete(self, kind: str) -> bool:
    @contextmanager
    def tempdir_registry() -> Generator[TempDirectoryTypeRegistry, None, None]:
    class _Default:
    class TempDirectory:
        def __init__(
        @property
        def path(self) -> str:
        def __repr__(self) -> str:
        def __enter__(self: _T) -> _T:
        def __exit__(self, exc: Any, value: Any, tb: Any) -> None:
        def _create(self, kind: str) -> str:
        def cleanup(self) -> None:
            def onerror(
    class AdjacentTempDirectory(TempDirectory):
        LEADING_CHARS = "-~.=%0123456789"
        def __init__(self, original: str, delete: Optional[bool] = None) -> None:
        @classmethod
        def _generate_names(cls, name: str) -> Generator[str, None, None]:
        def _create(self, kind: str) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: unpacking.py
    import logging
    import os
    import shutil
    import stat
    import sys
    import tarfile
    import zipfile
    from typing import Iterable, List, Optional
    from zipfile import ZipInfo
    from pip._internal.exceptions import InstallationError
    from pip._internal.utils.filetypes import (
    from pip._internal.utils.misc import ensure_dir
    SUPPORTED_EXTENSIONS = ZIP_EXTENSIONS + TAR_EXTENSIONS
        import bz2  # noqa
        import lzma  # noqa
    def current_umask() -> int:
    def split_leading_dir(path: str) -> List[str]:
    def has_leading_dir(paths: Iterable[str]) -> bool:
    def is_within_directory(directory: str, target: str) -> bool:
    def _get_default_mode_plus_executable() -> int:
    def set_extracted_file_to_default_mode_plus_executable(path: str) -> None:
    def zip_item_is_executable(info: ZipInfo) -> bool:
    def unzip_file(filename: str, location: str, flatten: bool = True) -> None:
    def untar_file(filename: str, location: str) -> None:
                def pip_filter(member: tarfile.TarInfo, path: str) -> tarfile.TarInfo:
    def _untar_without_filter(
    def unpack_file(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: urls.py
    import os
    import string
    import urllib.parse
    import urllib.request
    from .compat import WINDOWS
    def path_to_url(path: str) -> str:
    def url_to_path(url: str) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: virtualenv.py
    import logging
    import os
    import re
    import site
    import sys
    from typing import List, Optional
    _INCLUDE_SYSTEM_SITE_PACKAGES_REGEX = re.compile(
    def _running_under_venv() -> bool:
    def _running_under_legacy_virtualenv() -> bool:
    def running_under_virtualenv() -> bool:
    def _get_pyvenv_cfg_lines() -> Optional[List[str]]:
    def _no_global_under_venv() -> bool:
    def _no_global_under_legacy_virtualenv() -> bool:
    def virtualenv_no_global() -> bool:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: wheel.py
    import logging
    from email.message import Message
    from email.parser import Parser
    from typing import Tuple
    from zipfile import BadZipFile, ZipFile
    from pip._vendor.packaging.utils import canonicalize_name
    from pip._internal.exceptions import UnsupportedWheel
    VERSION_COMPATIBLE = (1, 0)
    def parse_wheel(wheel_zip: ZipFile, name: str) -> Tuple[str, Message]:
    def wheel_dist_info_dir(source: ZipFile, name: str) -> str:
    def read_wheel_metadata_file(source: ZipFile, path: str) -> bytes:
    def wheel_metadata(source: ZipFile, dist_info_dir: str) -> Message:
    def wheel_version(wheel_data: Message) -> Tuple[int, ...]:
    def check_compatibility(version: Tuple[int, ...], name: str) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _jaraco_text.py
    import functools
    import itertools
    def _nonblank(str):
    @functools.singledispatch
    def yield_lines(iterable):
    @yield_lines.register(str)
    def _(text):
    def drop_comment(line):
    def join_continuation(lines):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _log.py
    import logging
    from typing import Any, cast
    VERBOSE = 15
    class VerboseLogger(logging.Logger):
        def verbose(self, msg: str, *args: Any, **kwargs: Any) -> None:
    def getLogger(name: str) -> VerboseLogger:
    def init_logging() -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_internal\vcs

  ðŸ“„ Ð¤Ð°Ð¹Ð»: bazaar.py
    import logging
    from typing import List, Optional, Tuple
    from pip._internal.utils.misc import HiddenText, display_path
    from pip._internal.utils.subprocess import make_command
    from pip._internal.utils.urls import path_to_url
    from pip._internal.vcs.versioncontrol import (
    class Bazaar(VersionControl):
        @staticmethod
        def get_base_rev_args(rev: str) -> List[str]:
        def fetch_new(
        def switch(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:
        def update(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:
        @classmethod
        def get_url_rev_and_auth(cls, url: str) -> Tuple[str, Optional[str], AuthInfo]:
        @classmethod
        def get_remote_url(cls, location: str) -> str:
        @classmethod
        def get_revision(cls, location: str) -> str:
        @classmethod
        def is_commit_id_equal(cls, dest: str, name: Optional[str]) -> bool:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: git.py
    import logging
    import os.path
    import pathlib
    import re
    import urllib.parse
    import urllib.request
    from dataclasses import replace
    from typing import List, Optional, Tuple
    from pip._internal.exceptions import BadCommand, InstallationError
    from pip._internal.utils.misc import HiddenText, display_path, hide_url
    from pip._internal.utils.subprocess import make_command
    from pip._internal.vcs.versioncontrol import (
    GIT_VERSION_REGEX = re.compile(
    HASH_REGEX = re.compile("^[a-fA-F0-9]{40}$")
    SCP_REGEX = re.compile(
    def looks_like_hash(sha: str) -> bool:
    class Git(VersionControl):
        @staticmethod
        def get_base_rev_args(rev: str) -> List[str]:
        def is_immutable_rev_checkout(self, url: str, dest: str) -> bool:
        def get_git_version(self) -> Tuple[int, ...]:
        @classmethod
        def get_current_branch(cls, location: str) -> Optional[str]:
        @classmethod
        def get_revision_sha(cls, dest: str, rev: str) -> Tuple[Optional[str], bool]:
        @classmethod
        def _should_fetch(cls, dest: str, rev: str) -> bool:
        @classmethod
        def resolve_revision(
        @classmethod
        def is_commit_id_equal(cls, dest: str, name: Optional[str]) -> bool:
        def fetch_new(
        def switch(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:
        def update(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:
        @classmethod
        def get_remote_url(cls, location: str) -> str:
        @staticmethod
        def _git_remote_to_pip_url(url: str) -> str:
        @classmethod
        def has_commit(cls, location: str, rev: str) -> bool:
        @classmethod
        def get_revision(cls, location: str, rev: Optional[str] = None) -> str:
        @classmethod
        def get_subdirectory(cls, location: str) -> Optional[str]:
        @classmethod
        def get_url_rev_and_auth(cls, url: str) -> Tuple[str, Optional[str], AuthInfo]:
        @classmethod
        def update_submodules(cls, location: str) -> None:
        @classmethod
        def get_repository_root(cls, location: str) -> Optional[str]:
        @staticmethod
        def should_add_vcs_url_prefix(repo_url: str) -> bool:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: mercurial.py
    import configparser
    import logging
    import os
    from typing import List, Optional, Tuple
    from pip._internal.exceptions import BadCommand, InstallationError
    from pip._internal.utils.misc import HiddenText, display_path
    from pip._internal.utils.subprocess import make_command
    from pip._internal.utils.urls import path_to_url
    from pip._internal.vcs.versioncontrol import (
    class Mercurial(VersionControl):
        @staticmethod
        def get_base_rev_args(rev: str) -> List[str]:
        def fetch_new(
        def switch(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:
        def update(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:
        @classmethod
        def get_remote_url(cls, location: str) -> str:
        @classmethod
        def get_revision(cls, location: str) -> str:
        @classmethod
        def get_requirement_revision(cls, location: str) -> str:
        @classmethod
        def is_commit_id_equal(cls, dest: str, name: Optional[str]) -> bool:
        @classmethod
        def get_subdirectory(cls, location: str) -> Optional[str]:
        @classmethod
        def get_repository_root(cls, location: str) -> Optional[str]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: subversion.py
    import logging
    import os
    import re
    from typing import List, Optional, Tuple
    from pip._internal.utils.misc import (
    from pip._internal.utils.subprocess import CommandArgs, make_command
    from pip._internal.vcs.versioncontrol import (
    class Subversion(VersionControl):
        @classmethod
        def should_add_vcs_url_prefix(cls, remote_url: str) -> bool:
        @staticmethod
        def get_base_rev_args(rev: str) -> List[str]:
        @classmethod
        def get_revision(cls, location: str) -> str:
        @classmethod
        def get_netloc_and_auth(
        @classmethod
        def get_url_rev_and_auth(cls, url: str) -> Tuple[str, Optional[str], AuthInfo]:
        @staticmethod
        def make_rev_args(
        @classmethod
        def get_remote_url(cls, location: str) -> str:
        @classmethod
        def _get_svn_url_rev(cls, location: str) -> Tuple[Optional[str], int]:
            from pip._internal.exceptions import InstallationError
        @classmethod
        def is_commit_id_equal(cls, dest: str, name: Optional[str]) -> bool:
        def __init__(self, use_interactive: Optional[bool] = None) -> None:
        def call_vcs_version(self) -> Tuple[int, ...]:
        def get_vcs_version(self) -> Tuple[int, ...]:
        def get_remote_call_options(self) -> CommandArgs:
        def fetch_new(
        def switch(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:
        def update(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: versioncontrol.py
    import logging
    import os
    import shutil
    import sys
    import urllib.parse
    from dataclasses import dataclass, field
    from typing import (
    from pip._internal.cli.spinners import SpinnerInterface
    from pip._internal.exceptions import BadCommand, InstallationError
    from pip._internal.utils.misc import (
    from pip._internal.utils.subprocess import (
    def is_url(name: str) -> bool:
    def make_vcs_requirement_url(
    def find_path_to_project_root_from_repo_root(
    class RemoteNotFoundError(Exception):
    class RemoteNotValidError(Exception):
        def __init__(self, url: str):
    @dataclass(frozen=True)
    class RevOptions:
        def __repr__(self) -> str:
        @property
        def arg_rev(self) -> Optional[str]:
        def to_args(self) -> CommandArgs:
        def to_display(self) -> str:
        def make_new(self, rev: str) -> "RevOptions":
    class VcsSupport:
        def __init__(self) -> None:
        def __iter__(self) -> Iterator[str]:
        @property
        def backends(self) -> List["VersionControl"]:
        @property
        def dirnames(self) -> List[str]:
        @property
        def all_schemes(self) -> List[str]:
        def register(self, cls: Type["VersionControl"]) -> None:
        def unregister(self, name: str) -> None:
        def get_backend_for_dir(self, location: str) -> Optional["VersionControl"]:
        def get_backend_for_scheme(self, scheme: str) -> Optional["VersionControl"]:
        def get_backend(self, name: str) -> Optional["VersionControl"]:
    class VersionControl:
        @classmethod
        def should_add_vcs_url_prefix(cls, remote_url: str) -> bool:
        @classmethod
        def get_subdirectory(cls, location: str) -> Optional[str]:
        @classmethod
        def get_requirement_revision(cls, repo_dir: str) -> str:
        @classmethod
        def get_src_requirement(cls, repo_dir: str, project_name: str) -> str:
        @staticmethod
        def get_base_rev_args(rev: str) -> List[str]:
        def is_immutable_rev_checkout(self, url: str, dest: str) -> bool:
        @classmethod
        def make_rev_options(
        @classmethod
        def _is_local_repository(cls, repo: str) -> bool:
        @classmethod
        def get_netloc_and_auth(
        @classmethod
        def get_url_rev_and_auth(cls, url: str) -> Tuple[str, Optional[str], AuthInfo]:
        @staticmethod
        def make_rev_args(
        def get_url_rev_options(self, url: HiddenText) -> Tuple[HiddenText, RevOptions]:
        @staticmethod
        def normalize_url(url: str) -> str:
        @classmethod
        def compare_urls(cls, url1: str, url2: str) -> bool:
        def fetch_new(
        def switch(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:
        def update(self, dest: str, url: HiddenText, rev_options: RevOptions) -> None:
        @classmethod
        def is_commit_id_equal(cls, dest: str, name: Optional[str]) -> bool:
        def obtain(self, dest: str, url: HiddenText, verbosity: int) -> None:
        def unpack(self, location: str, url: HiddenText, verbosity: int) -> None:
        @classmethod
        def get_remote_url(cls, location: str) -> str:
        @classmethod
        def get_revision(cls, location: str) -> str:
        @classmethod
        def run_command(
        @classmethod
        def is_repository_directory(cls, path: str) -> bool:
        @classmethod
        def get_repository_root(cls, location: str) -> Optional[str]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    import pip._internal.vcs.bazaar
    import pip._internal.vcs.git
    import pip._internal.vcs.mercurial
    import pip._internal.vcs.subversion  # noqa: F401
    from pip._internal.vcs.versioncontrol import (  # noqa: F401

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor

  ðŸ“„ Ð¤Ð°Ð¹Ð»: typing_extensions.py
    import abc
    import collections
    import collections.abc
    import contextlib
    import functools
    import inspect
    import operator
    import sys
    import types as _types
    import typing
    import warnings
    class _Sentinel:
        def __repr__(self):
        def _should_collect_from_parameters(t):
        def _should_collect_from_parameters(t):
        def _should_collect_from_parameters(t):
    T = typing.TypeVar('T')  # Any type.
    KT = typing.TypeVar('KT')  # Key type.
    VT = typing.TypeVar('VT')  # Value type.
        from typing import Any
        class _AnyMeta(type):
            def __instancecheck__(self, obj):
            def __repr__(self):
        class Any(metaclass=_AnyMeta):
            def __new__(cls, *args, **kwargs):
    class _ExtensionsSpecialForm(typing._SpecialForm, _root=True):
        def __repr__(self):
        def final(f):
                class Base:
                    @final
                    def done(self) -> None:
                class Sub(Base):
                    def done(self) -> None:  # Error reported by type checker
                @final
                class Leaf:
                class Other(Leaf):  # Error reported by type checker
    def IntVar(name):
        def _flatten_literal_params(parameters):
        def _value_and_type_iter(params):
        class _LiteralGenericAlias(typing._GenericAlias, _root=True):
            def __eq__(self, other):
            def __hash__(self):
        class _LiteralForm(_ExtensionsSpecialForm, _root=True):
            def __init__(self, doc: str):
            def __getitem__(self, parameters):
        def overload(func):
            @overload
            def utf8(value: None) -> None: ...
            @overload
            def utf8(value: bytes) -> bytes: ...
            @overload
            def utf8(value: str) -> bytes: ...
            @overload
            def utf8(value: None) -> None: ...
            @overload
            def utf8(value: bytes) -> bytes: ...
            @overload
            def utf8(value: str) -> bytes: ...
            def utf8(value):
        def get_overloads(func):
        def clear_overloads():
    TYPE_CHECKING = typing.TYPE_CHECKING
        from typing import AsyncContextManager, AsyncGenerator, ContextManager, Generator
        def _is_dunder(attr):
        class _SpecialGenericAlias(_special_generic_alias_base, _root=True):
            def __init__(self, origin, nparams, *, inst=True, name=None, defaults=()):
            def __setattr__(self, attr, val):
            @typing._tp_cache
            def __getitem__(self, params):
    _PROTO_ALLOWLIST = {
    _EXCLUDED_ATTRS = frozenset(typing.EXCLUDED_ATTRIBUTES) | {
    def _get_protocol_attrs(cls):
    def _caller(depth=2):
        def _allow_reckless_class_checks(depth=3):
        def _no_init(self, *args, **kwargs):
        def _type_check_issubclass_arg_1(arg):
        class _ProtocolMeta(type(typing.Protocol)):
            def __new__(mcls, name, bases, namespace, **kwargs):
            def __init__(cls, *args, **kwargs):
            def __subclasscheck__(cls, other):
            def __instancecheck__(cls, instance):
            def __eq__(cls, other):
            def __hash__(cls) -> int:
        @classmethod
        def _proto_hook(cls, other):
        class Protocol(typing.Generic, metaclass=_ProtocolMeta):
            def __init_subclass__(cls, *args, **kwargs):
        def runtime_checkable(cls):
                @runtime_checkable
                class Closable(Protocol):
                    def close(self): ...
        @runtime_checkable
        class SupportsInt(Protocol):
            @abc.abstractmethod
            def __int__(self) -> int:
        @runtime_checkable
        class SupportsFloat(Protocol):
            @abc.abstractmethod
            def __float__(self) -> float:
        @runtime_checkable
        class SupportsComplex(Protocol):
            @abc.abstractmethod
            def __complex__(self) -> complex:
        @runtime_checkable
        class SupportsBytes(Protocol):
            @abc.abstractmethod
            def __bytes__(self) -> bytes:
        @runtime_checkable
        class SupportsIndex(Protocol):
            @abc.abstractmethod
            def __index__(self) -> int:
        @runtime_checkable
        class SupportsAbs(Protocol[T_co]):
            @abc.abstractmethod
            def __abs__(self) -> T_co:
        @runtime_checkable
        class SupportsRound(Protocol[T_co]):
            @abc.abstractmethod
            def __round__(self, ndigits: int = 0) -> T_co:
    def _ensure_subclassable(mro_entries):
        def inner(func):
        _TAKES_MODULE = "module" in inspect.signature(typing._type_check).parameters
        def _get_typeddict_qualifiers(annotation_type):
        class _TypedDictMeta(type):
            def __new__(cls, name, bases, ns, *, total=True, closed=False):
            def __subclasscheck__(cls, other):
        @_ensure_subclassable(lambda bases: (_TypedDict,))
        def TypedDict(typename, fields=_marker, /, *, total=True, closed=False, **kwargs):
                class Point2D(TypedDict):
                class Point2D(TypedDict, total=False):
            class body be required.
                class Point2D(TypedDict):
            _TYPEDDICT_TYPES = (typing._TypedDictMeta, _TypedDictMeta)
            _TYPEDDICT_TYPES = (_TypedDictMeta,)
        def is_typeddict(tp):
                class Film(TypedDict):
        def assert_type(val, typ, /):
                def greet(name: str) -> None:
        def _strip_extras(t):
        def get_type_hints(obj, globalns=None, localns=None, include_extras=False):
        class _AnnotatedAlias(typing._GenericAlias, _root=True):
            def __init__(self, origin, metadata):
            def copy_with(self, params):
            def __repr__(self):
            def __reduce__(self):
            def __eq__(self, other):
            def __hash__(self):
        class Annotated:
            def __new__(cls, *args, **kwargs):
            @typing._tp_cache
            def __class_getitem__(cls, params):
            def __init_subclass__(cls, *args, **kwargs):
            from typing import _BaseGenericAlias
            from typing import GenericAlias as _typing_GenericAlias
        def get_origin(tp):
        def get_args(tp):
        @_ExtensionsSpecialForm
        def TypeAlias(self, parameters):
        class NoDefaultTypeMeta(type):
            def __setattr__(cls, attr, value):
        class NoDefaultType(metaclass=NoDefaultTypeMeta):
            def __new__(cls):
            def __repr__(self):
            def __reduce__(self):
    def _set_default(type_param, default):
    def _set_module(typevarlike):
    class _DefaultMixin:
    class _TypeVarLikeMeta(type):
        def __instancecheck__(cls, __instance: Any) -> bool:
        from typing import TypeVar
        class TypeVar(metaclass=_TypeVarLikeMeta):
            def __new__(cls, name, *constraints, bound=None,
                def _tvar_prepare_subst(alias, args):
            def __init_subclass__(cls) -> None:
        class _Immutable:
            def __copy__(self):
            def __deepcopy__(self, memo):
        class ParamSpecArgs(_Immutable):
            def __init__(self, origin):
            def __repr__(self):
            def __eq__(self, other):
        class ParamSpecKwargs(_Immutable):
            def __init__(self, origin):
            def __repr__(self):
            def __eq__(self, other):
        from typing import ParamSpec
        class ParamSpec(metaclass=_TypeVarLikeMeta):
            def __new__(cls, name, *, bound=None,
                def _paramspec_prepare_subst(alias, args):
            def __init_subclass__(cls) -> None:
        class ParamSpec(list, _DefaultMixin):
               P = ParamSpec('P')
               T = TypeVar('T')
               P = ParamSpec('P')
               def add_logging(f: Callable[P, T]) -> Callable[P, T]:
                   def inner(*args: P.args, **kwargs: P.kwargs) -> T:
               @add_logging
               def add_two(x: float, y: float) -> float:
            @property
            def args(self):
            @property
            def kwargs(self):
            def __init__(self, name, *, bound=None, covariant=False, contravariant=False,
            def __repr__(self):
            def __hash__(self):
            def __eq__(self, other):
            def __reduce__(self):
            def __call__(self, *args, **kwargs):
        class _ConcatenateGenericAlias(list):
            def __init__(self, origin, args):
            def __repr__(self):
            def __hash__(self):
            def __call__(self, *args, **kwargs):
            @property
            def __parameters__(self):
    @typing._tp_cache
    def _concatenate_getitem(self, parameters):
        @_ExtensionsSpecialForm
        def Concatenate(self, parameters):
        class _ConcatenateForm(_ExtensionsSpecialForm, _root=True):
            def __getitem__(self, parameters):
        @_ExtensionsSpecialForm
        def TypeGuard(self, parameters):
                def is_str(val: Union[str, float]):
        class _TypeGuardForm(_ExtensionsSpecialForm, _root=True):
            def __getitem__(self, parameters):
                def is_str(val: Union[str, float]):
        @_ExtensionsSpecialForm
        def TypeIs(self, parameters):
                def is_awaitable(val: object) -> TypeIs[Awaitable[Any]]:
                def f(val: Union[int, Awaitable[int]]) -> int:
        class _TypeIsForm(_ExtensionsSpecialForm, _root=True):
            def __getitem__(self, parameters):
                def is_awaitable(val: object) -> TypeIs[Awaitable[Any]]:
                def f(val: Union[int, Awaitable[int]]) -> int:
    class _SpecialForm(typing._Final, _root=True):
        def __init__(self, getitem):
        def __getattr__(self, item):
        def __mro_entries__(self, bases):
        def __repr__(self):
        def __reduce__(self):
        def __call__(self, *args, **kwds):
        def __or__(self, other):
        def __ror__(self, other):
        def __instancecheck__(self, obj):
        def __subclasscheck__(self, cls):
        @typing._tp_cache
        def __getitem__(self, parameters):
        @_SpecialForm
        def LiteralString(self, params):
              from pip._vendor.typing_extensions import LiteralString
              def query(sql: LiteralString) -> ...:
        @_SpecialForm
        def Self(self, params):
              from typing import Self
              class ReturnsSelf:
                  def parse(self, data: bytes) -> Self:
        @_SpecialForm
        def Never(self, params):
                from pip._vendor.typing_extensions import Never
                def never_call_me(arg: Never) -> None:
                def int_or_str(arg: int | str) -> None:
        @_ExtensionsSpecialForm
        def Required(self, parameters):
                class Movie(TypedDict, total=False):
        @_ExtensionsSpecialForm
        def NotRequired(self, parameters):
                class Movie(TypedDict):
        class _RequiredForm(_ExtensionsSpecialForm, _root=True):
            def __getitem__(self, parameters):
                class Movie(TypedDict, total=False):
                class Movie(TypedDict):
        @_ExtensionsSpecialForm
        def ReadOnly(self, parameters):
                class Movie(TypedDict):
                def mutate_movie(m: Movie) -> None:
        class _ReadOnlyForm(_ExtensionsSpecialForm, _root=True):
            def __getitem__(self, parameters):
                class Movie(TypedDict):
                def mutate_movie(m: Movie) -> None:
    _UNPACK_DOC = """\
      class Bar(Generic[Unpack[Ts]]): ...
        class Bar(Generic[*Ts]): ...
      class Movie(TypedDict):
      def foo(**kwargs: Unpack[Movie]): ...
        def _is_unpack(obj):
        class _UnpackSpecialForm(_ExtensionsSpecialForm, _root=True):
            def __init__(self, getitem):
        class _UnpackAlias(typing._GenericAlias, _root=True):
            @property
            def __typing_unpacked_tuple_args__(self):
        @_UnpackSpecialForm
        def Unpack(self, parameters):
        def _is_unpack(obj):
        class _UnpackAlias(typing._GenericAlias, _root=True):
        class _UnpackForm(_ExtensionsSpecialForm, _root=True):
            def __getitem__(self, parameters):
        def _is_unpack(obj):
        from typing import TypeVarTuple
        def _unpack_args(*args):
        class TypeVarTuple(metaclass=_TypeVarLikeMeta):
            def __new__(cls, name, *, default=NoDefault):
                def _typevartuple_prepare_subst(alias, args):
            def __init_subclass__(self, *args, **kwds):
        class TypeVarTuple(_DefaultMixin):
                class Array(Generic[*Ts]): ...
                class Array(Generic[*Ts]):
                    def __init__(self, shape: Tuple[*Ts]):
                    def get_shape(self) -> Tuple[*Ts]:
            def __iter__(self):
            def __init__(self, name, *, default=NoDefault):
            def __repr__(self):
            def __hash__(self):
            def __eq__(self, other):
            def __reduce__(self):
            def __init_subclass__(self, *args, **kwds):
        def reveal_type(obj: T, /) -> T:
        _ASSERT_NEVER_REPR_MAX_LENGTH = typing._ASSERT_NEVER_REPR_MAX_LENGTH
        _ASSERT_NEVER_REPR_MAX_LENGTH = 100
        def assert_never(arg: Never, /) -> Never:
                def int_or_str(arg: int | str) -> None:
        def dataclass_transform(
                from pip._vendor.typing_extensions import dataclass_transform
                _T = TypeVar("_T")
                @dataclass_transform()
                def create_model(cls: type[_T]) -> type[_T]:
                @create_model
                class CustomerModel:
                @dataclass_transform()
                class ModelBase: ...
                class CustomerModel(ModelBase):
                @dataclass_transform()
                class ModelMeta(type): ...
                class ModelBase(metaclass=ModelMeta): ...
                class CustomerModel(ModelBase):
            def decorator(cls_or_fn):
        _F = typing.TypeVar("_F", bound=typing.Callable[..., typing.Any])
        def override(arg: _F, /) -> _F:
                class Base:
                    def method(self) -> None:
                class Child(Base):
                    @override
                    def method(self) -> None:
        _T = typing.TypeVar("_T")
        class deprecated:
                @deprecated("Use B instead")
                class A:
                @deprecated("Use g instead")
                def f():
                @overload
                @deprecated("int support is deprecated")
                def g(x: int) -> int: ...
                @overload
                def g(x: str) -> int: ...
            def __init__(
            def __call__(self, arg: _T, /) -> _T:
                    import functools
                    from types import MethodType
                    @functools.wraps(original_new)
                    def __new__(cls, *args, **kwargs):
                        @functools.wraps(original_init_subclass)
                        def __init_subclass__(*args, **kwargs):
                        @functools.wraps(original_init_subclass)
                        def __init_subclass__(*args, **kwargs):
                    import functools
                    @functools.wraps(arg)
                    def wrapper(*args, **kwargs):
        def _check_generic(cls, parameters, elen=_marker):
        def _check_generic(cls, parameters, elen):
    def _has_generic_or_protocol_as_origin() -> bool:
    _TYPEVARTUPLE_TYPES = {TypeVarTuple, getattr(typing, "TypeVarTuple", None)}
    def _is_unpacked_typevartuple(x) -> bool:
        def _collect_type_vars(types, typevar_types=None):
        def _collect_parameters(args):
        def _make_nmtuple(name, types, module, defaults=()):
        class _NamedTupleMeta(type):
            def __new__(cls, typename, bases, ns):
        def _namedtuple_mro_entries(bases):
        @_ensure_subclassable(_namedtuple_mro_entries)
        def NamedTuple(typename, fields=_marker, /, **kwargs):
                class Employee(NamedTuple):
        class Buffer(abc.ABC):  # noqa: B024
        def get_original_bases(cls, /):
                from typing import TypeVar, Generic
                from pip._vendor.typing_extensions import NamedTuple, TypedDict
                T = TypeVar("T")
                class Foo(Generic[T]): ...
                class Bar(Foo[int], float): ...
                class Baz(list[str]): ...
        class NewType:
                def name_by_id(user_id: UserId) -> str:
            def __call__(self, obj, /):
            def __init__(self, name, tp):
            def __mro_entries__(self, bases):
                class Dummy:
                    def __init_subclass__(cls):
            def __repr__(self):
            def __reduce__(self):
                def __or__(self, other):
                def __ror__(self, other):
        def _is_unionable(obj):
        class TypeAliasType:
                T = TypeVar("T")
            def __init__(self, name: str, value, *, type_params=()):
            def __setattr__(self, name: str, value: object, /) -> None:
            def __delattr__(self, name: str, /) -> Never:
            def _raise_attribute_error(self, name: str) -> Never:
            def __repr__(self) -> str:
            def __getitem__(self, parameters):
            def __reduce__(self):
            def __init_subclass__(cls, *args, **kwargs):
            def __call__(self):
                def __or__(self, right):
                def __ror__(self, left):
        def is_protocol(tp: type, /) -> bool:
        def get_protocol_members(tp: type, /) -> typing.FrozenSet[str]:
        class Doc:
            def __init__(self, documentation: str, /) -> None:
            def __repr__(self) -> str:
            def __hash__(self) -> int:
            def __eq__(self, other: object) -> bool:
            import _socket
            _CAPI = getattr(_socket, "CAPI", None)
    IO = typing.IO

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from __future__ import absolute_import
    import glob
    import os.path
    import sys
    DEBUNDLED = False
    WHEEL_DIR = os.path.abspath(os.path.dirname(__file__))
    def vendored(modulename):

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\cachecontrol

  ðŸ“„ Ð¤Ð°Ð¹Ð»: adapter.py
    from __future__ import annotations
    import functools
    import types
    import zlib
    from typing import TYPE_CHECKING, Any, Collection, Mapping
    from pip._vendor.requests.adapters import HTTPAdapter
    from pip._vendor.cachecontrol.cache import DictCache
    from pip._vendor.cachecontrol.controller import PERMANENT_REDIRECT_STATUSES, CacheController
    from pip._vendor.cachecontrol.filewrapper import CallbackFileWrapper
        from pip._vendor.requests import PreparedRequest, Response
        from pip._vendor.urllib3 import HTTPResponse
        from pip._vendor.cachecontrol.cache import BaseCache
        from pip._vendor.cachecontrol.heuristics import BaseHeuristic
        from pip._vendor.cachecontrol.serialize import Serializer
    class CacheControlAdapter(HTTPAdapter):
        def __init__(
        def send(
        def build_response(  # type: ignore[override]
                        def _update_chunk_length(self: HTTPResponse) -> None:
        def close(self) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: cache.py
    from __future__ import annotations
    from threading import Lock
    from typing import IO, TYPE_CHECKING, MutableMapping
        from datetime import datetime
    class BaseCache:
        def get(self, key: str) -> bytes | None:
        def set(
        def delete(self, key: str) -> None:
        def close(self) -> None:
    class DictCache(BaseCache):
        def __init__(self, init_dict: MutableMapping[str, bytes] | None = None) -> None:
        def get(self, key: str) -> bytes | None:
        def set(
        def delete(self, key: str) -> None:
    class SeparateBodyBaseCache(BaseCache):
        def set_body(self, key: str, body: bytes) -> None:
        def get_body(self, key: str) -> IO[bytes] | None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: controller.py
    from __future__ import annotations
    import calendar
    import logging
    import re
    import time
    from email.utils import parsedate_tz
    from typing import TYPE_CHECKING, Collection, Mapping
    from pip._vendor.requests.structures import CaseInsensitiveDict
    from pip._vendor.cachecontrol.cache import DictCache, SeparateBodyBaseCache
    from pip._vendor.cachecontrol.serialize import Serializer
        from typing import Literal
        from pip._vendor.requests import PreparedRequest
        from pip._vendor.urllib3 import HTTPResponse
        from pip._vendor.cachecontrol.cache import BaseCache
    URI = re.compile(r"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?")
    PERMANENT_REDIRECT_STATUSES = (301, 308)
    def parse_uri(uri: str) -> tuple[str, str, str, str, str]:
    class CacheController:
        def __init__(
        @classmethod
        def _urlnorm(cls, uri: str) -> str:
        @classmethod
        def cache_url(cls, uri: str) -> str:
        def parse_cache_control(self, headers: Mapping[str, str]) -> dict[str, int | None]:
        def _load_from_cache(self, request: PreparedRequest) -> HTTPResponse | None:
        def cached_request(self, request: PreparedRequest) -> HTTPResponse | Literal[False]:
        def conditional_headers(self, request: PreparedRequest) -> dict[str, str]:
        def _cache_set(
        def cache_response(
        def update_cached_response(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: filewrapper.py
    from __future__ import annotations
    import mmap
    from tempfile import NamedTemporaryFile
    from typing import TYPE_CHECKING, Any, Callable
        from http.client import HTTPResponse
    class CallbackFileWrapper:
        def __init__(
        def __getattr__(self, name: str) -> Any:
        def __is_fp_closed(self) -> bool:
        def _close(self) -> None:
        def read(self, amt: int | None = None) -> bytes:
        def _safe_read(self, amt: int) -> bytes:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: heuristics.py
    from __future__ import annotations
    import calendar
    import time
    from datetime import datetime, timedelta, timezone
    from email.utils import formatdate, parsedate, parsedate_tz
    from typing import TYPE_CHECKING, Any, Mapping
        from pip._vendor.urllib3 import HTTPResponse
    TIME_FMT = "%a, %d %b %Y %H:%M:%S GMT"
    def expire_after(delta: timedelta, date: datetime | None = None) -> datetime:
    def datetime_to_header(dt: datetime) -> str:
    class BaseHeuristic:
        def warning(self, response: HTTPResponse) -> str | None:
        def update_headers(self, response: HTTPResponse) -> dict[str, str]:
        def apply(self, response: HTTPResponse) -> HTTPResponse:
    class OneDayCache(BaseHeuristic):
        def update_headers(self, response: HTTPResponse) -> dict[str, str]:
    class ExpiresAfter(BaseHeuristic):
        def __init__(self, **kw: Any) -> None:
        def update_headers(self, response: HTTPResponse) -> dict[str, str]:
        def warning(self, response: HTTPResponse) -> str | None:
    class LastModified(BaseHeuristic):
        def update_headers(self, resp: HTTPResponse) -> dict[str, str]:
        def warning(self, resp: HTTPResponse) -> str | None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: serialize.py
    from __future__ import annotations
    import io
    from typing import IO, TYPE_CHECKING, Any, Mapping, cast
    from pip._vendor import msgpack
    from pip._vendor.requests.structures import CaseInsensitiveDict
    from pip._vendor.urllib3 import HTTPResponse
        from pip._vendor.requests import PreparedRequest
    class Serializer:
        def dumps(
        def serialize(self, data: dict[str, Any]) -> bytes:
        def loads(
        def prepare_response(
        def _loads_v4(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: wrapper.py
    from __future__ import annotations
    from typing import TYPE_CHECKING, Collection
    from pip._vendor.cachecontrol.adapter import CacheControlAdapter
    from pip._vendor.cachecontrol.cache import DictCache
        from pip._vendor import requests
        from pip._vendor.cachecontrol.cache import BaseCache
        from pip._vendor.cachecontrol.controller import CacheController
        from pip._vendor.cachecontrol.heuristics import BaseHeuristic
        from pip._vendor.cachecontrol.serialize import Serializer
    def CacheControl(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _cmd.py
    from __future__ import annotations
    import logging
    from argparse import ArgumentParser
    from typing import TYPE_CHECKING
    from pip._vendor import requests
    from pip._vendor.cachecontrol.adapter import CacheControlAdapter
    from pip._vendor.cachecontrol.cache import DictCache
    from pip._vendor.cachecontrol.controller import logger
        from argparse import Namespace
        from pip._vendor.cachecontrol.controller import CacheController
    def setup_logging() -> None:
    def get_session() -> requests.Session:
    def get_args() -> Namespace:
    def main() -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from pip._vendor.cachecontrol.adapter import CacheControlAdapter
    from pip._vendor.cachecontrol.controller import CacheController
    from pip._vendor.cachecontrol.wrapper import CacheControl
    import logging

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\cachecontrol\caches

  ðŸ“„ Ð¤Ð°Ð¹Ð»: file_cache.py
    from __future__ import annotations
    import hashlib
    import os
    from textwrap import dedent
    from typing import IO, TYPE_CHECKING
    from pathlib import Path
    from pip._vendor.cachecontrol.cache import BaseCache, SeparateBodyBaseCache
    from pip._vendor.cachecontrol.controller import CacheController
        from datetime import datetime
        from filelock import BaseFileLock
    def _secure_open_write(filename: str, fmode: int) -> IO[bytes]:
    class _FileCacheMixin:
        def __init__(
                    from filelock import FileLock
        @staticmethod
        def encode(x: str) -> str:
        def _fn(self, name: str) -> str:
        def get(self, key: str) -> bytes | None:
        def set(
        def _write(self, path: str, data: bytes) -> None:
        def _delete(self, key: str, suffix: str) -> None:
    class FileCache(_FileCacheMixin, BaseCache):
        def delete(self, key: str) -> None:
    class SeparateBodyFileCache(_FileCacheMixin, SeparateBodyBaseCache):
        def get_body(self, key: str) -> IO[bytes] | None:
        def set_body(self, key: str, body: bytes) -> None:
        def delete(self, key: str) -> None:
    def url_to_file_path(url: str, filecache: FileCache) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: redis_cache.py
    from __future__ import annotations
    from datetime import datetime, timezone
    from typing import TYPE_CHECKING
    from pip._vendor.cachecontrol.cache import BaseCache
        from redis import Redis
    class RedisCache(BaseCache):
        def __init__(self, conn: Redis[bytes]) -> None:
        def get(self, key: str) -> bytes | None:
        def set(
        def delete(self, key: str) -> None:
        def clear(self) -> None:
        def close(self) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from pip._vendor.cachecontrol.caches.file_cache import FileCache, SeparateBodyFileCache
    from pip._vendor.cachecontrol.caches.redis_cache import RedisCache

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\certifi

  ðŸ“„ Ð¤Ð°Ð¹Ð»: core.py
    import sys
    import atexit
    def exit_cacert_ctx() -> None:
        from importlib.resources import as_file, files
        _CACERT_CTX = None
        _CACERT_PATH = None
        def where() -> str:
                _CACERT_CTX = as_file(files("pip._vendor.certifi").joinpath("cacert.pem"))
                _CACERT_PATH = str(_CACERT_CTX.__enter__())
        def contents() -> str:
        from importlib.resources import path as get_path, read_text
        _CACERT_CTX = None
        _CACERT_PATH = None
        def where() -> str:
                _CACERT_CTX = get_path("pip._vendor.certifi", "cacert.pem")
                _CACERT_PATH = str(_CACERT_CTX.__enter__())
        def contents() -> str:
        import os
        import types
        from typing import Union
        def read_text(
        def where() -> str:
        def contents() -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from .core import contents, where

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __main__.py
    import argparse
    from pip._vendor.certifi import contents, where

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\distlib

  ðŸ“„ Ð¤Ð°Ð¹Ð»: compat.py
    from __future__ import absolute_import
    import os
    import re
    import shutil
    import sys
        import ssl
        from StringIO import StringIO
        from types import FileType as file_type
        import __builtin__ as builtins
        import ConfigParser as configparser
        from urlparse import urlparse, urlunparse, urljoin, urlsplit, urlunsplit
        from urllib import (urlretrieve, quote as _quote, unquote, url2pathname,
        def quote(s):
        import urllib2
        from urllib2 import (Request, urlopen, URLError, HTTPError,
            from urllib2 import HTTPSHandler
        import httplib
        import xmlrpclib
        import Queue as queue
        from HTMLParser import HTMLParser
        import htmlentitydefs
        from itertools import ifilter as filter
        from itertools import ifilterfalse as filterfalse
        from io import StringIO
        from io import TextIOWrapper as file_type
        import builtins
        import configparser
        from urllib.parse import (urlparse, urlunparse, urljoin, quote, unquote,
        from urllib.request import (urlopen, urlretrieve, Request, url2pathname,
            from urllib.request import HTTPSHandler
        from urllib.error import HTTPError, URLError, ContentTooShortError
        import http.client as httplib
        import urllib.request as urllib2
        import xmlrpc.client as xmlrpclib
        import queue
        from html.parser import HTMLParser
        import html.entities as htmlentitydefs
        from itertools import filterfalse
        from ssl import match_hostname, CertificateError
        class CertificateError(ValueError):
        def _dnsname_match(dn, hostname, max_wildcards=1):
        def match_hostname(cert, hostname):
        from types import SimpleNamespace as Container
        class Container(object):
            def __init__(self, **kwargs):
        from shutil import which
        def which(cmd, mode=os.F_OK | os.X_OK, path=None):
            def _access_check(fn, mode):
    from zipfile import ZipFile as BaseZipFile
        from zipfile import ZipExtFile as BaseZipExtFile
        class ZipExtFile(BaseZipExtFile):
            def __init__(self, base):
            def __enter__(self):
            def __exit__(self, *exc_info):
        class ZipFile(BaseZipFile):
            def __enter__(self):
            def __exit__(self, *exc_info):
            def open(self, *args, **kwargs):
        from platform import python_implementation
        def python_implementation():
    import sysconfig
        from collections.abc import Callable
        def callable(obj):
        def fsencode(filename):
        def fsdecode(filename):
        from tokenize import detect_encoding
        from codecs import BOM_UTF8, lookup
        def _get_normal_name(orig_enc):
        def detect_encoding(readline):
            def read_or_stop():
            def find_cookie(line):
        from html import escape
        from cgi import escape
        from html import unescape
        from collections import ChainMap
        from collections import MutableMapping
            from reprlib import recursive_repr as _recursive_repr
            def _recursive_repr(fillvalue='...'):
                def decorating_function(user_function):
                    def wrapper(self):
        class ChainMap(MutableMapping):
            def __init__(self, *maps):
            def __missing__(self, key):
            def __getitem__(self, key):
            def get(self, key, default=None):
            def __len__(self):
            def __iter__(self):
            def __contains__(self, key):
            def __bool__(self):
            @_recursive_repr()
            def __repr__(self):
            @classmethod
            def fromkeys(cls, iterable, *args):
            def copy(self):
            def new_child(self):  # like Django's Context.push()
            @property
            def parents(self):  # like Django's Context.pop()
            def __setitem__(self, key, value):
            def __delitem__(self, key):
            def popitem(self):
            def pop(self, key, *args):
            def clear(self):
        from importlib.util import cache_from_source  # Python >= 3.4
        def cache_from_source(path, debug_override=None):
        from collections import OrderedDict
            from thread import get_ident as _get_ident
            from dummy_thread import get_ident as _get_ident
            from _abcoll import KeysView, ValuesView, ItemsView
        class OrderedDict(dict):
            def __init__(self, *args, **kwds):
            def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
            def __delitem__(self, key, dict_delitem=dict.__delitem__):
            def __iter__(self):
            def __reversed__(self):
            def clear(self):
            def popitem(self, last=True):
            def keys(self):
            def values(self):
            def items(self):
            def iterkeys(self):
            def itervalues(self):
            def iteritems(self):
            def update(*args, **kwds):
            def pop(self, key, default=__marker):
            def setdefault(self, key, default=None):
            def __repr__(self, _repr_running=None):
            def __reduce__(self):
            def copy(self):
            @classmethod
            def fromkeys(cls, iterable, value=None):
            def __eq__(self, other):
            def __ne__(self, other):
            def viewkeys(self):
            def viewvalues(self):
            def viewitems(self):
        from logging.config import BaseConfigurator, valid_ident
        IDENTIFIER = re.compile('^[a-z_][a-z0-9_]*$', re.I)
        def valid_ident(s):
        class ConvertingDict(dict):
            def __getitem__(self, key):
            def get(self, key, default=None):
        def pop(self, key, default=None):
        class ConvertingList(list):
            def __getitem__(self, key):
            def pop(self, idx=-1):
        class ConvertingTuple(tuple):
            def __getitem__(self, key):
        class BaseConfigurator(object):
            CONVERT_PATTERN = re.compile(r'^(?P<prefix>[a-z]+)://(?P<suffix>.*)$')
            WORD_PATTERN = re.compile(r'^\s*(\w+)\s*')
            DOT_PATTERN = re.compile(r'^\.\s*(\w+)\s*')
            INDEX_PATTERN = re.compile(r'^\[\s*(\w+)\s*\]\s*')
            DIGIT_PATTERN = re.compile(r'^\d+$')
            def __init__(self, config):
            def resolve(self, s):
            def ext_convert(self, value):
            def cfg_convert(self, value):
            def convert(self, value):
            def configure_custom(self, config):
            def as_tuple(self, value):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: database.py
    from __future__ import unicode_literals
    import base64
    import codecs
    import contextlib
    import hashlib
    import logging
    import os
    import posixpath
    import sys
    import zipimport
    from . import DistlibException, resources
    from .compat import StringIO
    from .version import get_scheme, UnsupportedVersionError
    from .metadata import (Metadata, METADATA_FILENAME, WHEEL_METADATA_FILENAME, LEGACY_METADATA_FILENAME)
    from .util import (parse_requirement, cached_property, parse_name_and_version, read_exports, write_exports, CSVReader,
    EXPORTS_FILENAME = 'pydist-exports.json'
    COMMANDS_FILENAME = 'pydist-commands.json'
    DIST_FILES = ('INSTALLER', METADATA_FILENAME, 'RECORD', 'REQUESTED', 'RESOURCES', EXPORTS_FILENAME, 'SHARED')
    DISTINFO_EXT = '.dist-info'
    class _Cache(object):
        def __init__(self):
        def clear(self):
        def add(self, dist):
    class DistributionPath(object):
        def __init__(self, path=None, include_egg=False):
        def _get_cache_enabled(self):
        def _set_cache_enabled(self, value):
        def clear_cache(self):
        def _yield_distributions(self):
                        import warnings
        def _generate_cache(self):
        @classmethod
        def distinfo_dirname(cls, name, version):
        def get_distributions(self):
        def get_distribution(self, name):
        def provides_distribution(self, name, version=None):
        def get_file_path(self, name, relative_path):
        def get_exported_entries(self, category, name=None):
    class Distribution(object):
        def __init__(self, metadata):
        @property
        def source_url(self):
        @property
        def name_and_version(self):
        @property
        def provides(self):
        def _get_requirements(self, req_attr):
        @property
        def run_requires(self):
        @property
        def meta_requires(self):
        @property
        def build_requires(self):
        @property
        def test_requires(self):
        @property
        def dev_requires(self):
        def matches_requirement(self, req):
        def __repr__(self):
        def __eq__(self, other):
        def __hash__(self):
    class BaseInstalledDistribution(Distribution):
        def __init__(self, metadata, path, env=None):
                             from a metadata file in the ``path``.
        def get_hash(self, data, hasher=None):
    class InstalledDistribution(BaseInstalledDistribution):
        def __init__(self, path, metadata=None, env=None):
        def __repr__(self):
        def __str__(self):
        def _get_records(self):
        @cached_property
        def exports(self):
        def read_exports(self):
        def write_exports(self, exports):
        def get_resource_path(self, relative_path):
        def list_installed_files(self):
        def write_installed_files(self, paths, prefix, dry_run=False):
        def check_installed_files(self):
        @cached_property
        def shared_locations(self):
        def write_shared_locations(self, paths, dry_run=False):
        def get_distinfo_resource(self, path):
        def get_distinfo_file(self, path):
        def list_distinfo_files(self):
        def __eq__(self, other):
    class EggInfoDistribution(BaseInstalledDistribution):
        def __init__(self, path, env=None):
            def set_name_and_version(s, n, v):
        def _get_metadata(self, path):
            def parse_requires_data(data):
            def parse_requires_path(req_path):
        def __repr__(self):
        def __str__(self):
        def check_installed_files(self):
        def list_installed_files(self):
            def _md5(path):
            def _size(path):
        def list_distinfo_files(self, absolute=False):
        def __eq__(self, other):
    class DependencyGraph(object):
        def __init__(self):
        def add_distribution(self, distribution):
        def add_edge(self, x, y, label=None):
        def add_missing(self, distribution, requirement):
        def _repr_dist(self, dist):
        def repr_node(self, dist, level=1):
        def to_dot(self, f, skip_disconnected=True):
        def topological_sort(self):
        def __repr__(self):
    def make_graph(dists, scheme='default'):
    def get_dependent_dists(dists, dist):
    def get_required_dists(dists, dist):
    def make_dist(name, version, **kwargs):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: index.py
    import hashlib
    import logging
    import os
    import shutil
    import subprocess
    import tempfile
        from threading import Thread
        from dummy_threading import Thread
    from . import DistlibException
    from .compat import (HTTPBasicAuthHandler, Request, HTTPPasswordMgr,
    from .util import zip_dir, ServerProxy
    DEFAULT_INDEX = 'https://pypi.org/pypi'
    DEFAULT_REALM = 'pypi'
    class PackageIndex(object):
        def __init__(self, url=None):
        def _get_pypirc_command(self):
            from .util import _get_pypirc_command as cmd
        def read_configuration(self):
            from .util import _load_pypirc
        def save_configuration(self):
            from .util import _store_pypirc
        def check_credentials(self):
        def register(self, metadata):  # pragma: no cover
        def _reader(self, name, stream, outbuf):
        def get_sign_command(self, filename, signer, sign_password, keystore=None):  # pragma: no cover
        def run_command(self, cmd, input_data=None):
        def sign_file(self, filename, signer, sign_password, keystore=None):  # pragma: no cover
        def upload_file(self, metadata, filename, signer=None, sign_password=None,
        def upload_documentation(self, metadata, doc_dir):  # pragma: no cover
        def get_verify_command(self, signature_filename, data_filename,
        def verify_signature(self, signature_filename, data_filename,
        def download_file(self, url, destfile, digest=None, reporthook=None):
        def send_request(self, req):
        def encode_request(self, fields, files):
        def search(self, terms, operator=None):  # pragma: no cover

  ðŸ“„ Ð¤Ð°Ð¹Ð»: locators.py
    import gzip
    from io import BytesIO
    import json
    import logging
    import os
    import posixpath
    import re
        import threading
        import dummy_threading as threading
    import zlib
    from . import DistlibException
    from .compat import (urljoin, urlparse, urlunparse, url2pathname, pathname2url, queue, quote, unescape, build_opener,
    from .database import Distribution, DistributionPath, make_dist
    from .metadata import Metadata, MetadataInvalidError
    from .util import (cached_property, ensure_slash, split_filename, get_project_data, parse_requirement,
    from .version import get_scheme, UnsupportedVersionError
    from .wheel import Wheel, is_compatible
    HASHER_HASH = re.compile(r'^(\w+)=([a-f0-9]+)')
    CHARSET = re.compile(r';\s*charset\s*=\s*(.*)\s*$', re.I)
    HTML_CONTENT_TYPE = re.compile('text/html|application/x(ht)?ml')
    DEFAULT_INDEX = 'https://pypi.org/pypi'
    def get_all_distribution_names(url=None):
    class RedirectHandler(BaseRedirectHandler):
        def http_error_302(self, req, fp, code, msg, headers):
    class Locator(object):
        def __init__(self, scheme='default'):
        def get_errors(self):
        def clear_errors(self):
        def clear_cache(self):
        def _get_scheme(self):
        def _set_scheme(self, value):
        def _get_project(self, name):
        def get_distribution_names(self):
        def get_project(self, name):
        def score_url(self, url):
        def prefer_url(self, url1, url2):
            from PyPI over those from other locations, wheel compatibility (if a
        def split_filename(self, filename, project_name):
        def convert_url_to_download_info(self, url, project_name):
            def same_project(name1, name2):
        def _get_digest(self, info):
        def _update_version_data(self, result, info):
        def locate(self, requirement, prereleases=False):
    class PyPIRPCLocator(Locator):
        def __init__(self, url, **kwargs):
        def get_distribution_names(self):
        def _get_project(self, name):
    class PyPIJSONLocator(Locator):
        def __init__(self, url, **kwargs):
        def get_distribution_names(self):
        def _get_project(self, name):
    class Page(object):
        def __init__(self, data, url):
        @cached_property
        def links(self):
            def clean(url):
    class SimpleScrapingLocator(Locator):
        def __init__(self, url, timeout=None, num_workers=10, **kwargs):
        def _prepare_threads(self):
        def _wait_threads(self):
        def _get_project(self, name):
        def _is_platform_dependent(self, url):
        def _process_download(self, url):
        def _should_queue(self, link, referrer, rel):
        def _fetch(self):
        def get_page(self, url):
        def get_distribution_names(self):
    class DirectoryLocator(Locator):
        def __init__(self, path, **kwargs):
        def should_include(self, filename, parent):
        def _get_project(self, name):
        def get_distribution_names(self):
    class JSONLocator(Locator):
        def get_distribution_names(self):
        def _get_project(self, name):
    class DistPathLocator(Locator):
        def __init__(self, distpath, **kwargs):
        def _get_project(self, name):
    class AggregatingLocator(Locator):
        def __init__(self, *locators, **kwargs):
        def clear_cache(self):
        def _set_scheme(self, value):
        def _get_project(self, name):
        def get_distribution_names(self):
    class DependencyFinder(object):
        def __init__(self, locator=None):
        def add_distribution(self, dist):
        def remove_distribution(self, dist):
        def get_matcher(self, reqt):
        def find_providers(self, reqt):
        def try_to_replace(self, provider, other, problems):
        def find(self, requirement, meta_extras=None, prereleases=False):
            from the ``requirement`` passed to ``find()``, and they have the

  ðŸ“„ Ð¤Ð°Ð¹Ð»: manifest.py
    import fnmatch
    import logging
    import os
    import re
    import sys
    from . import DistlibException
    from .compat import fsdecode
    from .util import convert_path
    _COLLAPSE_PATTERN = re.compile('\\\\w*\n', re.M)
    _COMMENTED_LINE = re.compile('#.*?(?=\n)|\n(?=$)', re.M | re.S)
    _PYTHON_VERSION = sys.version_info[:2]
    class Manifest(object):
        def __init__(self, base=None):
        def findall(self):
            from stat import S_ISREG, S_ISDIR, S_ISLNK
        def add(self, item):
        def add_many(self, items):
        def sorted(self, wantdirs=False):
            def add_dir(dirs, d):
        def clear(self):
        def process_directive(self, directive):
        def _parse_directive(self, directive):
        def _include_pattern(self, pattern, anchor=True, prefix=None,
        def _exclude_pattern(self, pattern, anchor=True, prefix=None,
        def _translate_pattern(self, pattern, anchor=True, prefix=None,
        def _glob_to_re(self, pattern):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: markers.py
    import os
    import re
    import sys
    import platform
    from .compat import string_types
    from .util import in_venv, parse_marker
    from .version import LegacyVersion as LV
    _VERSION_PATTERN = re.compile(r'((\d+(\.\d+)*\w*)|\'(\d+(\.\d+)*\w*)\'|\"(\d+(\.\d+)*\w*)\")')
    _VERSION_MARKERS = {'python_version', 'python_full_version'}
    def _is_version_marker(s):
    def _is_literal(o):
    def _get_versions(s):
    class Evaluator(object):
        def evaluate(self, expr, context):
    _DIGITS = re.compile(r'\d+\.\d+')
    def default_context():
        def format_full_version(info):
    DEFAULT_CONTEXT = default_context()
    def interpret(marker, execution_context=None):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: metadata.py
    from __future__ import unicode_literals
    import codecs
    from email import message_from_file
    import json
    import logging
    import re
    from . import DistlibException, __version__
    from .compat import StringIO, string_types, text_type
    from .markers import interpret
    from .util import extract_by_key, get_extras
    from .version import get_scheme, PEP440_VERSION_RE
    class MetadataMissingError(DistlibException):
    class MetadataConflictError(DistlibException):
    class MetadataUnrecognizedVersionError(DistlibException):
    class MetadataInvalidError(DistlibException):
    PKG_INFO_ENCODING = 'utf-8'
    PKG_INFO_PREFERRED_VERSION = '1.1'
    _ALL_FIELDS = set()
    EXTRA_RE = re.compile(r'''extra\s*==\s*("([^"]+)"|'([^']+)')''')
    def _version2fieldlist(version):
    def _best_version(fields):
        def _has_marker(keys, markers):
    _PREDICATE_FIELDS = ('Requires-Dist', 'Obsoletes-Dist', 'Provides-Dist')
    _VERSIONS_FIELDS = ('Requires-Python', )
    _VERSION_FIELDS = ('Version', )
    _LISTFIELDS = ('Platform', 'Classifier', 'Obsoletes', 'Requires', 'Provides', 'Obsoletes-Dist', 'Provides-Dist',
    _LISTTUPLEFIELDS = ('Project-URL', )
    _ELEMENTSFIELD = ('Keywords', )
    _UNICODEFIELDS = ('Author', 'Maintainer', 'Summary', 'Description')
    _MISSING = object()
    _FILESAFE = re.compile('[^A-Za-z0-9.]+')
    def _get_name_and_version(name, version, for_filename=False):
    class LegacyMetadata(object):
        def __init__(self, path=None, fileobj=None, mapping=None, scheme='default'):
        def set_metadata_version(self):
        def _write_field(self, fileobj, name, value):
        def __getitem__(self, name):
        def __setitem__(self, name, value):
        def __delitem__(self, name):
        def __contains__(self, name):
        def _convert_name(self, name):
        def _default_value(self, name):
        def _remove_line_prefix(self, value):
        def __getattr__(self, name):
        def get_fullname(self, filesafe=False):
        def is_field(self, name):
        def is_multi_field(self, name):
        def read(self, filepath):
        def read_file(self, fileob):
        def write(self, filepath, skip_unknown=False):
        def write_file(self, fileobject, skip_unknown=False):
        def update(self, other=None, **kwargs):
            def _set(key, value):
        def set(self, name, value):
        def get(self, name, default=_MISSING):
        def check(self, strict=False):
            def are_valid_constraints(value):
        def todict(self, skip_missing=False):
        def add_requirements(self, requirements):
        def keys(self):
        def __iter__(self):
        def values(self):
        def items(self):
        def __repr__(self):
    METADATA_FILENAME = 'pydist.json'
    WHEEL_METADATA_FILENAME = 'metadata.json'
    LEGACY_METADATA_FILENAME = 'METADATA'
    class Metadata(object):
        METADATA_VERSION_MATCHER = re.compile(r'^\d+(\.\d+)*$')
        NAME_MATCHER = re.compile('^[0-9A-Z]([0-9A-Z_.-]*[0-9A-Z])?$', re.I)
        FIELDNAME_MATCHER = re.compile('^[A-Z]([0-9A-Z-]*[0-9A-Z])?$', re.I)
        VERSION_MATCHER = PEP440_VERSION_RE
        SUMMARY_MATCHER = re.compile('.{1,2047}')
        METADATA_VERSION = '2.0'
        GENERATOR = 'distlib (%s)' % __version__
        MANDATORY_KEYS = {
        INDEX_KEYS = ('name version license summary description author '
        DEPENDENCY_KEYS = ('extras run_requires test_requires build_requires '
        SYNTAX_VALIDATORS = {
        def __init__(self, path=None, fileobj=None, mapping=None, scheme='default'):
        def __getattribute__(self, key):
        def _validate_value(self, key, value, scheme=None):
        def __setattr__(self, key, value):
        @property
        def name_and_version(self):
        @property
        def provides(self):
        @provides.setter
        def provides(self, value):
        def get_requirements(self, reqts, extras=None, env=None):
        @property
        def dictionary(self):
        @property
        def dependencies(self):
        @dependencies.setter
        def dependencies(self, value):
        def _validate_mapping(self, mapping, scheme):
        def validate(self):
        def todict(self):
        def _from_legacy(self):
        LEGACY_MAPPING = {
        def _to_legacy(self):
            def process_entries(entries):
        def write(self, path=None, fileobj=None, legacy=False, skip_unknown=True):
        def add_requirements(self, requirements):
        def __repr__(self):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: resources.py
    from __future__ import unicode_literals
    import bisect
    import io
    import logging
    import os
    import pkgutil
    import sys
    import types
    import zipimport
    from . import DistlibException
    from .util import cached_property, get_cache_base, Cache
    class ResourceCache(Cache):
        def __init__(self, base=None):
        def is_stale(self, resource, path):
        def get(self, resource):
    class ResourceBase(object):
        def __init__(self, finder, name):
    class Resource(ResourceBase):
        def as_stream(self):
        @cached_property
        def file_path(self):
        @cached_property
        def bytes(self):
        @cached_property
        def size(self):
    class ResourceContainer(ResourceBase):
        @cached_property
        def resources(self):
    class ResourceFinder(object):
        def __init__(self, module):
        def _adjust_path(self, path):
        def _make_path(self, resource_name):
        def _find(self, path):
        def get_cache_info(self, resource):
        def find(self, resource_name):
        def get_stream(self, resource):
        def get_bytes(self, resource):
        def get_size(self, resource):
        def get_resources(self, resource):
            def allowed(f):
        def is_container(self, resource):
        def iterator(self, resource_name):
    class ZipResourceFinder(ResourceFinder):
        def __init__(self, module):
        def _adjust_path(self, path):
        def _find(self, path):
        def get_cache_info(self, resource):
        def get_bytes(self, resource):
        def get_stream(self, resource):
        def get_size(self, resource):
        def get_resources(self, resource):
        def _is_directory(self, path):
            import _frozen_importlib_external as _fi
            import _frozen_importlib as _fi
    def register_finder(loader, finder_maker):
    def finder(package):
    def finder_for_path(path):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: scripts.py
    from io import BytesIO
    import logging
    import os
    import re
    import struct
    import sys
    import time
    from zipfile import ZipInfo
    from .compat import sysconfig, detect_encoding, ZipFile
    from .resources import finder
    from .util import (FileOperator, get_export_entry, convert_path, get_executable, get_platform, in_venv)
    _DEFAULT_MANIFEST = '''
    FIRST_LINE_RE = re.compile(b'^#!.*pythonw?[0-9.]*([ \t].*)?$')
    SCRIPT_TEMPLATE = r'''# -*- coding: utf-8 -*-
    import re
    import sys
    from %(module)s import %(import_name)s
        DISTLIB_PACKAGE = __name__.rsplit('.', 1)[0]
        WRAPPERS = {
    def enquote_executable(executable):
    class ScriptMaker(object):
        def __init__(self, source_dir, target_dir, add_launchers=True, dry_run=False, fileop=None):
        def _get_alternate_executable(self, executable, options):
            def _is_shell(self, executable):
            def _fix_jython_executable(self, executable):
                    import java
        def _build_shebang(self, executable, post_interp):
        def _get_shebang(self, encoding, post_interp=b'', options=None):
        def _get_script_text(self, entry):
        def get_manifest(self, exename):
        def _write_script(self, names, shebang, script_bytes, filenames, ext):
        def get_script_filenames(self, name):
        def _make_script(self, entry, filenames, options=None):
        def _copy_script(self, script, filenames):
        @property
        def dry_run(self):
        @dry_run.setter
        def dry_run(self, value):
            def _get_launcher(self, kind):
        def make(self, specification, options=None):
        def make_multiple(self, specifications, options=None):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: util.py
    import codecs
    from collections import deque
    import contextlib
    import csv
    from glob import iglob as std_iglob
    import io
    import json
    import logging
    import os
    import py_compile
    import re
    import socket
        import ssl
    import subprocess
    import sys
    import tarfile
    import tempfile
    import textwrap
        import threading
        import dummy_threading as threading
    import time
    from . import DistlibException
    from .compat import (string_types, text_type, shutil, raw_input, StringIO, cache_from_source, urlopen, urljoin, httplib,
    IDENTIFIER = re.compile(r'^([\w\.-]+)\s*')
    VERSION_IDENTIFIER = re.compile(r'^([\w\.*+-]+)\s*')
    COMPARE_OP = re.compile(r'^(<=?|>=?|={2,3}|[~!]=)\s*')
    MARKER_OP = re.compile(r'^((<=?)|(>=?)|={2,3}|[~!]=|in|not\s+in)\s*')
    OR = re.compile(r'^or\b\s*')
    AND = re.compile(r'^and\b\s*')
    NON_SPACE = re.compile(r'(\S+)\s*')
    STRING_CHUNK = re.compile(r'([\s\w\.{}()*+#:;,/?!~`@$%^&=|<>\[\]-]+)')
    def parse_marker(marker_string):
        def marker_var(remaining):
        def marker_expr(remaining):
        def marker_and(remaining):
        def marker(remaining):
    def parse_requirement(req):
                def get_versions(ver_remaining):
    def get_resources_dests(resources_root, rules):
        def get_rel_path(root, path):
    def in_venv():
    def get_executable():
    def proceed(prompt, allowed_chars, error_prompt=None, default=None):
    def extract_by_key(d, keys):
    def read_exports(stream):
        def read_stream(cp, stream):
    def write_exports(exports, stream):
    @contextlib.contextmanager
    def tempdir():
    @contextlib.contextmanager
    def chdir(d):
    @contextlib.contextmanager
    def socket_timeout(seconds=15):
    class cached_property(object):
        def __init__(self, func):
        def __get__(self, obj, cls=None):
    def convert_path(pathname):
    class FileOperator(object):
        def __init__(self, dry_run=False):
        def _init_record(self):
        def record_as_written(self, path):
        def newer(self, source, target):
        def copy_file(self, infile, outfile, check=True):
        def copy_stream(self, instream, outfile, encoding=None):
        def write_binary_file(self, path, data):
        def write_text_file(self, path, data, encoding):
        def set_mode(self, bits, mask, files):
        def ensure_dir(self, path):
        def byte_compile(self, path, optimize=False, force=False, prefix=None, hashed_invalidation=False):
        def ensure_removed(self, path):
        def is_writable(self, path):
        def commit(self):
        def rollback(self):
    def resolve(module_name, dotted_path):
    class ExportEntry(object):
        def __init__(self, name, prefix, suffix, flags):
        @cached_property
        def value(self):
        def __repr__(self):  # pragma: no cover
        def __eq__(self, other):
    ENTRY_RE = re.compile(
    def get_export_entry(specification):
    def get_cache_base(suffix=None):
    def path_to_cache_dir(path, use_abspath=True):
    def ensure_slash(s):
    def parse_credentials(netloc):
    def get_process_umask():
    def is_string_sequence(seq):
    PROJECT_NAME_AND_VERSION = re.compile('([a-z0-9_]+([.-][a-z_][a-z0-9_]*)*)-'
    PYTHON_VERSION = re.compile(r'-py(\d\.?\d?)')
    def split_filename(filename, project_name=None):
    NAME_VERSION_RE = re.compile(r'(?P<name>[\w .-]+)\s*'
    def parse_name_and_version(p):
    def get_extras(requested, available):
    def _get_external_data(url):
    def get_project_data(name):
    def get_package_data(name, version):
    class Cache(object):
        def __init__(self, base):
        def prefix_to_dir(self, prefix, use_abspath=True):
        def clear(self):
    class EventMixin(object):
        def __init__(self):
        def add(self, event, subscriber, append=True):
        def remove(self, event, subscriber):
        def get_subscribers(self, event):
        def publish(self, event, *args, **kwargs):
    class Sequencer(object):
        def __init__(self):
        def add_node(self, node):
        def remove_node(self, node, edges=False):
        def add(self, pred, succ):
        def remove(self, pred, succ):
        def is_step(self, step):
        def get_steps(self, final):
        @property
        def strong_connections(self):
            def strongconnect(node):
        @property
        def dot(self):
    ARCHIVE_EXTENSIONS = ('.tar.gz', '.tar.bz2', '.tar', '.zip', '.tgz', '.tbz', '.whl')
    def unarchive(archive_filename, dest_dir, format=None, check=True):
        def check_path(path):
            def extraction_filter(member, path):
    def zip_dir(directory):
    UNITS = ('', 'K', 'M', 'G', 'T', 'P')
    class Progress(object):
        def __init__(self, minval=0, maxval=100):
        def update(self, curval):
        def increment(self, incr):
        def start(self):
        def stop(self):
        @property
        def maximum(self):
        @property
        def percentage(self):
        def format_duration(self, duration):
        @property
        def ETA(self):
        @property
        def speed(self):
    RICH_GLOB = re.compile(r'\{([^}]*)\}')
    _CHECK_RECURSIVE_GLOB = re.compile(r'[^/\\,{]\*\*|\*\*[^/\\,}]')
    _CHECK_MISMATCH_SET = re.compile(r'^[^{]*\}|\{[^}]*$')
    def iglob(path_glob):
    def _iglob(path_glob):
        from .compat import (HTTPSHandler as BaseHTTPSHandler, match_hostname, CertificateError)
        class HTTPSConnection(httplib.HTTPSConnection):
            def connect(self):
        class HTTPSHandler(BaseHTTPSHandler):
            def __init__(self, ca_certs, check_domain=True):
            def _conn_maker(self, *args, **kwargs):
            def https_open(self, req):
        class HTTPSOnlyHandler(HTTPSHandler, HTTPHandler):
            def http_open(self, req):
    class Transport(xmlrpclib.Transport):
        def __init__(self, timeout, use_datetime=0):
        def make_connection(self, host):
        class SafeTransport(xmlrpclib.SafeTransport):
            def __init__(self, timeout, use_datetime=0):
            def make_connection(self, host):
    class ServerProxy(xmlrpclib.ServerProxy):
        def __init__(self, uri, **kwargs):
    def _csv_open(fn, mode, **kwargs):
    class CSVBase(object):
        def __enter__(self):
        def __exit__(self, *exc_info):
    class CSVReader(CSVBase):
        def __init__(self, **kwargs):
        def __iter__(self):
        def next(self):
    class CSVWriter(CSVBase):
        def __init__(self, fn, **kwargs):
        def writerow(self, row):
    class Configurator(BaseConfigurator):
        def __init__(self, config, base=None):
        def configure_custom(self, config):
            def convert(o):
        def __getitem__(self, key):
        def inc_convert(self, value):
    class SubprocessMixin(object):
        def __init__(self, verbose=False, progress=None):
        def reader(self, stream, context):
        def run_command(self, cmd, **kwargs):
    def normalize_name(name):
    class PyPIRCFile(object):
        DEFAULT_REPOSITORY = 'https://upload.pypi.org/legacy/'
        DEFAULT_REALM = 'pypi'
        def __init__(self, fn=None, url=None):
        def read(self):
        def update(self, username, password):
    def _load_pypirc(index):
    def _store_pypirc(index):
    def get_host_platform():
            from _aix_support import aix_platform
            import _osx_support
                from distutils import sysconfig
                import sysconfig
    _TARGET_TO_PLAT = {
    def get_platform():

  ðŸ“„ Ð¤Ð°Ð¹Ð»: version.py
    import logging
    import re
    from .compat import string_types
    from .util import parse_requirement
    class UnsupportedVersionError(ValueError):
    class Version(object):
        def __init__(self, s):
        def parse(self, s):
        def _check_compatible(self, other):
        def __eq__(self, other):
        def __ne__(self, other):
        def __lt__(self, other):
        def __gt__(self, other):
        def __le__(self, other):
        def __ge__(self, other):
        def __hash__(self):
        def __repr__(self):
        def __str__(self):
        @property
        def is_prerelease(self):
    class Matcher(object):
        def parse_requirement(self, s):
        def __init__(self, s):
        def match(self, version):
        @property
        def exact_version(self):
        def _check_compatible(self, other):
        def __eq__(self, other):
        def __ne__(self, other):
        def __hash__(self):
        def __repr__(self):
        def __str__(self):
    def _pep_440_key(s):
    class NormalizedVersion(Version):
        def parse(self, s):
        PREREL_TAGS = set(['a', 'b', 'c', 'rc', 'dev'])
        @property
        def is_prerelease(self):
    def _match_prefix(x, y):
    class NormalizedMatcher(Matcher):
        def _adjust_local(self, version, constraint, prefix):
        def _match_lt(self, version, constraint, prefix):
        def _match_gt(self, version, constraint, prefix):
        def _match_le(self, version, constraint, prefix):
        def _match_ge(self, version, constraint, prefix):
        def _match_eq(self, version, constraint, prefix):
        def _match_arbitrary(self, version, constraint, prefix):
        def _match_ne(self, version, constraint, prefix):
        def _match_compatible(self, version, constraint, prefix):
    _REPLACEMENTS = (
    _SUFFIX_REPLACEMENTS = (
    _NUMERIC_PREFIX = re.compile(r'(\d+(\.\d+)*)')
    def _suggest_semantic_version(s):
    def _suggest_normalized_version(s):
        @param s {str} An irrational version string.
        @returns A rational version string, or None, if couldn't determine one.
    _VERSION_PART = re.compile(r'([a-z]+|\d+|[\.-])', re.I)
    _VERSION_REPLACE = {
    def _legacy_key(s):
        def get_parts(s):
    class LegacyVersion(Version):
        def parse(self, s):
        @property
        def is_prerelease(self):
    class LegacyMatcher(Matcher):
        def _match_compatible(self, version, constraint, prefix):
    _SEMVER_RE = re.compile(r'^(\d+)\.(\d+)\.(\d+)'
    def is_semver(s):
    def _semantic_key(s):
        def make_tuple(s, absent):
    class SemanticVersion(Version):
        def parse(self, s):
        @property
        def is_prerelease(self):
    class SemanticMatcher(Matcher):
    class VersionScheme(object):
        def __init__(self, key, matcher, suggester=None):
        def is_valid_version(self, s):
        def is_valid_matcher(self, s):
        def is_valid_constraint_list(self, s):
        def suggest(self, s):
    _SCHEMES = {
    def get_scheme(name):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: wheel.py
    from __future__ import unicode_literals
    import base64
    import codecs
    import datetime
    from email import message_from_file
    import hashlib
    import json
    import logging
    import os
    import posixpath
    import re
    import shutil
    import sys
    import tempfile
    import zipfile
    from . import __version__, DistlibException
    from .compat import sysconfig, ZipFile, fsdecode, text_type, filter
    from .database import InstalledDistribution
    from .metadata import Metadata, WHEEL_METADATA_FILENAME, LEGACY_METADATA_FILENAME
    from .util import (FileOperator, convert_path, CSVReader, CSVWriter, Cache, cached_property, get_cache_base,
    from .version import NormalizedVersion, UnsupportedVersionError
        IMP_PREFIX = 'pp'
        IMP_PREFIX = 'jy'
        IMP_PREFIX = 'ip'
        IMP_PREFIX = 'cp'
    VER_SUFFIX = sysconfig.get_config_var('py_version_nodot')
        VER_SUFFIX = '%s%s' % sys.version_info[:2]
    PYVER = 'py' + VER_SUFFIX
    IMPVER = IMP_PREFIX + VER_SUFFIX
    ARCH = get_platform().replace('-', '_').replace('.', '_')
    ABI = sysconfig.get_config_var('SOABI')
        ABI = ABI.replace('cpython-', 'cp').split('-')[0]
        def _derive_abi():
        ABI = _derive_abi()
    FILENAME_RE = re.compile(
    NAME_VERSION_RE = re.compile(r'''
    SHEBANG_RE = re.compile(br'\s*#![^\r\n]*')
    SHEBANG_DETAIL_RE = re.compile(br'^(\s*#!("[^"]+"|\S+))\s+(.*)$')
    SHEBANG_PYTHON = b'#!python'
    SHEBANG_PYTHONW = b'#!pythonw'
        import imp
        import importlib.machinery
        import importlib.util
    def _get_suffixes():
    def _load_dynamic(name, path):
    class Mounter(object):
        def __init__(self):
        def add(self, pathname, extensions):
        def remove(self, pathname):
        def find_module(self, fullname, path=None):
        def load_module(self, fullname):
    class Wheel(object):
        def __init__(self, filename=None, sign=False, verify=False):
        @property
        def filename(self):
        @property
        def exists(self):
        @property
        def tags(self):
        @cached_property
        def metadata(self):
        def get_wheel_metadata(self, zf):
        @cached_property
        def info(self):
        def process_shebang(self, data):
        def get_hash(self, data, hash_kind=None):
        def write_record(self, records, record_path, archive_record_path):
        def write_records(self, info, libdir, archive_paths):
        def build_zip(self, pathname, archive_paths):
        def build(self, paths, tags=None, wheel_version=None):
            def sorter(t):
        def skip_entry(self, arcname):
        def install(self, paths, maker, **kwargs):
        def _get_dylib_cache(self):
        def _get_extensions(self):
        def is_compatible(self):
        def is_mountable(self):
        def mount(self, append=False):
        def unmount(self):
        def verify(self):
        def update(self, modifier, dest_dir=None, **kwargs):
            def get_version(path_map, info_dir):
            def update_version(version, path):
    def _get_glibc_version():
        import platform
    def compatible_tags():
        class _Version:
            def __init__(self, major, minor):
            def __str__(self):
    COMPATIBLE_TAGS = compatible_tags()
    def is_compatible(wheel, tags=None):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    import logging
    class DistlibException(Exception):
        from logging import NullHandler
        class NullHandler(logging.Handler):
            def handle(self, record):
            def emit(self, record):
            def createLock(self):

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\distro

  ðŸ“„ Ð¤Ð°Ð¹Ð»: distro.py
    import argparse
    import json
    import logging
    import os
    import re
    import shlex
    import subprocess
    import sys
    import warnings
    from typing import (
        from typing import TypedDict
    class VersionDict(TypedDict):
    class InfoDict(TypedDict):
    _UNIXCONFDIR = os.environ.get("UNIXCONFDIR", "/etc")
    _UNIXUSRLIBDIR = os.environ.get("UNIXUSRLIBDIR", "/usr/lib")
    _OS_RELEASE_BASENAME = "os-release"
    NORMALIZED_OS_ID = {
    NORMALIZED_LSB_ID = {
    NORMALIZED_DISTRO_ID = {
    _DISTRO_RELEASE_CONTENT_REVERSED_PATTERN = re.compile(
    _DISTRO_RELEASE_BASENAME_PATTERN = re.compile(r"(\w+)[-_](release|version)$")
    _DISTRO_RELEASE_BASENAMES = [
    _DISTRO_RELEASE_IGNORE_BASENAMES = (
    def linux_distribution(full_distribution_name: bool = True) -> Tuple[str, str, str]:
    def id() -> str:
          from the distro release file name.
    def name(pretty: bool = False) -> str:
    def version(pretty: bool = False, best: bool = False) -> str:
    def version_parts(best: bool = False) -> Tuple[str, str, str]:
    def major_version(best: bool = False) -> str:
    def minor_version(best: bool = False) -> str:
    def build_number(best: bool = False) -> str:
    def like() -> str:
    def codename() -> str:
    def info(pretty: bool = False, best: bool = False) -> InfoDict:
    def os_release_info() -> Dict[str, str]:
        from the os-release file data source of the current OS distribution.
    def lsb_release_info() -> Dict[str, str]:
        from the lsb_release command data source of the current OS distribution.
    def distro_release_info() -> Dict[str, str]:
        from the distro release file data source of the current OS distribution.
    def uname_info() -> Dict[str, str]:
        from the distro release file data source of the current OS distribution.
    def os_release_attr(attribute: str) -> str:
    def lsb_release_attr(attribute: str) -> str:
    def distro_release_attr(attribute: str) -> str:
    def uname_attr(attribute: str) -> str:
        from functools import cached_property
        class cached_property:  # type: ignore
            def __init__(self, f: Callable[[Any], Any]) -> None:
            def __get__(self, obj: Any, owner: Type[Any]) -> Any:
    class LinuxDistribution:
        def __init__(
        def __repr__(self) -> str:
        def linux_distribution(
        def id(self) -> str:
            def normalize(distro_id: str, table: Dict[str, str]) -> str:
        def name(self, pretty: bool = False) -> str:
        def version(self, pretty: bool = False, best: bool = False) -> str:
        def version_parts(self, best: bool = False) -> Tuple[str, str, str]:
        def major_version(self, best: bool = False) -> str:
        def minor_version(self, best: bool = False) -> str:
        def build_number(self, best: bool = False) -> str:
        def like(self) -> str:
        def codename(self) -> str:
        def info(self, pretty: bool = False, best: bool = False) -> InfoDict:
        def os_release_info(self) -> Dict[str, str]:
        def lsb_release_info(self) -> Dict[str, str]:
        def distro_release_info(self) -> Dict[str, str]:
        def uname_info(self) -> Dict[str, str]:
        def oslevel_info(self) -> str:
        def os_release_attr(self, attribute: str) -> str:
        def lsb_release_attr(self, attribute: str) -> str:
        def distro_release_attr(self, attribute: str) -> str:
        def uname_attr(self, attribute: str) -> str:
        @cached_property
        def _os_release_info(self) -> Dict[str, str]:
        @staticmethod
        def _parse_os_release_content(lines: TextIO) -> Dict[str, str]:
        @cached_property
        def _lsb_release_info(self) -> Dict[str, str]:
        @staticmethod
        def _parse_lsb_release_content(lines: Iterable[str]) -> Dict[str, str]:
        @cached_property
        def _uname_info(self) -> Dict[str, str]:
        @cached_property
        def _oslevel_info(self) -> str:
        @cached_property
        def _debian_version(self) -> str:
        @staticmethod
        def _parse_uname_content(lines: Sequence[str]) -> Dict[str, str]:
        @staticmethod
        def _to_str(bytestring: bytes) -> str:
        @cached_property
        def _distro_release_info(self) -> Dict[str, str]:
        def _parse_distro_release_file(self, filepath: str) -> Dict[str, str]:
        @staticmethod
        def _parse_distro_release_content(line: str) -> Dict[str, str]:
    def main() -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from .distro import (

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __main__.py
    from .distro import main

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\idna

  ðŸ“„ Ð¤Ð°Ð¹Ð»: codec.py
    import codecs
    import re
    from typing import Any, Optional, Tuple
    from .core import IDNAError, alabel, decode, encode, ulabel
    class Codec(codecs.Codec):
        def encode(self, data: str, errors: str = "strict") -> Tuple[bytes, int]:
        def decode(self, data: bytes, errors: str = "strict") -> Tuple[str, int]:
    class IncrementalEncoder(codecs.BufferedIncrementalEncoder):
        def _buffer_encode(self, data: str, errors: str, final: bool) -> Tuple[bytes, int]:
    class IncrementalDecoder(codecs.BufferedIncrementalDecoder):
        def _buffer_decode(self, data: Any, errors: str, final: bool) -> Tuple[str, int]:
    class StreamWriter(Codec, codecs.StreamWriter):
    class StreamReader(Codec, codecs.StreamReader):
    def search_function(name: str) -> Optional[codecs.CodecInfo]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: compat.py
    from typing import Any, Union
    from .core import decode, encode
    def ToASCII(label: str) -> bytes:
    def ToUnicode(label: Union[bytes, bytearray]) -> str:
    def nameprep(s: Any) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: core.py
    import bisect
    import re
    import unicodedata
    from typing import Optional, Union
    from . import idnadata
    from .intranges import intranges_contain
    class IDNAError(UnicodeError):
    class IDNABidiError(IDNAError):
    class InvalidCodepoint(IDNAError):
    class InvalidCodepointContext(IDNAError):
    def _combining_class(cp: int) -> int:
    def _is_script(cp: str, script: str) -> bool:
    def _punycode(s: str) -> bytes:
    def _unot(s: int) -> str:
    def valid_label_length(label: Union[bytes, str]) -> bool:
    def valid_string_length(label: Union[bytes, str], trailing_dot: bool) -> bool:
    def check_bidi(label: str, check_ltr: bool = False) -> bool:
    def check_initial_combiner(label: str) -> bool:
    def check_hyphen_ok(label: str) -> bool:
    def check_nfc(label: str) -> None:
    def valid_contextj(label: str, pos: int) -> bool:
    def valid_contexto(label: str, pos: int, exception: bool = False) -> bool:
    def check_label(label: Union[str, bytes, bytearray]) -> None:
    def alabel(label: str) -> bytes:
    def ulabel(label: Union[str, bytes, bytearray]) -> str:
    def uts46_remap(domain: str, std3_rules: bool = True, transitional: bool = False) -> str:
        from .uts46data import uts46data
    def encode(
    def decode(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: idnadata.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

  ðŸ“„ Ð¤Ð°Ð¹Ð»: intranges.py
    import bisect
    from typing import List, Tuple
    def intranges_from_list(list_: List[int]) -> Tuple[int, ...]:
    def _encode_range(start: int, end: int) -> int:
    def _decode_range(r: int) -> Tuple[int, int]:
    def intranges_contain(int_: int, ranges: Tuple[int, ...]) -> bool:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: package_data.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

  ðŸ“„ Ð¤Ð°Ð¹Ð»: uts46data.py
    from typing import List, Tuple, Union
    def _seg_0() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_1() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_2() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_3() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_4() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_5() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_6() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_7() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_8() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_9() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_10() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_11() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_12() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_13() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_14() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_15() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_16() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_17() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_18() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_19() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_20() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_21() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_22() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_23() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_24() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_25() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_26() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_27() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_28() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_29() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_30() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_31() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_32() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_33() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_34() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_35() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_36() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_37() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_38() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_39() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_40() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_41() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_42() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_43() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_44() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_45() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_46() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_47() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_48() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_49() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_50() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_51() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_52() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_53() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_54() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_55() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_56() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_57() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_58() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_59() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_60() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_61() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_62() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_63() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_64() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_65() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_66() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_67() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_68() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_69() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_70() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_71() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_72() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_73() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_74() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_75() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_76() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_77() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_78() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_79() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_80() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:
    def _seg_81() -> List[Union[Tuple[int, str], Tuple[int, str, str]]]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from .core import (
    from .intranges import intranges_contain
    from .package_data import __version__

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\msgpack

  ðŸ“„ Ð¤Ð°Ð¹Ð»: exceptions.py
    class UnpackException(Exception):
    class BufferFull(UnpackException):
    class OutOfData(UnpackException):
    class FormatError(ValueError, UnpackException):
    class StackError(ValueError, UnpackException):
    class ExtraData(UnpackValueError):
        def __init__(self, unpacked, extra):
        def __str__(self):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: ext.py
    import datetime
    import struct
    from collections import namedtuple
    class ExtType(namedtuple("ExtType", "code data")):
        def __new__(cls, code, data):
    class Timestamp:
        def __init__(self, seconds, nanoseconds=0):
        def __repr__(self):
        def __eq__(self, other):
        def __ne__(self, other):
        def __hash__(self):
        @staticmethod
        def from_bytes(b):
        def to_bytes(self):
        @staticmethod
        def from_unix(unix_sec):
        def to_unix(self):
        @staticmethod
        def from_unix_nano(unix_ns):
        def to_unix_nano(self):
        def to_datetime(self):
        @staticmethod
        def from_datetime(dt):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: fallback.py
    import struct
    import sys
    from datetime import datetime as _DateTime
        from __pypy__ import newlist_hint
        from __pypy__.builders import BytesBuilder
        _USING_STRINGBUILDER = True
        class BytesIO:
            def __init__(self, s=b""):
            def write(self, s):
            def getvalue(self):
        from io import BytesIO
        _USING_STRINGBUILDER = False
        def newlist_hint(size):
    from .exceptions import BufferFull, ExtraData, FormatError, OutOfData, StackError
    from .ext import ExtType, Timestamp
    EX_SKIP = 0
    EX_CONSTRUCT = 1
    EX_READ_ARRAY_HEADER = 2
    EX_READ_MAP_HEADER = 3
    TYPE_IMMEDIATE = 0
    TYPE_ARRAY = 1
    TYPE_MAP = 2
    TYPE_RAW = 3
    TYPE_BIN = 4
    TYPE_EXT = 5
    DEFAULT_RECURSE_LIMIT = 511
    def _check_type_strict(obj, t, type=type, tuple=tuple):
    def _get_data_from_buffer(obj):
    def unpackb(packed, **kwargs):
    _NO_FORMAT_USED = ""
    _MSGPACK_HEADERS = {
    class Unpacker:
        def __init__(
        def feed(self, next_bytes):
        def _consume(self):
        def _got_extradata(self):
        def _get_extradata(self):
        def read_bytes(self, n):
        def _read(self, n, raise_outofdata=True):
        def _reserve(self, n, raise_outofdata=True):
        def _read_header(self):
        def _unpack(self, execute=EX_CONSTRUCT):
        def __iter__(self):
        def __next__(self):
        def skip(self):
        def unpack(self):
        def read_array_header(self):
        def read_map_header(self):
        def tell(self):
    class Packer:
            from serializable types will not be serialized and will be
        def __init__(
        def _pack(
                    L = len(data)
        def pack(self, obj):
        def pack_map_pairs(self, pairs):
        def pack_array_header(self, n):
        def pack_map_header(self, n):
        def pack_ext_type(self, typecode, data):
            L = len(data)
        def _pack_array_header(self, n):
        def _pack_map_header(self, n):
        def _pack_map_pairs(self, n, pairs, nest_limit=DEFAULT_RECURSE_LIMIT):
        def _pack_raw_header(self, n):
        def _pack_bin_header(self, n):
        def bytes(self):
        def reset(self):
        def getbuffer(self):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    import os
    from .exceptions import *  # noqa: F403
    from .ext import ExtType, Timestamp
        from .fallback import Packer, Unpacker, unpackb
            from ._cmsgpack import Packer, Unpacker, unpackb
            from .fallback import Packer, Unpacker, unpackb
    def pack(o, stream, **kwargs):
    def packb(o, **kwargs):
    def unpack(stream, **kwargs):

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\packaging

  ðŸ“„ Ð¤Ð°Ð¹Ð»: markers.py
    from __future__ import annotations
    import operator
    import os
    import platform
    import sys
    from typing import Any, Callable, TypedDict, cast
    from ._parser import MarkerAtom, MarkerList, Op, Value, Variable
    from ._parser import parse_marker as _parse_marker
    from ._tokenizer import ParserSyntaxError
    from .specifiers import InvalidSpecifier, Specifier
    from .utils import canonicalize_name
    class InvalidMarker(ValueError):
    class UndefinedComparison(ValueError):
    class UndefinedEnvironmentName(ValueError):
    class Environment(TypedDict):
    def _normalize_extra_values(results: Any) -> Any:
    def _format_marker(
    def _eval_op(lhs: str, op: Op, rhs: str) -> bool:
    def _normalize(*values: str, key: str) -> tuple[str, ...]:
    def _evaluate_markers(markers: MarkerList, environment: dict[str, str]) -> bool:
    def format_full_version(info: sys._version_info) -> str:
    def default_environment() -> Environment:
    class Marker:
        def __init__(self, marker: str) -> None:
        def __str__(self) -> str:
        def __repr__(self) -> str:
        def __hash__(self) -> int:
        def __eq__(self, other: Any) -> bool:
        def evaluate(self, environment: dict[str, str] | None = None) -> bool:
    def _repair_python_full_version(env: dict[str, str]) -> dict[str, str]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: metadata.py
    from __future__ import annotations
    import email.feedparser
    import email.header
    import email.message
    import email.parser
    import email.policy
    import pathlib
    import sys
    import typing
    from typing import (
    from . import licenses, requirements, specifiers, utils
    from . import version as version_module
    from .licenses import NormalizedLicenseExpression
    T = typing.TypeVar("T")
        class ExceptionGroup(Exception):
            def __init__(self, message: str, exceptions: list[Exception]) -> None:
            def __repr__(self) -> str:
    class InvalidMetadata(ValueError):
        def __init__(self, field: str, message: str) -> None:
    class RawMetadata(TypedDict, total=False):
    _STRING_FIELDS = {
    _LIST_FIELDS = {
    _DICT_FIELDS = {
    def _parse_keywords(data: str) -> list[str]:
    def _parse_project_urls(data: list[str]) -> dict[str, str]:
    def _get_payload(msg: email.message.Message, source: bytes | str) -> str:
    _EMAIL_TO_RAW_MAPPING = {
    _RAW_TO_EMAIL_MAPPING = {raw: email for email, raw in _EMAIL_TO_RAW_MAPPING.items()}
    def parse_email(data: bytes | str) -> tuple[RawMetadata, dict[str, list[str]]]:
    _NOT_FOUND = object()
    _VALID_METADATA_VERSIONS = ["1.0", "1.1", "1.2", "2.1", "2.2", "2.3", "2.4"]
    _REQUIRED_ATTRS = frozenset(["metadata_version", "name", "version"])
    class _Validator(Generic[T]):
        def __init__(
        def __set_name__(self, _owner: Metadata, name: str) -> None:
        def __get__(self, instance: Metadata, _owner: type[Metadata]) -> T:
        def _invalid_metadata(
        def _process_metadata_version(self, value: str) -> _MetadataVersion:
        def _process_name(self, value: str) -> str:
        def _process_version(self, value: str) -> version_module.Version:
        def _process_summary(self, value: str) -> str:
        def _process_description_content_type(self, value: str) -> str:
        def _process_dynamic(self, value: list[str]) -> list[str]:
        def _process_provides_extra(
        def _process_requires_python(self, value: str) -> specifiers.SpecifierSet:
        def _process_requires_dist(
        def _process_license_expression(
        def _process_license_files(self, value: list[str]) -> list[str]:
    class Metadata:
        @classmethod
        def from_raw(cls, data: RawMetadata, *, validate: bool = True) -> Metadata:
        @classmethod
        def from_email(cls, data: bytes | str, *, validate: bool = True) -> Metadata:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: requirements.py
    from __future__ import annotations
    from typing import Any, Iterator
    from ._parser import parse_requirement as _parse_requirement
    from ._tokenizer import ParserSyntaxError
    from .markers import Marker, _normalize_extra_values
    from .specifiers import SpecifierSet
    from .utils import canonicalize_name
    class InvalidRequirement(ValueError):
    class Requirement:
        def __init__(self, requirement_string: str) -> None:
        def _iter_parts(self, name: str) -> Iterator[str]:
        def __str__(self) -> str:
        def __repr__(self) -> str:
        def __hash__(self) -> int:
        def __eq__(self, other: Any) -> bool:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: specifiers.py
        from pip._vendor.packaging.specifiers import Specifier, SpecifierSet, InvalidSpecifier
        from pip._vendor.packaging.version import Version
    from __future__ import annotations
    import abc
    import itertools
    import re
    from typing import Callable, Iterable, Iterator, TypeVar, Union
    from .utils import canonicalize_version
    from .version import Version
    def _coerce_version(version: UnparsedVersion) -> Version:
    class InvalidSpecifier(ValueError):
    class BaseSpecifier(metaclass=abc.ABCMeta):
        @abc.abstractmethod
        def __str__(self) -> str:
        @abc.abstractmethod
        def __hash__(self) -> int:
        @abc.abstractmethod
        def __eq__(self, other: object) -> bool:
        @property
        @abc.abstractmethod
        def prereleases(self) -> bool | None:
        @prereleases.setter
        def prereleases(self, value: bool) -> None:
        @abc.abstractmethod
        def contains(self, item: str, prereleases: bool | None = None) -> bool:
        @abc.abstractmethod
        def filter(
    class Specifier(BaseSpecifier):
        def __init__(self, spec: str = "", prereleases: bool | None = None) -> None:
        @property  # type: ignore[override]
        def prereleases(self) -> bool:
        @prereleases.setter
        def prereleases(self, value: bool) -> None:
        @property
        def operator(self) -> str:
        @property
        def version(self) -> str:
        def __repr__(self) -> str:
        def __str__(self) -> str:
        @property
        def _canonical_spec(self) -> tuple[str, str]:
        def __hash__(self) -> int:
        def __eq__(self, other: object) -> bool:
        def _get_operator(self, op: str) -> CallableOperator:
        def _compare_compatible(self, prospective: Version, spec: str) -> bool:
        def _compare_equal(self, prospective: Version, spec: str) -> bool:
        def _compare_not_equal(self, prospective: Version, spec: str) -> bool:
        def _compare_less_than_equal(self, prospective: Version, spec: str) -> bool:
        def _compare_greater_than_equal(self, prospective: Version, spec: str) -> bool:
        def _compare_less_than(self, prospective: Version, spec_str: str) -> bool:
        def _compare_greater_than(self, prospective: Version, spec_str: str) -> bool:
        def _compare_arbitrary(self, prospective: Version, spec: str) -> bool:
        def __contains__(self, item: str | Version) -> bool:
        def contains(self, item: UnparsedVersion, prereleases: bool | None = None) -> bool:
        def filter(
    def _version_split(version: str) -> list[str]:
    def _version_join(components: list[str]) -> str:
    def _is_not_suffix(segment: str) -> bool:
    def _pad_version(left: list[str], right: list[str]) -> tuple[list[str], list[str]]:
    class SpecifierSet(BaseSpecifier):
        def __init__(
        @property
        def prereleases(self) -> bool | None:
        @prereleases.setter
        def prereleases(self, value: bool) -> None:
        def __repr__(self) -> str:
        def __str__(self) -> str:
        def __hash__(self) -> int:
        def __and__(self, other: SpecifierSet | str) -> SpecifierSet:
        def __eq__(self, other: object) -> bool:
        def __len__(self) -> int:
        def __iter__(self) -> Iterator[Specifier]:
        def __contains__(self, item: UnparsedVersion) -> bool:
        def contains(
        def filter(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: tags.py
    from __future__ import annotations
    import logging
    import platform
    import re
    import struct
    import subprocess
    import sys
    import sysconfig
    from importlib.machinery import EXTENSION_SUFFIXES
    from typing import (
    from . import _manylinux, _musllinux
    class Tag:
        def __init__(self, interpreter: str, abi: str, platform: str) -> None:
        @property
        def interpreter(self) -> str:
        @property
        def abi(self) -> str:
        @property
        def platform(self) -> str:
        def __eq__(self, other: object) -> bool:
        def __hash__(self) -> int:
        def __str__(self) -> str:
        def __repr__(self) -> str:
    def parse_tag(tag: str) -> frozenset[Tag]:
    def _get_config_var(name: str, warn: bool = False) -> int | str | None:
    def _normalize_string(string: str) -> str:
    def _is_threaded_cpython(abis: list[str]) -> bool:
    def _abi3_applies(python_version: PythonVersion, threading: bool) -> bool:
    def _cpython_abis(py_version: PythonVersion, warn: bool = False) -> list[str]:
    def cpython_tags(
    def _generic_abi() -> list[str]:
    def generic_tags(
    def _py_interpreter_range(py_version: PythonVersion) -> Iterator[str]:
    def compatible_tags(
    def _mac_arch(arch: str, is_32bit: bool = _32_BIT_INTERPRETER) -> str:
    def _mac_binary_formats(version: AppleVersion, cpu_arch: str) -> list[str]:
    def mac_platforms(
    def ios_platforms(
    def _linux_platforms(is_32bit: bool = _32_BIT_INTERPRETER) -> Iterator[str]:
    def _generic_platforms() -> Iterator[str]:
    def platform_tags() -> Iterator[str]:
    def interpreter_name() -> str:
    def interpreter_version(*, warn: bool = False) -> str:
    def _version_nodot(version: PythonVersion) -> str:
    def sys_tags(*, warn: bool = False) -> Iterator[Tag]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: utils.py
    from __future__ import annotations
    import functools
    import re
    from typing import NewType, Tuple, Union, cast
    from .tags import Tag, parse_tag
    from .version import InvalidVersion, Version, _TrimmedRelease
    class InvalidName(ValueError):
    class InvalidWheelFilename(ValueError):
    class InvalidSdistFilename(ValueError):
    def canonicalize_name(name: str, *, validate: bool = False) -> NormalizedName:
    def is_normalized_name(name: str) -> bool:
    @functools.singledispatch
    def canonicalize_version(
    @canonicalize_version.register
    def _(version: str, *, strip_trailing_zero: bool = True) -> str:
    def parse_wheel_filename(
    def parse_sdist_filename(filename: str) -> tuple[NormalizedName, Version]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: version.py
        from pip._vendor.packaging.version import parse, Version
    from __future__ import annotations
    import itertools
    import re
    from typing import Any, Callable, NamedTuple, SupportsInt, Tuple, Union
    from ._structures import Infinity, InfinityType, NegativeInfinity, NegativeInfinityType
    class _Version(NamedTuple):
    def parse(version: str) -> Version:
    class InvalidVersion(ValueError):
    class _BaseVersion:
        def __hash__(self) -> int:
        def __lt__(self, other: _BaseVersion) -> bool:
        def __le__(self, other: _BaseVersion) -> bool:
        def __eq__(self, other: object) -> bool:
        def __ge__(self, other: _BaseVersion) -> bool:
        def __gt__(self, other: _BaseVersion) -> bool:
        def __ne__(self, other: object) -> bool:
    _VERSION_PATTERN = r"""
    VERSION_PATTERN = _VERSION_PATTERN
    class Version(_BaseVersion):
        def __init__(self, version: str) -> None:
        def __repr__(self) -> str:
        def __str__(self) -> str:
        @property
        def epoch(self) -> int:
        @property
        def release(self) -> tuple[int, ...]:
        @property
        def pre(self) -> tuple[str, int] | None:
        @property
        def post(self) -> int | None:
        @property
        def dev(self) -> int | None:
        @property
        def local(self) -> str | None:
        @property
        def public(self) -> str:
        @property
        def base_version(self) -> str:
        @property
        def is_prerelease(self) -> bool:
        @property
        def is_postrelease(self) -> bool:
        @property
        def is_devrelease(self) -> bool:
        @property
        def major(self) -> int:
        @property
        def minor(self) -> int:
        @property
        def micro(self) -> int:
    class _TrimmedRelease(Version):
        @property
        def release(self) -> tuple[int, ...]:
    def _parse_letter_version(
    def _parse_local_version(local: str | None) -> LocalType | None:
    def _cmpkey(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _elffile.py
    from __future__ import annotations
    import enum
    import os
    import struct
    from typing import IO
    class ELFInvalid(ValueError):
    class EIClass(enum.IntEnum):
    class EIData(enum.IntEnum):
    class EMachine(enum.IntEnum):
    class ELFFile:
        def __init__(self, f: IO[bytes]) -> None:
        def _read(self, fmt: str) -> tuple[int, ...]:
        @property
        def interpreter(self) -> str | None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _manylinux.py
    from __future__ import annotations
    import collections
    import contextlib
    import functools
    import os
    import re
    import sys
    import warnings
    from typing import Generator, Iterator, NamedTuple, Sequence
    from ._elffile import EIClass, EIData, ELFFile, EMachine
    EF_ARM_ABIMASK = 0xFF000000
    EF_ARM_ABI_FLOAT_HARD = 0x00000400
    @contextlib.contextmanager
    def _parse_elf(path: str) -> Generator[ELFFile | None, None, None]:
    def _is_linux_armhf(executable: str) -> bool:
    def _is_linux_i686(executable: str) -> bool:
    def _have_compatible_abi(executable: str, archs: Sequence[str]) -> bool:
    class _GLibCVersion(NamedTuple):
    def _glibc_version_string_confstr() -> str | None:
    def _glibc_version_string_ctypes() -> str | None:
            import ctypes
    def _glibc_version_string() -> str | None:
    def _parse_glibc_version(version_str: str) -> tuple[int, int]:
    @functools.lru_cache
    def _get_glibc_version() -> tuple[int, int]:
    def _is_compatible(arch: str, version: _GLibCVersion) -> bool:
            import _manylinux
    _LEGACY_MANYLINUX_MAP = {
    def platform_tags(archs: Sequence[str]) -> Iterator[str]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _musllinux.py
    from __future__ import annotations
    import functools
    import re
    import subprocess
    import sys
    from typing import Iterator, NamedTuple, Sequence
    from ._elffile import ELFFile
    class _MuslVersion(NamedTuple):
    def _parse_musl_version(output: str) -> _MuslVersion | None:
    @functools.lru_cache
    def _get_musl_version(executable: str) -> _MuslVersion | None:
    def platform_tags(archs: Sequence[str]) -> Iterator[str]:
        import sysconfig

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _parser.py
    from __future__ import annotations
    import ast
    from typing import NamedTuple, Sequence, Tuple, Union
    from ._tokenizer import DEFAULT_RULES, Tokenizer
    class Node:
        def __init__(self, value: str) -> None:
        def __str__(self) -> str:
        def __repr__(self) -> str:
        def serialize(self) -> str:
    class Variable(Node):
        def serialize(self) -> str:
    class Value(Node):
        def serialize(self) -> str:
    class Op(Node):
        def serialize(self) -> str:
    class ParsedRequirement(NamedTuple):
    def parse_requirement(source: str) -> ParsedRequirement:
    def _parse_requirement(tokenizer: Tokenizer) -> ParsedRequirement:
    def _parse_requirement_details(
    def _parse_requirement_marker(
    def _parse_extras(tokenizer: Tokenizer) -> list[str]:
    def _parse_extras_list(tokenizer: Tokenizer) -> list[str]:
    def _parse_specifier(tokenizer: Tokenizer) -> str:
    def _parse_version_many(tokenizer: Tokenizer) -> str:
    def parse_marker(source: str) -> MarkerList:
    def _parse_full_marker(tokenizer: Tokenizer) -> MarkerList:
    def _parse_marker(tokenizer: Tokenizer) -> MarkerList:
    def _parse_marker_atom(tokenizer: Tokenizer) -> MarkerAtom:
    def _parse_marker_item(tokenizer: Tokenizer) -> MarkerItem:
    def _parse_marker_var(tokenizer: Tokenizer) -> MarkerVar:
    def process_env_var(env_var: str) -> Variable:
    def process_python_str(python_str: str) -> Value:
    def _parse_marker_op(tokenizer: Tokenizer) -> Op:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _structures.py
    class InfinityType:
        def __repr__(self) -> str:
        def __hash__(self) -> int:
        def __lt__(self, other: object) -> bool:
        def __le__(self, other: object) -> bool:
        def __eq__(self, other: object) -> bool:
        def __gt__(self, other: object) -> bool:
        def __ge__(self, other: object) -> bool:
        def __neg__(self: object) -> "NegativeInfinityType":
    class NegativeInfinityType:
        def __repr__(self) -> str:
        def __hash__(self) -> int:
        def __lt__(self, other: object) -> bool:
        def __le__(self, other: object) -> bool:
        def __eq__(self, other: object) -> bool:
        def __gt__(self, other: object) -> bool:
        def __ge__(self, other: object) -> bool:
        def __neg__(self: object) -> InfinityType:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _tokenizer.py
    from __future__ import annotations
    import contextlib
    import re
    from dataclasses import dataclass
    from typing import Iterator, NoReturn
    from .specifiers import Specifier
    @dataclass
    class Token:
    class ParserSyntaxError(Exception):
        def __init__(
        def __str__(self) -> str:
    class Tokenizer:
        def __init__(
        def consume(self, name: str) -> None:
        def check(self, name: str, *, peek: bool = False) -> bool:
        def expect(self, name: str, *, expected: str) -> Token:
        def read(self) -> Token:
        def raise_syntax_error(
        @contextlib.contextmanager
        def enclosing_tokens(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\packaging\licenses

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _spdx.py
    from __future__ import annotations
    from typing import TypedDict
    class SPDXLicense(TypedDict):
    class SPDXException(TypedDict):
    VERSION = '3.25.0'

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from __future__ import annotations
    import re
    from typing import NewType, cast
    from pip._vendor.packaging.licenses._spdx import EXCEPTIONS, LICENSES
    class InvalidLicenseExpression(ValueError):
    def canonicalize_license_expression(

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\pkg_resources

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from __future__ import annotations
    import sys
    import os
    import io
    import time
    import re
    import types
    from typing import (
    import zipfile
    import zipimport
    import warnings
    import stat
    import functools
    import pkgutil
    import operator
    import platform
    import collections
    import plistlib
    import email.parser
    import errno
    import tempfile
    import textwrap
    import inspect
    import ntpath
    import posixpath
    import importlib
    import importlib.abc
    import importlib.machinery
    from pkgutil import get_importer
    import _imp
    from os import utime
    from os import open as os_open
    from os.path import isdir, split
        from os import mkdir, rename, unlink
        WRITE_SUPPORT = True
        WRITE_SUPPORT = False
    from pip._internal.utils._jaraco_text import (
    from pip._vendor.packaging import markers as _packaging_markers
    from pip._vendor.packaging import requirements as _packaging_requirements
    from pip._vendor.packaging import utils as _packaging_utils
    from pip._vendor.packaging import version as _packaging_version
    from pip._vendor.platformdirs import user_cache_dir as _user_cache_dir
        from _typeshed import BytesPath, StrPath, StrOrBytesPath
        from pip._vendor.typing_extensions import Self
    _T = TypeVar("_T")
    class _LoaderProtocol(Protocol):
        def load_module(self, fullname: str, /) -> types.ModuleType: ...
    class _ZipLoaderModule(Protocol):
    class PEP440Warning(RuntimeWarning):
    def _declare_state(vartype: str, varname: str, initial_value: _T) -> _T:
    def __getstate__() -> dict[str, Any]:
    def __setstate__(state: dict[str, Any]) -> dict[str, Any]:
    def _sget_dict(val):
    def _sset_dict(key, ob, state):
    def _sget_object(val):
    def _sset_object(key, ob, state):
    def get_supported_platform():
    class ResolutionError(Exception):
        def __repr__(self):
    class VersionConflict(ResolutionError):
        @property
        def dist(self) -> Distribution:
        @property
        def req(self) -> Requirement:
        def report(self):
        def with_context(self, required_by: set[Distribution | str]):
    class ContextualVersionConflict(VersionConflict):
        @property
        def required_by(self) -> set[str]:
    class DistributionNotFound(ResolutionError):
        @property
        def req(self) -> Requirement:
        @property
        def requirers(self) -> set[str] | None:
        @property
        def requirers_str(self):
        def report(self):
        def __str__(self):
    class UnknownExtra(ResolutionError):
    PY_MAJOR = '{}.{}'.format(*sys.version_info)
    EGG_DIST = 3
    BINARY_DIST = 2
    SOURCE_DIST = 1
    CHECKOUT_DIST = 0
    DEVELOP_DIST = -1
    def register_loader_type(
    @overload
    def get_provider(moduleOrReq: str) -> IResourceProvider: ...
    @overload
    def get_provider(moduleOrReq: Requirement) -> Distribution: ...
    def get_provider(moduleOrReq: str | Requirement) -> IResourceProvider | Distribution:
    @functools.lru_cache(maxsize=None)
    def _macos_vers():
    def _macos_arch(machine):
    def get_build_platform():
        from sysconfig import get_platform
    def compatible_platforms(provided: str | None, required: str | None):
    @overload
    def get_distribution(dist: _DistributionT) -> _DistributionT: ...
    @overload
    def get_distribution(dist: _PkgReqType) -> Distribution: ...
    def get_distribution(dist: Distribution | _PkgReqType) -> Distribution:
    def load_entry_point(dist: _EPDistType, group: str, name: str) -> _ResolvedEntryPoint:
    @overload
    def get_entry_map(
    @overload
    def get_entry_map(dist: _EPDistType, group: str) -> dict[str, EntryPoint]: ...
    def get_entry_map(dist: _EPDistType, group: str | None = None):
    def get_entry_info(dist: _EPDistType, group: str, name: str):
    class IMetadataProvider(Protocol):
        def has_metadata(self, name: str) -> bool:
        def get_metadata(self, name: str) -> str:
        def get_metadata_lines(self, name: str) -> Iterator[str]:
        def metadata_isdir(self, name: str) -> bool:
        def metadata_listdir(self, name: str) -> list[str]:
        def run_script(self, script_name: str, namespace: dict[str, Any]) -> None:
    class IResourceProvider(IMetadataProvider, Protocol):
        def get_resource_filename(
        def get_resource_stream(
        def get_resource_string(
        def has_resource(self, resource_name: str) -> bool:
        def resource_isdir(self, resource_name: str) -> bool:
        def resource_listdir(self, resource_name: str) -> list[str]:
    class WorkingSet:
        def __init__(self, entries: Iterable[str] | None = None):
        @classmethod
        def _build_master(cls):
                from __main__ import __requires__
        @classmethod
        def _build_from_requirements(cls, req_spec):
        def add_entry(self, entry: str):
        def __contains__(self, dist: Distribution) -> bool:
        def find(self, req: Requirement) -> Distribution | None:
        def iter_entry_points(self, group: str, name: str | None = None):
        def run_script(self, requires: str, script_name: str):
        def __iter__(self) -> Iterator[Distribution]:
        def add(
        @overload
        def resolve(
        @overload
        def resolve(
        @overload
        def resolve(
        def resolve(
        def _resolve_dist(
        @overload
        def find_plugins(
        @overload
        def find_plugins(
        @overload
        def find_plugins(
        def find_plugins(
        def require(self, *requirements: _NestedStr):
        def subscribe(
        def _added_new(self, dist):
        def __getstate__(self):
        def __setstate__(self, e_k_b_n_c):
    class _ReqExtras(Dict["Requirement", Tuple[str, ...]]):
        def markers_pass(self, req: Requirement, extras: tuple[str, ...] | None = None):
    class Environment:
        def __init__(
        def can_add(self, dist: Distribution):
        def remove(self, dist: Distribution):
        def scan(self, search_path: Iterable[str] | None = None):
        def __getitem__(self, project_name: str) -> list[Distribution]:
        def add(self, dist: Distribution):
        @overload
        def best_match(
        @overload
        def best_match(
        def best_match(
        @overload
        def obtain(
        @overload
        def obtain(
        @overload
        def obtain(
        def obtain(
        def __iter__(self) -> Iterator[str]:
        def __iadd__(self, other: Distribution | Environment):
        def __add__(self, other: Distribution | Environment):
    class ExtractionError(RuntimeError):
    class ResourceManager:
        def __init__(self):
        def resource_exists(self, package_or_requirement: _PkgReqType, resource_name: str):
        def resource_isdir(self, package_or_requirement: _PkgReqType, resource_name: str):
        def resource_filename(
        def resource_stream(self, package_or_requirement: _PkgReqType, resource_name: str):
        def resource_string(
        def resource_listdir(self, package_or_requirement: _PkgReqType, resource_name: str):
        def extraction_error(self) -> NoReturn:
        def get_cache_path(self, archive_name: str, names: Iterable[StrPath] = ()):
        @staticmethod
        def _warn_unsafe_extraction_path(path):
        def postprocess(self, tempname: StrOrBytesPath, filename: StrOrBytesPath):
        def set_extraction_path(self, path: str):
        def cleanup_resources(self, force: bool = False) -> list[str]:
    def get_default_cache() -> str:
    def safe_name(name: str):
    def safe_version(version: str):
    def _forgiving_version(version):
    def _safe_segment(segment):
    def safe_extra(extra: str):
    def to_filename(name: str):
    def invalid_marker(text: str):
    def evaluate_marker(text: str, extra: str | None = None) -> bool:
    class NullProvider:
        def __init__(self, module: _ModuleLike):
        def get_resource_filename(self, manager: ResourceManager, resource_name: str):
        def get_resource_stream(self, manager: ResourceManager, resource_name: str):
        def get_resource_string(
        def has_resource(self, resource_name: str):
        def _get_metadata_path(self, name):
        def has_metadata(self, name: str) -> bool:
        def get_metadata(self, name: str):
        def get_metadata_lines(self, name: str) -> Iterator[str]:
        def resource_isdir(self, resource_name: str):
        def metadata_isdir(self, name: str) -> bool:
        def resource_listdir(self, resource_name: str):
        def metadata_listdir(self, name: str) -> list[str]:
        def run_script(self, script_name: str, namespace: dict[str, Any]):
                from linecache import cache
        def _has(self, path) -> bool:
        def _isdir(self, path) -> bool:
        def _listdir(self, path) -> list[str]:
        def _fn(self, base: str | None, resource_name: str):
        @staticmethod
        def _validate_resource_path(path):
        def _get(self, path) -> bytes:
    def _parents(path):
    class EggProvider(NullProvider):
        def __init__(self, module: _ModuleLike):
        def _setup_prefix(self):
        def _set_egg(self, path: str):
    class DefaultProvider(EggProvider):
        def _has(self, path) -> bool:
        def _isdir(self, path) -> bool:
        def _listdir(self, path):
        def get_resource_stream(self, manager: object, resource_name: str):
        def _get(self, path) -> bytes:
        @classmethod
        def _register(cls):
    class EmptyProvider(NullProvider):
        def _get(self, path) -> bytes:
        def _listdir(self, path):
        def __init__(self):
    class ZipManifests(Dict[str, "MemoizedZipManifests.manifest_mod"]):
        @classmethod
        def build(cls, path: str):
    class MemoizedZipManifests(ZipManifests):
        class manifest_mod(NamedTuple):
        def load(self, path: str) -> dict[str, zipfile.ZipInfo]:  # type: ignore[override] # ZipManifests.load is a classmethod
    class ZipProvider(EggProvider):
        def __init__(self, module: _ZipLoaderModule):
        def _zipinfo_name(self, fspath):
        def _parts(self, zip_path):
        @property
        def zipinfo(self):
        def get_resource_filename(self, manager: ResourceManager, resource_name: str):
        @staticmethod
        def _get_date_and_size(zip_stat):
        def _extract_resource(self, manager: ResourceManager, zip_path) -> str:  # noqa: C901
        def _is_current(self, file_path, zip_path):
        def _get_eager_resources(self):
        def _index(self):
        def _has(self, fspath) -> bool:
        def _isdir(self, fspath) -> bool:
        def _listdir(self, fspath):
        def _eager_to_zip(self, resource_name: str):
        def _resource_to_zip(self, resource_name: str):
    class FileMetadata(EmptyProvider):
        def __init__(self, path: StrPath):
        def _get_metadata_path(self, name):
        def has_metadata(self, name: str) -> bool:
        def get_metadata(self, name: str):
        def _warn_on_replacement(self, metadata):
        def get_metadata_lines(self, name: str) -> Iterator[str]:
    class PathMetadata(DefaultProvider):
        def __init__(self, path: str, egg_info: str):
    class EggMetadata(ZipProvider):
        def __init__(self, importer: zipimport.zipimporter):
    def register_finder(importer_type: type[_T], distribution_finder: _DistFinderType[_T]):
    def find_distributions(path_item: str, only: bool = False):
    def find_eggs_in_zip(
    def find_nothing(
    def find_on_path(importer: object | None, path_item, only=False):
    def dist_factory(path_item, entry, only):
    class NoDists:
        def __bool__(self):
        def __call__(self, fullpath):
    def safe_listdir(path: StrOrBytesPath):
    def distributions_from_metadata(path: str):
    def non_empty_lines(path):
    def resolve_egg_link(path):
    def register_namespace_handler(
            def namespace_handler(importer, path_entry, moduleName, module):
    def _handle_ns(packageName, path_item):
    def _rebuild_mod_path(orig_path, package_name, module: types.ModuleType):
        def safe_sys_path_index(entry):
        def position_in_sys_path(path):
    def declare_namespace(packageName: str):
    def fixup_namespace_packages(path_item: str, parent: str | None = None):
    def file_ns_handler(
    def null_ns_handler(
    @overload
    def normalize_path(filename: StrPath) -> str: ...
    @overload
    def normalize_path(filename: BytesPath) -> bytes: ...
    def normalize_path(filename: StrOrBytesPath):
    def _cygwin_patch(filename: StrOrBytesPath):  # pragma: nocover
        @overload
        def _normalize_cached(filename: StrPath) -> str: ...
        @overload
        def _normalize_cached(filename: BytesPath) -> bytes: ...
        def _normalize_cached(filename: StrOrBytesPath) -> str | bytes: ...
        @functools.lru_cache(maxsize=None)
        def _normalize_cached(filename):
    def _is_egg_path(path):
    def _is_zip_egg(path):
    def _is_unpacked_egg(path):
    def _set_parent_ns(packageName):
    MODULE = re.compile(r"\w+(\.\w+)*$").match
    EGG_NAME = re.compile(
    class EntryPoint:
        def __init__(
        def __str__(self):
        def __repr__(self):
        @overload
        def load(
        @overload
        def load(
        def load(
        def resolve(self) -> _ResolvedEntryPoint:
        def require(
        @classmethod
        def parse(cls, src: str, dist: Distribution | None = None):
        @classmethod
        def _parse_extras(cls, extras_spec):
        @classmethod
        def parse_group(
        @classmethod
        def parse_map(
    def _version_from_file(lines):
        def is_version_line(line):
    class Distribution:
        PKG_INFO = 'PKG-INFO'
        def __init__(
        @classmethod
        def from_location(
        def _reload_version(self):
        @property
        def hashcmp(self):
        def __hash__(self):
        def __lt__(self, other: Distribution):
        def __le__(self, other: Distribution):
        def __gt__(self, other: Distribution):
        def __ge__(self, other: Distribution):
        def __eq__(self, other: object):
        def __ne__(self, other: object):
        @property
        def key(self):
        @property
        def parsed_version(self):
        @property
        def _forgiving_parsed_version(self):
        @property
        def version(self):
        @property
        def _dep_map(self):
        @staticmethod
        def _filter_extras(dm: dict[str | None, list[Requirement]]):
        def _build_dep_map(self):
        def requires(self, extras: Iterable[str] = ()):
        def _get_metadata_path_for_display(self, name):
        def _get_metadata(self, name):
        def _get_version(self):
        def activate(self, path: list[str] | None = None, replace: bool = False):
        def egg_name(self):
        def __repr__(self):
        def __str__(self):
        def __getattr__(self, attr):
        def __dir__(self):
        @classmethod
        def from_filename(
        def as_requirement(self):
        def load_entry_point(self, group: str, name: str) -> _ResolvedEntryPoint:
        @overload
        def get_entry_map(self, group: None = None) -> dict[str, dict[str, EntryPoint]]: ...
        @overload
        def get_entry_map(self, group: str) -> dict[str, EntryPoint]: ...
        def get_entry_map(self, group: str | None = None):
        def get_entry_info(self, group: str, name: str):
        def insert_on(  # noqa: C901
        def check_version_conflict(self):
        def has_version(self):
        def clone(self, **kw: str | int | IResourceProvider | None):
        @property
        def extras(self):
    class EggInfoDistribution(Distribution):
        def _reload_version(self):
    class DistInfoDistribution(Distribution):
        PKG_INFO = 'METADATA'
        EQEQ = re.compile(r"([\(,])\s*(\d.*?)\s*([,\)])")
        @property
        def _parsed_pkg_info(self):
        @property
        def _dep_map(self):
        def _compute_dependencies(self) -> dict[str | None, list[Requirement]]:
            def reqs_for_extra(extra):
    def issue_warning(*args, **kw):
    def parse_requirements(strs: _NestedStr):
    class RequirementParseError(_packaging_requirements.InvalidRequirement):
    class Requirement(_packaging_requirements.Requirement):
        def __init__(self, requirement_string: str):
        def __eq__(self, other: object):
        def __ne__(self, other):
        def __contains__(self, item: Distribution | str | tuple[str, ...]) -> bool:
        def __hash__(self):
        def __repr__(self):
        @staticmethod
        def parse(s: str | Iterable[str]):
    def _always_object(classes):
    def _find_adapter(registry: Mapping[type, _AdapterT], ob: object) -> _AdapterT:
    def ensure_directory(path: StrOrBytesPath):
    def _bypass_ensure_directory(path):
    def split_sections(s: _NestedStr) -> Iterator[tuple[str | None, list[str]]]:
    def _mkstemp(*args, **kw):
    class PkgResourcesDeprecationWarning(Warning):
    _LOCALE_ENCODING = "locale" if sys.version_info >= (3, 10) else None
    def _read_utf8_with_fallback(file: str, fallback_encoding=_LOCALE_ENCODING) -> str:
    def _call_aside(f, *args, **kwargs):
    @_call_aside
    def _initialize(g=globals()):
    @_call_aside
    def _initialize_master_working_set():

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\platformdirs

  ðŸ“„ Ð¤Ð°Ð¹Ð»: android.py
    from __future__ import annotations
    import os
    import re
    import sys
    from functools import lru_cache
    from typing import TYPE_CHECKING, cast
    from .api import PlatformDirsABC
    class Android(PlatformDirsABC):
        @property
        def user_data_dir(self) -> str:
        @property
        def site_data_dir(self) -> str:
        @property
        def user_config_dir(self) -> str:
        @property
        def site_config_dir(self) -> str:
        @property
        def user_cache_dir(self) -> str:
        @property
        def site_cache_dir(self) -> str:
        @property
        def user_state_dir(self) -> str:
        @property
        def user_log_dir(self) -> str:
        @property
        def user_documents_dir(self) -> str:
        @property
        def user_downloads_dir(self) -> str:
        @property
        def user_pictures_dir(self) -> str:
        @property
        def user_videos_dir(self) -> str:
        @property
        def user_music_dir(self) -> str:
        @property
        def user_desktop_dir(self) -> str:
        @property
        def user_runtime_dir(self) -> str:
        @property
        def site_runtime_dir(self) -> str:
    @lru_cache(maxsize=1)
    def _android_folder() -> str | None:  # noqa: C901
                from android import mActivity  # noqa: PLC0415
                from jnius import autoclass  # noqa: PLC0415
    @lru_cache(maxsize=1)
    def _android_documents_folder() -> str:
            from jnius import autoclass  # noqa: PLC0415
    @lru_cache(maxsize=1)
    def _android_downloads_folder() -> str:
            from jnius import autoclass  # noqa: PLC0415
    @lru_cache(maxsize=1)
    def _android_pictures_folder() -> str:
            from jnius import autoclass  # noqa: PLC0415
    @lru_cache(maxsize=1)
    def _android_videos_folder() -> str:
            from jnius import autoclass  # noqa: PLC0415
    @lru_cache(maxsize=1)
    def _android_music_folder() -> str:
            from jnius import autoclass  # noqa: PLC0415

  ðŸ“„ Ð¤Ð°Ð¹Ð»: api.py
    from __future__ import annotations
    import os
    from abc import ABC, abstractmethod
    from pathlib import Path
    from typing import TYPE_CHECKING
        from typing import Iterator, Literal
    class PlatformDirsABC(ABC):  # noqa: PLR0904
        def __init__(  # noqa: PLR0913, PLR0917
        def _append_app_name_and_version(self, *base: str) -> str:
        def _optionally_create_directory(self, path: str) -> None:
        def _first_item_as_path_if_multipath(self, directory: str) -> Path:
        @property
        @abstractmethod
        def user_data_dir(self) -> str:
        @property
        @abstractmethod
        def site_data_dir(self) -> str:
        @property
        @abstractmethod
        def user_config_dir(self) -> str:
        @property
        @abstractmethod
        def site_config_dir(self) -> str:
        @property
        @abstractmethod
        def user_cache_dir(self) -> str:
        @property
        @abstractmethod
        def site_cache_dir(self) -> str:
        @property
        @abstractmethod
        def user_state_dir(self) -> str:
        @property
        @abstractmethod
        def user_log_dir(self) -> str:
        @property
        @abstractmethod
        def user_documents_dir(self) -> str:
        @property
        @abstractmethod
        def user_downloads_dir(self) -> str:
        @property
        @abstractmethod
        def user_pictures_dir(self) -> str:
        @property
        @abstractmethod
        def user_videos_dir(self) -> str:
        @property
        @abstractmethod
        def user_music_dir(self) -> str:
        @property
        @abstractmethod
        def user_desktop_dir(self) -> str:
        @property
        @abstractmethod
        def user_runtime_dir(self) -> str:
        @property
        @abstractmethod
        def site_runtime_dir(self) -> str:
        @property
        def user_data_path(self) -> Path:
        @property
        def site_data_path(self) -> Path:
        @property
        def user_config_path(self) -> Path:
        @property
        def site_config_path(self) -> Path:
        @property
        def user_cache_path(self) -> Path:
        @property
        def site_cache_path(self) -> Path:
        @property
        def user_state_path(self) -> Path:
        @property
        def user_log_path(self) -> Path:
        @property
        def user_documents_path(self) -> Path:
        @property
        def user_downloads_path(self) -> Path:
        @property
        def user_pictures_path(self) -> Path:
        @property
        def user_videos_path(self) -> Path:
        @property
        def user_music_path(self) -> Path:
        @property
        def user_desktop_path(self) -> Path:
        @property
        def user_runtime_path(self) -> Path:
        @property
        def site_runtime_path(self) -> Path:
        def iter_config_dirs(self) -> Iterator[str]:
        def iter_data_dirs(self) -> Iterator[str]:
        def iter_cache_dirs(self) -> Iterator[str]:
        def iter_runtime_dirs(self) -> Iterator[str]:
        def iter_config_paths(self) -> Iterator[Path]:
        def iter_data_paths(self) -> Iterator[Path]:
        def iter_cache_paths(self) -> Iterator[Path]:
        def iter_runtime_paths(self) -> Iterator[Path]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: macos.py
    from __future__ import annotations
    import os.path
    import sys
    from typing import TYPE_CHECKING
    from .api import PlatformDirsABC
        from pathlib import Path
    class MacOS(PlatformDirsABC):
        @property
        def user_data_dir(self) -> str:
        @property
        def site_data_dir(self) -> str:
        @property
        def site_data_path(self) -> Path:
        @property
        def user_config_dir(self) -> str:
        @property
        def site_config_dir(self) -> str:
        @property
        def user_cache_dir(self) -> str:
        @property
        def site_cache_dir(self) -> str:
        @property
        def site_cache_path(self) -> Path:
        @property
        def user_state_dir(self) -> str:
        @property
        def user_log_dir(self) -> str:
        @property
        def user_documents_dir(self) -> str:
        @property
        def user_downloads_dir(self) -> str:
        @property
        def user_pictures_dir(self) -> str:
        @property
        def user_videos_dir(self) -> str:
        @property
        def user_music_dir(self) -> str:
        @property
        def user_desktop_dir(self) -> str:
        @property
        def user_runtime_dir(self) -> str:
        @property
        def site_runtime_dir(self) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: unix.py
    from __future__ import annotations
    import os
    import sys
    from configparser import ConfigParser
    from pathlib import Path
    from typing import Iterator, NoReturn
    from .api import PlatformDirsABC
        def getuid() -> NoReturn:
        from os import getuid
    class Unix(PlatformDirsABC):  # noqa: PLR0904
        @property
        def user_data_dir(self) -> str:
        @property
        def _site_data_dirs(self) -> list[str]:
        @property
        def site_data_dir(self) -> str:
        @property
        def user_config_dir(self) -> str:
        @property
        def _site_config_dirs(self) -> list[str]:
        @property
        def site_config_dir(self) -> str:
        @property
        def user_cache_dir(self) -> str:
        @property
        def site_cache_dir(self) -> str:
        @property
        def user_state_dir(self) -> str:
        @property
        def user_log_dir(self) -> str:
        @property
        def user_documents_dir(self) -> str:
        @property
        def user_downloads_dir(self) -> str:
        @property
        def user_pictures_dir(self) -> str:
        @property
        def user_videos_dir(self) -> str:
        @property
        def user_music_dir(self) -> str:
        @property
        def user_desktop_dir(self) -> str:
        @property
        def user_runtime_dir(self) -> str:
        @property
        def site_runtime_dir(self) -> str:
        @property
        def site_data_path(self) -> Path:
        @property
        def site_config_path(self) -> Path:
        @property
        def site_cache_path(self) -> Path:
        def iter_config_dirs(self) -> Iterator[str]:
        def iter_data_dirs(self) -> Iterator[str]:
    def _get_user_media_dir(env_var: str, fallback_tilde_path: str) -> str:
    def _get_user_dirs_folder(key: str) -> str | None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: version.py
    TYPE_CHECKING = False
        from typing import Tuple, Union
        VERSION_TUPLE = Tuple[Union[int, str], ...]
        VERSION_TUPLE = object

  ðŸ“„ Ð¤Ð°Ð¹Ð»: windows.py
    from __future__ import annotations
    import os
    import sys
    from functools import lru_cache
    from typing import TYPE_CHECKING
    from .api import PlatformDirsABC
        from collections.abc import Callable
    class Windows(PlatformDirsABC):
        @property
        def user_data_dir(self) -> str:
        def _append_parts(self, path: str, *, opinion_value: str | None = None) -> str:
        @property
        def site_data_dir(self) -> str:
        @property
        def user_config_dir(self) -> str:
        @property
        def site_config_dir(self) -> str:
        @property
        def user_cache_dir(self) -> str:
        @property
        def site_cache_dir(self) -> str:
        @property
        def user_state_dir(self) -> str:
        @property
        def user_log_dir(self) -> str:
        @property
        def user_documents_dir(self) -> str:
        @property
        def user_downloads_dir(self) -> str:
        @property
        def user_pictures_dir(self) -> str:
        @property
        def user_videos_dir(self) -> str:
        @property
        def user_music_dir(self) -> str:
        @property
        def user_desktop_dir(self) -> str:
        @property
        def user_runtime_dir(self) -> str:
        @property
        def site_runtime_dir(self) -> str:
    def get_win_folder_from_env_vars(csidl_name: str) -> str:
    def get_win_folder_if_csidl_name_not_env_var(csidl_name: str) -> str | None:
    def get_win_folder_from_registry(csidl_name: str) -> str:
        import winreg  # noqa: PLC0415
    def get_win_folder_via_ctypes(csidl_name: str) -> str:
        import ctypes  # noqa: PLC0415
    def _pick_get_win_folder() -> Callable[[str], str]:
            import ctypes  # noqa: PLC0415
            import winreg  # noqa: PLC0415, F401

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from __future__ import annotations
    import os
    import sys
    from typing import TYPE_CHECKING
    from .api import PlatformDirsABC
    from .version import __version__
    from .version import __version_tuple__ as __version_info__
        from pathlib import Path
        from typing import Literal
        from pip._vendor.platformdirs.windows import Windows as _Result
        from pip._vendor.platformdirs.macos import MacOS as _Result
        from pip._vendor.platformdirs.unix import Unix as _Result
    def _set_platform_dir_class() -> type[PlatformDirsABC]:
            from pip._vendor.platformdirs.android import _android_folder  # noqa: PLC0415
                from pip._vendor.platformdirs.android import Android  # noqa: PLC0415
    def user_data_dir(
    def site_data_dir(
    def user_config_dir(
    def site_config_dir(
    def user_cache_dir(
    def site_cache_dir(
    def user_state_dir(
    def user_log_dir(
    def user_documents_dir() -> str:
    def user_downloads_dir() -> str:
    def user_pictures_dir() -> str:
    def user_videos_dir() -> str:
    def user_music_dir() -> str:
    def user_desktop_dir() -> str:
    def user_runtime_dir(
    def site_runtime_dir(
    def user_data_path(
    def site_data_path(
    def user_config_path(
    def site_config_path(
    def site_cache_path(
    def user_cache_path(
    def user_state_path(
    def user_log_path(
    def user_documents_path() -> Path:
    def user_downloads_path() -> Path:
    def user_pictures_path() -> Path:
    def user_videos_path() -> Path:
    def user_music_path() -> Path:
    def user_desktop_path() -> Path:
    def user_runtime_path(
    def site_runtime_path(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __main__.py
    from __future__ import annotations
    from pip._vendor.platformdirs import PlatformDirs, __version__
    PROPS = (
    def main() -> None:

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\pygments

  ðŸ“„ Ð¤Ð°Ð¹Ð»: cmdline.py
    import os
    import sys
    import shutil
    import argparse
    from textwrap import dedent
    from pip._vendor.pygments import __version__, highlight
    from pip._vendor.pygments.util import ClassNotFound, OptionError, docstring_headline, \
    from pip._vendor.pygments.lexers import get_all_lexers, get_lexer_by_name, guess_lexer, \
    from pip._vendor.pygments.lexers.special import TextLexer
    from pip._vendor.pygments.formatters.latex import LatexEmbeddedLexer, LatexFormatter
    from pip._vendor.pygments.formatters import get_all_formatters, get_formatter_by_name, \
    from pip._vendor.pygments.formatters.terminal import TerminalFormatter
    from pip._vendor.pygments.formatters.terminal256 import Terminal256Formatter, TerminalTrueColorFormatter
    from pip._vendor.pygments.filters import get_all_filters, find_filter_class
    from pip._vendor.pygments.styles import get_all_styles, get_style_by_name
    def _parse_options(o_strs):
    def _parse_filters(f_strs):
    def _print_help(what, name):
    def _print_list(what):
    def _print_list_as_json(requested_items):
        import json
    def main_inner(parser, argns):
        def is_only_option(opt):
                import colorama.initialise
    class HelpFormatter(argparse.HelpFormatter):
        def __init__(self, prog, indent_increment=2, max_help_position=16, width=None):
    def main(args=sys.argv):
            import traceback

  ðŸ“„ Ð¤Ð°Ð¹Ð»: console.py
    def reset_color():
    def colorize(color_key, text):
    def ansiformat(attr, text):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: filter.py
    def apply_filters(stream, filters, lexer=None):
        def _apply(filter_, stream):
    def simplefilter(f):
            @simplefilter
            def lowercase(self, lexer, stream, options):
    class Filter:
        def __init__(self, **options):
        def filter(self, lexer, stream):
    class FunctionFilter(Filter):
        def __init__(self, **options):
        def filter(self, lexer, stream):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: formatter.py
    import codecs
    from pip._vendor.pygments.util import get_bool_opt
    from pip._vendor.pygments.styles import get_style_by_name
    def _lookup_style(style):
    class Formatter:
        def __init__(self, **options):
        def get_style_defs(self, arg=''):
        def format(self, tokensource, outfile):
        def __class_getitem__(cls, name):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: lexer.py
    import re
    import sys
    import time
    from pip._vendor.pygments.filter import apply_filters, Filter
    from pip._vendor.pygments.filters import get_filter_by_name
    from pip._vendor.pygments.token import Error, Text, Other, Whitespace, _TokenType
    from pip._vendor.pygments.util import get_bool_opt, get_int_opt, get_list_opt, \
    from pip._vendor.pygments.regexopt import regex_opt
    class LexerMeta(type):
        def __new__(mcs, name, bases, d):
    class Lexer(metaclass=LexerMeta):
        def __init__(self, **options):
               def __init__(self, **options):
        def __repr__(self):
        def add_filter(self, filter_, **options):
        def analyse_text(text):
            from ``0.0`` to ``1.0``.  If it returns ``0.0``, the lexer
        def _preprocess_lexer_input(self, text):
        def get_tokens(self, text, unfiltered=False):
            from `get_tokens_unprocessed()`, with the ``index`` dropped.
            def streamer():
        def get_tokens_unprocessed(self, text):
    class DelegatingLexer(Lexer):
        def __init__(self, _root_lexer, _language_lexer, _needle=Other, **options):
        def get_tokens_unprocessed(self, text):
    class include(str):  # pylint: disable=invalid-name
    class _inherit:
        def __repr__(self):
    class combined(tuple):  # pylint: disable=invalid-name
        def __new__(cls, *args):
        def __init__(self, *args):
    class _PseudoMatch:
        def __init__(self, start, text):
        def start(self, arg=None):
        def end(self, arg=None):
        def group(self, arg=None):
        def groups(self):
        def groupdict(self):
    def bygroups(*args):
        def callback(lexer, match, ctx=None):
    class _This:
    def using(_other, **kwargs):
            def callback(lexer, match, ctx=None):
            def callback(lexer, match, ctx=None):
    class default:
        def __init__(self, state):
    class words(Future):
        def __init__(self, words, prefix='', suffix=''):
        def get(self):
    class RegexLexerMeta(LexerMeta):
        def _process_regex(cls, regex, rflags, state):
        def _process_token(cls, token):
        def _process_new_state(cls, new_state, unprocessed, processed):
        def _process_state(cls, unprocessed, processed, state):
        def process_tokendef(cls, name, tokendefs=None):
        def get_tokendefs(cls):
        def __call__(cls, *args, **kwds):
    class RegexLexer(Lexer, metaclass=RegexLexerMeta):
        def get_tokens_unprocessed(self, text, stack=('root',)):
    class LexerContext:
        def __init__(self, text, pos, stack=None, end=None):
        def __repr__(self):
    class ExtendedRegexLexer(RegexLexer):
        def get_tokens_unprocessed(self, text=None, context=None):
    def do_insertions(insertions, tokens):
    class ProfilingRegexLexerMeta(RegexLexerMeta):
        def _process_regex(cls, regex, rflags, state):
            def match_func(text, pos, endpos=sys.maxsize):
    class ProfilingRegexLexer(RegexLexer, metaclass=ProfilingRegexLexerMeta):
        def get_tokens_unprocessed(self, text, stack=('root',)):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: modeline.py
    import re
    def get_filetype_from_line(l): # noqa: E741
    def get_filetype_from_buffer(buf, max_lines=5):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: plugin.py
    from importlib.metadata import entry_points
    LEXER_ENTRY_POINT = 'pygments.lexers'
    FORMATTER_ENTRY_POINT = 'pygments.formatters'
    STYLE_ENTRY_POINT = 'pygments.styles'
    FILTER_ENTRY_POINT = 'pygments.filters'
    def iter_entry_points(group_name):
    def find_plugin_lexers():
    def find_plugin_formatters():
    def find_plugin_styles():
    def find_plugin_filters():

  ðŸ“„ Ð¤Ð°Ð¹Ð»: regexopt.py
    import re
    from re import escape
    from os.path import commonprefix
    from itertools import groupby
    from operator import itemgetter
    CS_ESCAPE = re.compile(r'[\[\^\\\-\]]')
    FIRST_ELEMENT = itemgetter(0)
    def make_charset(letters):
    def regex_opt_inner(strings, open_paren):
    def regex_opt(strings, prefix='', suffix=''):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: scanner.py
    import re
    class EndOfText(RuntimeError):
    class Scanner:
        def __init__(self, text, flags=0):
        def eos(self):
        def check(self, pattern):
        def test(self, pattern):
        def scan(self, pattern):
        def get_char(self):
        def __repr__(self):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: sphinxext.py
    import sys
    from docutils import nodes
    from docutils.statemachine import ViewList
    from docutils.parsers.rst import Directive
    from sphinx.util.nodes import nested_parse_with_titles
    MODULEDOC = '''
    LEXERDOC = '''
    FMTERDOC = '''
    FILTERDOC = '''
    class PygmentsDoc(Directive):
        def run(self):
        def document_lexers_overview(self):
            from pip._vendor.pygments.lexers._mapping import LEXERS
            from pip._vendor.pygments.lexers import find_lexer_class
            def format_link(name, url):
            def write_row(*columns):
            def write_seperator():
        def document_lexers(self):
            from pip._vendor.pygments.lexers._mapping import LEXERS
            from pip._vendor import pygments
            import inspect
            import pathlib
        def document_formatters(self):
            from pip._vendor.pygments.formatters import FORMATTERS
        def document_filters(self):
            from pip._vendor.pygments.filters import FILTERS
    def setup(app):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: style.py
    from pip._vendor.pygments.token import Token, STANDARD_TYPES
    class StyleMeta(type):
        def __new__(mcs, name, bases, dct):
            def colorformat(text):
        def style_for_token(cls, token):
        def list_styles(cls):
        def styles_token(cls, ttype):
        def __iter__(cls):
        def __len__(cls):
    class Style(metaclass=StyleMeta):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: token.py
    class _TokenType(tuple):
        def split(self):
        def __init__(self, *args):
        def __contains__(self, val):
        def __getattr__(self, val):
        def __repr__(self):
        def __copy__(self):
        def __deepcopy__(self, memo):
    def is_token_subtype(ttype, other):
    def string_to_tokentype(s):
    STANDARD_TYPES = {

  ðŸ“„ Ð¤Ð°Ð¹Ð»: unistring.py
    def combine(*args):
    def allexcept(*args):
    def _handle_runs(char_list):  # pragma: no cover
        import unicodedata

  ðŸ“„ Ð¤Ð°Ð¹Ð»: util.py
    import re
    from io import TextIOWrapper
    class ClassNotFound(ValueError):
    class OptionError(Exception):
    def get_choice_opt(options, optname, allowed, default=None, normcase=False):
    def get_bool_opt(options, optname, default=None):
    def get_int_opt(options, optname, default=None):
    def get_list_opt(options, optname, default=None):
    def docstring_headline(obj):
    def make_analysator(f):
        def text_analyse(text):
    def shebang_matches(text, regex):
    def doctype_matches(text, regex):
    def html_doctype_matches(text):
    def looks_like_xml(text):
    def surrogatepair(c):
    def format_lines(var_name, seq, raw=False, indent_level=0):
    def duplicates_removed(it, already_seen=()):
    class Future:
        def get(self):
    def guess_decode(text):
                import locale
    def guess_decode_from_terminal(text, term):
    def terminal_encoding(term):
        import locale
    class UnclosingTextIOWrapper(TextIOWrapper):
        def close(self):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from io import StringIO, BytesIO
    def lex(code, lexer):
            from pip._vendor.pygments.lexer import RegexLexer
    def format(tokens, formatter, outfile=None):  # pylint: disable=redefined-builtin
            from pip._vendor.pygments.formatter import Formatter
    def highlight(code, lexer, formatter, outfile=None):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __main__.py
    import sys
    from pip._vendor.pygments.cmdline import main

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\pygments\filters

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    import re
    from pip._vendor.pygments.token import String, Comment, Keyword, Name, Error, Whitespace, \
    from pip._vendor.pygments.filter import Filter
    from pip._vendor.pygments.util import get_list_opt, get_int_opt, get_bool_opt, \
    from pip._vendor.pygments.plugin import find_plugin_filters
    def find_filter_class(filtername):
    def get_filter_by_name(filtername, **options):
    def get_all_filters():
    def _replace_special(ttype, value, regex, specialttype,
    class CodeTagFilter(Filter):
        def __init__(self, **options):
        def filter(self, lexer, stream):
    class SymbolFilter(Filter):
        def __init__(self, **options):
        def filter(self, lexer, stream):
    class KeywordCaseFilter(Filter):
        def __init__(self, **options):
        def filter(self, lexer, stream):
    class NameHighlightFilter(Filter):
        def __init__(self, **options):
        def filter(self, lexer, stream):
    class ErrorToken(Exception):
    class RaiseOnErrorTokenFilter(Filter):
        def __init__(self, **options):
        def filter(self, lexer, stream):
    class VisibleWhitespaceFilter(Filter):
        def __init__(self, **options):
        def filter(self, lexer, stream):
                def replacefunc(wschar):
    class GobbleFilter(Filter):
        def __init__(self, **options):
        def gobble(self, value, left):
        def filter(self, lexer, stream):
    class TokenMergeFilter(Filter):
        def __init__(self, **options):
        def filter(self, lexer, stream):
    FILTERS = {

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\pygments\formatters

  ðŸ“„ Ð¤Ð°Ð¹Ð»: bbcode.py
    from pip._vendor.pygments.formatter import Formatter
    from pip._vendor.pygments.util import get_bool_opt
    class BBCodeFormatter(Formatter):
        def __init__(self, **options):
        def _make_styles(self):
        def format_unencoded(self, tokensource, outfile):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: groff.py
    import math
    from pip._vendor.pygments.formatter import Formatter
    from pip._vendor.pygments.util import get_bool_opt, get_int_opt
    class GroffFormatter(Formatter):
        def __init__(self, **options):
        def _make_styles(self):
        def _define_colors(self, outfile):
        def _write_lineno(self, outfile):
        def _wrap_line(self, line):
        def _escape_chars(self, text):
        def format_unencoded(self, tokensource, outfile):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: html.py
    import functools
    import os
    import sys
    import os.path
    from io import StringIO
    from pip._vendor.pygments.formatter import Formatter
    from pip._vendor.pygments.token import Token, Text, STANDARD_TYPES
    from pip._vendor.pygments.util import get_bool_opt, get_int_opt, get_list_opt
        import ctags
    def escape_html(text, table=_escape_html_table):
    def webify(color):
    def _get_ttype_class(ttype):
    CSSFILE_TEMPLATE = '''\
    DOC_HEADER = '''\
    DOC_HEADER_EXTERNALCSS = '''\
    DOC_FOOTER = '''\
    class HtmlFormatter(Formatter):
            class CodeHtmlFormatter(HtmlFormatter):
                def wrap(self, source, *, include_div):
                def _wrap_code(self, source):
        def __init__(self, **options):
        def _get_css_class(self, ttype):
        def _get_css_classes(self, ttype):
        def _get_css_inline_styles(self, ttype):
        def _create_stylesheet(self):
        def get_style_defs(self, arg=None):
        def get_token_style_defs(self, arg=None):
        def get_background_style_defs(self, arg=None):
        def get_linenos_style_defs(self):
        def get_css_prefix(self, arg):
            def prefix(cls):
        @property
        def _pre_style(self):
        @property
        def _linenos_style(self):
        @property
        def _linenos_special_style(self):
        def _decodeifneeded(self, value):
        def _wrap_full(self, inner, outfile):
        def _wrap_tablelinenos(self, inner):
        def _wrap_inlinelinenos(self, inner):
        def _wrap_lineanchors(self, inner):
        def _wrap_linespans(self, inner):
        def _wrap_div(self, inner):
        def _wrap_pre(self, inner):
        def _wrap_code(self, inner):
        @functools.lru_cache(maxsize=100)
        def _translate_parts(self, value):
        def _format_lines(self, tokensource):
        def _lookup_ctag(self, token):
        def _highlight_lines(self, tokensource):
        def wrap(self, source):
        def format_unencoded(self, tokensource, outfile):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: img.py
    import os
    import sys
    from pip._vendor.pygments.formatter import Formatter
    from pip._vendor.pygments.util import get_bool_opt, get_int_opt, get_list_opt, \
    import subprocess
        from PIL import Image, ImageDraw, ImageFont
        import _winreg
            import winreg as _winreg
    STYLES = {
    DEFAULT_FONT_NAME_NIX = 'DejaVu Sans Mono'
    DEFAULT_FONT_NAME_WIN = 'Courier New'
    DEFAULT_FONT_NAME_MAC = 'Menlo'
    class PilNotAvailable(ImportError):
    class FontNotFound(Exception):
    class FontManager:
        def __init__(self, font_name, font_size=14):
        def _get_nix_font_path(self, name, style):
        def _create_nix(self):
        def _get_mac_font_path(self, font_map, name, style):
        def _create_mac(self):
        def _lookup_win(self, key, basename, styles, fail=False):
        def _create_win(self):
        def get_char_size(self):
        def get_text_size(self, text):
        def get_font(self, bold, oblique):
        def get_style(self, style):
    class ImageFormatter(Formatter):
        def __init__(self, **options):
        def get_style_defs(self, arg=''):
        def _get_line_height(self):
        def _get_line_y(self, lineno):
        def _get_char_width(self):
        def _get_char_x(self, linelength):
        def _get_text_pos(self, linelength, lineno):
        def _get_linenumber_pos(self, lineno):
        def _get_text_color(self, style):
        def _get_text_bg_color(self, style):
        def _get_style_font(self, style):
        def _get_image_size(self, maxlinelength, maxlineno):
        def _draw_linenumber(self, posno, lineno):
        def _draw_text(self, pos, text, font, text_fg, text_bg):
        def _create_drawables(self, tokensource):
        def _draw_line_numbers(self):
        def _paint_line_number_bg(self, im):
        def format(self, tokensource, outfile):
    class GifImageFormatter(ImageFormatter):
    class JpgImageFormatter(ImageFormatter):
    class BmpImageFormatter(ImageFormatter):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: irc.py
    from pip._vendor.pygments.formatter import Formatter
    from pip._vendor.pygments.token import Keyword, Name, Comment, String, Error, \
    from pip._vendor.pygments.util import get_choice_opt
    IRC_COLORS = {
    IRC_COLOR_MAP = {
    def ircformat(color, text):
    class IRCFormatter(Formatter):
        def __init__(self, **options):
        def _write_lineno(self, outfile):
        def format_unencoded(self, tokensource, outfile):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: latex.py
    from io import StringIO
    from pip._vendor.pygments.formatter import Formatter
    from pip._vendor.pygments.lexer import Lexer, do_insertions
    from pip._vendor.pygments.token import Token, STANDARD_TYPES
    from pip._vendor.pygments.util import get_bool_opt, get_int_opt
    def escape_tex(text, commandprefix):
    DOC_TEMPLATE = r'''
    STYLE_TEMPLATE = r'''
    def _get_ttype_name(ttype):
    class LatexFormatter(Formatter):
        def __init__(self, **options):
        def _create_stylesheet(self):
            def rgbcolor(col):
        def get_style_defs(self, arg=''):
        def format_unencoded(self, tokensource, outfile):
    class LatexEmbeddedLexer(Lexer):
        def __init__(self, left, right, lang, **options):
        def get_tokens_unprocessed(self, text):
        def _find_safe_escape_tokens(self, text):
        def _filter_to(self, it, pred):
        def _find_escape_tokens(self, text):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: other.py
    from pip._vendor.pygments.formatter import Formatter
    from pip._vendor.pygments.util import get_choice_opt
    from pip._vendor.pygments.token import Token
    from pip._vendor.pygments.console import colorize
    class NullFormatter(Formatter):
        def format(self, tokensource, outfile):
    class RawTokenFormatter(Formatter):
        def __init__(self, **options):
        def format(self, tokensource, outfile):
                import gzip
                import bz2
                def write(text):
                def flush():
    TESTCASE_BEFORE = '''\
        def testNeedsName(lexer):
    TESTCASE_AFTER = '''\
    class TestcaseFormatter(Formatter):
        def __init__(self, **options):
        def format(self, tokensource, outfile):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: pangomarkup.py
    from pip._vendor.pygments.formatter import Formatter
    def escape_special_chars(text, table=_escape_table):
    class PangoMarkupFormatter(Formatter):
        def __init__(self, **options):
        def format_unencoded(self, tokensource, outfile):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: rtf.py
    from collections import OrderedDict
    from pip._vendor.pygments.formatter import Formatter
    from pip._vendor.pygments.style import _ansimap
    from pip._vendor.pygments.util import get_bool_opt, get_int_opt, get_list_opt, surrogatepair
    class RtfFormatter(Formatter):
        def __init__(self, **options):
        def _escape(self, text):
        def _escape_text(self, text):
        @staticmethod
        def hex_to_rtf_color(hex_color):
        def _split_tokens_on_newlines(self, tokensource):
        def _create_color_mapping(self):
        @property
        def _lineno_template(self):
        @property
        def _hl_open_str(self):
        @property
        def _rtf_header(self):
        def format_unencoded(self, tokensource, outfile):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: svg.py
    from pip._vendor.pygments.formatter import Formatter
    from pip._vendor.pygments.token import Comment
    from pip._vendor.pygments.util import get_bool_opt, get_int_opt
    def escape_html(text):
    class SvgFormatter(Formatter):
        def __init__(self, **options):
        def format_unencoded(self, tokensource, outfile):
        def _get_style(self, tokentype):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: terminal.py
    from pip._vendor.pygments.formatter import Formatter
    from pip._vendor.pygments.token import Keyword, Name, Comment, String, Error, \
    from pip._vendor.pygments.console import ansiformat
    from pip._vendor.pygments.util import get_choice_opt
    TERMINAL_COLORS = {
    class TerminalFormatter(Formatter):
        def __init__(self, **options):
        def format(self, tokensource, outfile):
        def _write_lineno(self, outfile):
        def _get_color(self, ttype):
        def format_unencoded(self, tokensource, outfile):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: terminal256.py
    from pip._vendor.pygments.formatter import Formatter
    from pip._vendor.pygments.console import codes
    from pip._vendor.pygments.style import ansicolors
    class EscapeSequence:
        def __init__(self, fg=None, bg=None, bold=False, underline=False, italic=False):
        def escape(self, attrs):
        def color_string(self):
        def true_color_string(self):
        def reset_string(self):
    class Terminal256Formatter(Formatter):
        def __init__(self, **options):
        def _build_color_table(self):
        def _closest_color(self, r, g, b):
        def _color_index(self, color):
        def _setup_styles(self):
        def _write_lineno(self, outfile):
        def format(self, tokensource, outfile):
        def format_unencoded(self, tokensource, outfile):
    class TerminalTrueColorFormatter(Terminal256Formatter):
        def _build_color_table(self):
        def _color_tuple(self, color):
        def _setup_styles(self):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _mapping.py
    FORMATTERS = {

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    import re
    import sys
    import types
    import fnmatch
    from os.path import basename
    from pip._vendor.pygments.formatters._mapping import FORMATTERS
    from pip._vendor.pygments.plugin import find_plugin_formatters
    from pip._vendor.pygments.util import ClassNotFound
    def _fn_matches(fn, glob):
    def _load_formatters(module_name):
    def get_all_formatters():
    def find_formatter_class(alias):
    def get_formatter_by_name(_alias, **options):
    def load_formatter_from_file(filename, formattername="CustomFormatter", **options):
    def get_formatter_for_filename(fn, **options):
    class _automodule(types.ModuleType):
        def __getattr__(self, name):

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\pygments\lexers

  ðŸ“„ Ð¤Ð°Ð¹Ð»: python.py
    import keyword
    from pip._vendor.pygments.lexer import DelegatingLexer, RegexLexer, include, \
    from pip._vendor.pygments.util import get_bool_opt, shebang_matches
    from pip._vendor.pygments.token import Text, Comment, Operator, Keyword, Name, String, \
    from pip._vendor.pygments import unistring as uni
    class PythonLexer(RegexLexer):
        def innerstring_rules(ttype):
        def fstring_rules(ttype):
        def analyse_text(text):
    class Python2Lexer(RegexLexer):
        def innerstring_rules(ttype):
        def analyse_text(text):
    class _PythonConsoleLexerBase(RegexLexer):
    class PythonConsoleLexer(DelegatingLexer):
        def __init__(self, **options):
            class _ReplaceInnerCode(DelegatingLexer):
                def __init__(self, **options):
    class PythonTracebackLexer(RegexLexer):
    class Python2TracebackLexer(RegexLexer):
    class CythonLexer(RegexLexer):
    class DgLexer(RegexLexer):
    class NumPyLexer(PythonLexer):
        EXTRA_KEYWORDS = {
        def get_tokens_unprocessed(self, text):
        def analyse_text(text):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _mapping.py
    LEXERS = {

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    import re
    import sys
    import types
    import fnmatch
    from os.path import basename
    from pip._vendor.pygments.lexers._mapping import LEXERS
    from pip._vendor.pygments.modeline import get_filetype_from_buffer
    from pip._vendor.pygments.plugin import find_plugin_lexers
    from pip._vendor.pygments.util import ClassNotFound, guess_decode
    COMPAT = {
    def _fn_matches(fn, glob):
    def _load_lexers(module_name):
    def get_all_lexers(plugins=True):
    def find_lexer_class(name):
    def find_lexer_class_by_name(_alias):
    def get_lexer_by_name(_alias, **options):
    def load_lexer_from_file(filename, lexername="CustomLexer", **options):
    def find_lexer_class_for_filename(_fn, code=None):
        def get_rating(info):
    def get_lexer_for_filename(_fn, code=None, **options):
    def get_lexer_for_mimetype(_mime, **options):
    def _iter_lexerclasses(plugins=True):
    def guess_lexer_for_filename(_fn, _text, **options):
        def type_sort(t):
    def guess_lexer(_text, **options):
        class is called with the text as argument, and the lexer which returned the
    class _automodule(types.ModuleType):
        def __getattr__(self, name):

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\pygments\styles

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _mapping.py
    STYLES = {

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from pip._vendor.pygments.plugin import find_plugin_styles
    from pip._vendor.pygments.util import ClassNotFound
    from pip._vendor.pygments.styles._mapping import STYLES
    STYLE_MAP = {v[1]: v[0].split('.')[-1] + '::' + k for k, v in STYLES.items()}
    _STYLE_NAME_TO_MODULE_MAP = {v[1]: (v[0], k) for k, v in STYLES.items()}
    def get_style_by_name(name):
    def get_all_styles():

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\pyproject_hooks

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _impl.py
    import json
    import os
    import sys
    import tempfile
    from contextlib import contextmanager
    from os.path import abspath
    from os.path import join as pjoin
    from subprocess import STDOUT, check_call, check_output
    from typing import TYPE_CHECKING, Any, Iterator, Mapping, Optional, Sequence
    from ._in_process import _in_proc_script_path
        from typing import Protocol
        class SubprocessRunner(Protocol):
            def __call__(
    def write_json(obj: Mapping[str, Any], path: str, **kwargs) -> None:
    def read_json(path: str) -> Mapping[str, Any]:
    class BackendUnavailable(Exception):
        def __init__(
    class HookMissing(Exception):
        def __init__(self, hook_name: str) -> None:
    class UnsupportedOperation(Exception):
        def __init__(self, traceback: str) -> None:
    def default_subprocess_runner(
    def quiet_subprocess_runner(
    def norm_and_check(source_tree: str, requested: str) -> str:
    class BuildBackendHookCaller:
        def __init__(
        @contextmanager
        def subprocess_runner(self, runner: "SubprocessRunner") -> Iterator[None]:
        def _supported_features(self) -> Sequence[str]:
        def get_requires_for_build_wheel(
        def prepare_metadata_for_build_wheel(
        def build_wheel(
        def get_requires_for_build_editable(
        def prepare_metadata_for_build_editable(
        def build_editable(
        def get_requires_for_build_sdist(
        def build_sdist(
        def _call_hook(self, hook_name: str, kwargs: Mapping[str, Any]) -> Any:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from typing import TYPE_CHECKING
    from ._impl import (
        from ._impl import SubprocessRunner

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\pyproject_hooks\_in_process

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _in_process.py
          _PYPROJECT_HOOKS_BUILD_BACKEND=entry.point:spec
          _PYPROJECT_HOOKS_BACKEND_PATH=paths (separated with os.pathsep)
    import json
    import os
    import os.path
    import re
    import shutil
    import sys
    import traceback
    from glob import glob
    from importlib import import_module
    from importlib.machinery import PathFinder
    from os.path import join as pjoin
    def write_json(obj, path, **kwargs):
    def read_json(path):
    class BackendUnavailable(Exception):
        def __init__(self, message, traceback=None):
    class HookMissing(Exception):
        def __init__(self, hook_name=None):
    def _build_backend():
    class _BackendPathFinder:
        def __init__(self, backend_path, backend_module):
        def find_spec(self, fullname, _path, _target=None):
            def find_distributions(self, context=None):
                from importlib.metadata import DistributionFinder, MetadataPathFinder
    def _supported_features():
    def get_requires_for_build_wheel(config_settings):
    def get_requires_for_build_editable(config_settings):
    def prepare_metadata_for_build_wheel(
    def prepare_metadata_for_build_editable(
    WHEEL_BUILT_MARKER = "PYPROJECT_HOOKS_ALREADY_BUILT_WHEEL"
    def _dist_info_files(whl_zip):
    def _get_wheel_metadata_from_wheel(whl_basename, metadata_directory, config_settings):
        from zipfile import ZipFile
    def _find_already_built_wheel(metadata_directory):
    def build_wheel(wheel_directory, config_settings, metadata_directory=None):
    def build_editable(wheel_directory, config_settings, metadata_directory=None):
    def get_requires_for_build_sdist(config_settings):
    class _DummyException(Exception):
    class GotUnsupportedOperation(Exception):
        def __init__(self, traceback):
    def build_sdist(sdist_directory, config_settings):
    HOOK_NAMES = {
    def main():

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    import importlib.resources as resources
        def _in_proc_script_path():
        def _in_proc_script_path():

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\requests

  ðŸ“„ Ð¤Ð°Ð¹Ð»: adapters.py
    import os.path
    import socket  # noqa: F401
    import typing
    import warnings
    from pip._vendor.urllib3.exceptions import ClosedPoolError, ConnectTimeoutError
    from pip._vendor.urllib3.exceptions import HTTPError as _HTTPError
    from pip._vendor.urllib3.exceptions import InvalidHeader as _InvalidHeader
    from pip._vendor.urllib3.exceptions import (
    from pip._vendor.urllib3.exceptions import ProxyError as _ProxyError
    from pip._vendor.urllib3.exceptions import ReadTimeoutError, ResponseError
    from pip._vendor.urllib3.exceptions import SSLError as _SSLError
    from pip._vendor.urllib3.poolmanager import PoolManager, proxy_from_url
    from pip._vendor.urllib3.util import Timeout as TimeoutSauce
    from pip._vendor.urllib3.util import parse_url
    from pip._vendor.urllib3.util.retry import Retry
    from pip._vendor.urllib3.util.ssl_ import create_urllib3_context
    from .auth import _basic_auth_str
    from .compat import basestring, urlparse
    from .cookies import extract_cookies_to_jar
    from .exceptions import (
    from .models import Response
    from .structures import CaseInsensitiveDict
    from .utils import (
        from pip._vendor.urllib3.contrib.socks import SOCKSProxyManager
        def SOCKSProxyManager(*args, **kwargs):
        from .models import PreparedRequest
    DEFAULT_POOLBLOCK = False
    DEFAULT_POOLSIZE = 10
    DEFAULT_RETRIES = 0
    DEFAULT_POOL_TIMEOUT = None
        import ssl  # noqa: F401
    def _urllib3_request_context(
    class BaseAdapter:
        def __init__(self):
        def send(
        def close(self):
    class HTTPAdapter(BaseAdapter):
        def __init__(
        def __getstate__(self):
        def __setstate__(self, state):
        def init_poolmanager(
        def proxy_manager_for(self, proxy, **proxy_kwargs):
        def cert_verify(self, conn, url, verify, cert):
        def build_response(self, req, resp):
        def build_connection_pool_key_attributes(self, request, verify, cert=None):
        def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):
        def get_connection(self, url, proxies=None):
        def close(self):
        def request_url(self, request, proxies):
        def add_headers(self, request, **kwargs):
        def proxy_headers(self, proxy):
        def send(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: api.py
    from . import sessions
    def request(method, url, **kwargs):
    def get(url, params=None, **kwargs):
    def options(url, **kwargs):
    def head(url, **kwargs):
    def post(url, data=None, json=None, **kwargs):
    def put(url, data=None, **kwargs):
    def patch(url, data=None, **kwargs):
    def delete(url, **kwargs):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: auth.py
    import hashlib
    import os
    import re
    import threading
    import time
    import warnings
    from base64 import b64encode
    from ._internal_utils import to_native_string
    from .compat import basestring, str, urlparse
    from .cookies import extract_cookies_to_jar
    from .utils import parse_dict_header
    CONTENT_TYPE_FORM_URLENCODED = "application/x-www-form-urlencoded"
    CONTENT_TYPE_MULTI_PART = "multipart/form-data"
    def _basic_auth_str(username, password):
    class AuthBase:
        def __call__(self, r):
    class HTTPBasicAuth(AuthBase):
        def __init__(self, username, password):
        def __eq__(self, other):
        def __ne__(self, other):
        def __call__(self, r):
    class HTTPProxyAuth(HTTPBasicAuth):
        def __call__(self, r):
    class HTTPDigestAuth(AuthBase):
        def __init__(self, username, password):
        def init_per_thread_state(self):
        def build_digest_header(self, method, url):
                def md5_utf8(x):
                def sha_utf8(x):
                def sha256_utf8(x):
                def sha512_utf8(x):
            KD = lambda s, d: hash_utf8(f"{s}:{d}")  # noqa:E731
        def handle_redirect(self, r, **kwargs):
        def handle_401(self, r, **kwargs):
        def __call__(self, r):
        def __eq__(self, other):
        def __ne__(self, other):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: certs.py
    from pip._vendor.certifi import where

  ðŸ“„ Ð¤Ð°Ð¹Ð»: compat.py
    import sys
    def _resolve_char_detection():
    import json
    from json import JSONDecodeError
    from collections import OrderedDict
    from collections.abc import Callable, Mapping, MutableMapping
    from http import cookiejar as cookielib
    from http.cookies import Morsel
    from io import StringIO
    from urllib.parse import (
    from urllib.request import (

  ðŸ“„ Ð¤Ð°Ð¹Ð»: cookies.py
    import calendar
    import copy
    import time
    from ._internal_utils import to_native_string
    from .compat import Morsel, MutableMapping, cookielib, urlparse, urlunparse
        import threading
        import dummy_threading as threading
    class MockRequest:
        def __init__(self, request):
        def get_type(self):
        def get_host(self):
        def get_origin_req_host(self):
        def get_full_url(self):
        def is_unverifiable(self):
        def has_header(self, name):
        def get_header(self, name, default=None):
        def add_header(self, key, val):
        def add_unredirected_header(self, name, value):
        def get_new_headers(self):
        @property
        def unverifiable(self):
        @property
        def origin_req_host(self):
        @property
        def host(self):
    class MockResponse:
        def __init__(self, headers):
        def info(self):
        def getheaders(self, name):
    def extract_cookies_to_jar(jar, request, response):
    def get_cookie_header(jar, request):
    def remove_cookie_by_name(cookiejar, name, domain=None, path=None):
    class CookieConflictError(RuntimeError):
    class RequestsCookieJar(cookielib.CookieJar, MutableMapping):
        def get(self, name, default=None, domain=None, path=None):
        def set(self, name, value, **kwargs):
        def iterkeys(self):
            from the jar.
        def keys(self):
        def itervalues(self):
            from the jar.
        def values(self):
        def iteritems(self):
            from the jar.
        def items(self):
        def list_domains(self):
        def list_paths(self):
        def multiple_domains(self):
        def get_dict(self, domain=None, path=None):
        def __contains__(self, name):
        def __getitem__(self, name):
        def __setitem__(self, name, value):
        def __delitem__(self, name):
        def set_cookie(self, cookie, *args, **kwargs):
        def update(self, other):
        def _find(self, name, domain=None, path=None):
        def _find_no_duplicates(self, name, domain=None, path=None):
        def __getstate__(self):
        def __setstate__(self, state):
        def copy(self):
        def get_policy(self):
    def _copy_cookie_jar(jar):
    def create_cookie(name, value, **kwargs):
    def morsel_to_cookie(morsel):
    def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):
    def merge_cookies(cookiejar, cookies):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: exceptions.py
    from pip._vendor.urllib3.exceptions import HTTPError as BaseHTTPError
    from .compat import JSONDecodeError as CompatJSONDecodeError
    class RequestException(IOError):
        def __init__(self, *args, **kwargs):
    class InvalidJSONError(RequestException):
    class JSONDecodeError(InvalidJSONError, CompatJSONDecodeError):
        def __init__(self, *args, **kwargs):
        def __reduce__(self):
    class HTTPError(RequestException):
    class ConnectionError(RequestException):
    class ProxyError(ConnectionError):
    class SSLError(ConnectionError):
    class Timeout(RequestException):
    class ConnectTimeout(ConnectionError, Timeout):
    class ReadTimeout(Timeout):
    class URLRequired(RequestException):
    class TooManyRedirects(RequestException):
    class MissingSchema(RequestException, ValueError):
    class InvalidSchema(RequestException, ValueError):
    class InvalidURL(RequestException, ValueError):
    class InvalidHeader(RequestException, ValueError):
    class InvalidProxyURL(InvalidURL):
    class ChunkedEncodingError(RequestException):
    class ContentDecodingError(RequestException, BaseHTTPError):
    class StreamConsumedError(RequestException, TypeError):
    class RetryError(RequestException):
    class UnrewindableBodyError(RequestException):
    class RequestsWarning(Warning):
    class FileModeWarning(RequestsWarning, DeprecationWarning):
    class RequestsDependencyWarning(RequestsWarning):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: help.py
    import json
    import platform
    import ssl
    import sys
    from pip._vendor import idna
    from pip._vendor import urllib3
    from . import __version__ as requests_version
        from pip._vendor.urllib3.contrib import pyopenssl
        import cryptography
        import OpenSSL
    def _implementation():
    def info():
    def main():

  ðŸ“„ Ð¤Ð°Ð¹Ð»: hooks.py
    HOOKS = ["response"]
    def default_hooks():
    def dispatch_hook(key, hooks, hook_data, **kwargs):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: models.py
    import datetime
    import encodings.idna  # noqa: F401
    from io import UnsupportedOperation
    from pip._vendor.urllib3.exceptions import (
    from pip._vendor.urllib3.fields import RequestField
    from pip._vendor.urllib3.filepost import encode_multipart_formdata
    from pip._vendor.urllib3.util import parse_url
    from ._internal_utils import to_native_string, unicode_is_ascii
    from .auth import HTTPBasicAuth
    from .compat import (
    from .compat import json as complexjson
    from .compat import urlencode, urlsplit, urlunparse
    from .cookies import _copy_cookie_jar, cookiejar_from_dict, get_cookie_header
    from .exceptions import (
    from .exceptions import JSONDecodeError as RequestsJSONDecodeError
    from .exceptions import MissingSchema
    from .exceptions import SSLError as RequestsSSLError
    from .exceptions import StreamConsumedError
    from .hooks import default_hooks
    from .status_codes import codes
    from .structures import CaseInsensitiveDict
    from .utils import (
    REDIRECT_STATI = (
    DEFAULT_REDIRECT_LIMIT = 30
    CONTENT_CHUNK_SIZE = 10 * 1024
    ITER_CHUNK_SIZE = 512
    class RequestEncodingMixin:
        @property
        def path_url(self):
        @staticmethod
        def _encode_params(data):
        @staticmethod
        def _encode_files(files, data):
    class RequestHooksMixin:
        def register_hook(self, event, hook):
        def deregister_hook(self, event, hook):
    class Request(RequestHooksMixin):
        def __init__(
        def __repr__(self):
        def prepare(self):
    class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):
        def __init__(self):
        def prepare(
        def __repr__(self):
        def copy(self):
        def prepare_method(self, method):
        @staticmethod
        def _get_idna_encoded_host(host):
            from pip._vendor import idna
        def prepare_url(self, url, params):
        def prepare_headers(self, headers):
        def prepare_body(self, data, files, json=None):
        def prepare_content_length(self, body):
        def prepare_auth(self, auth, url=""):
        def prepare_cookies(self, cookies):
        def prepare_hooks(self, hooks):
    class Response:
        def __init__(self):
        def __enter__(self):
        def __exit__(self, *args):
        def __getstate__(self):
        def __setstate__(self, state):
        def __repr__(self):
        def __bool__(self):
        def __nonzero__(self):
        def __iter__(self):
        @property
        def ok(self):
        @property
        def is_redirect(self):
        @property
        def is_permanent_redirect(self):
        @property
        def next(self):
        @property
        def apparent_encoding(self):
        def iter_content(self, chunk_size=1, decode_unicode=False):
            def generate():
        def iter_lines(
        @property
        def content(self):
        @property
        def text(self):
        def json(self, **kwargs):
        @property
        def links(self):
        def raise_for_status(self):
        def close(self):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: packages.py
    import sys
    from .compat import chardet

  ðŸ“„ Ð¤Ð°Ð¹Ð»: sessions.py
    import os
    import sys
    import time
    from collections import OrderedDict
    from datetime import timedelta
    from ._internal_utils import to_native_string
    from .adapters import HTTPAdapter
    from .auth import _basic_auth_str
    from .compat import Mapping, cookielib, urljoin, urlparse
    from .cookies import (
    from .exceptions import (
    from .hooks import default_hooks, dispatch_hook
    from .models import (  # noqa: F401
    from .status_codes import codes
    from .structures import CaseInsensitiveDict
    from .utils import (  # noqa: F401
    def merge_setting(request_setting, session_setting, dict_class=OrderedDict):
    def merge_hooks(request_hooks, session_hooks, dict_class=OrderedDict):
    class SessionRedirectMixin:
        def get_redirect_target(self, resp):
        def should_strip_auth(self, old_url, new_url):
        def resolve_redirects(
        def rebuild_auth(self, prepared_request, response):
        def rebuild_proxies(self, prepared_request, proxies):
        def rebuild_method(self, prepared_request, response):
    class Session(SessionRedirectMixin):
        def __init__(self):
        def __enter__(self):
        def __exit__(self, *args):
        def prepare_request(self, request):
        def request(
        def get(self, url, **kwargs):
        def options(self, url, **kwargs):
        def head(self, url, **kwargs):
        def post(self, url, data=None, json=None, **kwargs):
        def put(self, url, data=None, **kwargs):
        def patch(self, url, data=None, **kwargs):
        def delete(self, url, **kwargs):
        def send(self, request, **kwargs):
        def merge_environment_settings(self, url, proxies, stream, verify, cert):
        def get_adapter(self, url):
        def close(self):
        def mount(self, prefix, adapter):
        def __getstate__(self):
        def __setstate__(self, state):
    def session():

  ðŸ“„ Ð¤Ð°Ð¹Ð»: status_codes.py
    from .structures import LookupDict
    def _init():
        def doc(code):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: structures.py
    from collections import OrderedDict
    from .compat import Mapping, MutableMapping
    class CaseInsensitiveDict(MutableMapping):
        def __init__(self, data=None, **kwargs):
        def __setitem__(self, key, value):
        def __getitem__(self, key):
        def __delitem__(self, key):
        def __iter__(self):
        def __len__(self):
        def lower_items(self):
        def __eq__(self, other):
        def copy(self):
        def __repr__(self):
    class LookupDict(dict):
        def __init__(self, name=None):
        def __repr__(self):
        def __getitem__(self, key):
        def get(self, key, default=None):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: utils.py
    import codecs
    import contextlib
    import io
    import os
    import re
    import socket
    import struct
    import sys
    import tempfile
    import warnings
    import zipfile
    from collections import OrderedDict
    from pip._vendor.urllib3.util import make_headers, parse_url
    from . import certs
    from .__version__ import __version__
    from ._internal_utils import (  # noqa: F401
    from .compat import (
    from .compat import parse_http_list as _parse_list_header
    from .compat import (
    from .cookies import cookiejar_from_dict
    from .exceptions import (
    from .structures import CaseInsensitiveDict
    NETRC_FILES = (".netrc", "_netrc")
    DEFAULT_CA_BUNDLE_PATH = certs.where()
    DEFAULT_PORTS = {"http": 80, "https": 443}
    DEFAULT_ACCEPT_ENCODING = ", ".join(
        def proxy_bypass_registry(host):
                import winreg
        def proxy_bypass(host):  # noqa
    def dict_to_sequence(d):
    def super_len(o):
    def get_netrc_auth(url, raise_errors=False):
            from netrc import NetrcParseError, netrc
    def guess_filename(obj):
    def extract_zipped_paths(path):
    @contextlib.contextmanager
    def atomic_open(filename):
    def from_key_val_list(value):
    def to_key_val_list(value):
    def parse_list_header(value):
    def parse_dict_header(value):
    def unquote_header_value(value, is_filename=False):
    def dict_from_cookiejar(cj):
    def add_dict_to_cookiejar(cj, cookie_dict):
    def get_encodings_from_content(content):
    def _parse_content_type_header(header):
    def get_encoding_from_headers(headers):
    def stream_decode_response_unicode(iterator, r):
    def iter_slices(string, slice_length):
    def get_unicode_from_response(r):
    UNRESERVED_SET = frozenset(
    def unquote_unreserved(uri):
    def requote_uri(uri):
    def address_in_network(ip, net):
    def dotted_netmask(mask):
    def is_ipv4_address(string_ip):
    def is_valid_cidr(string_network):
    @contextlib.contextmanager
    def set_environ(env_name, value):
    def should_bypass_proxies(url, no_proxy):
        def get_proxy(key):
    def get_environ_proxies(url, no_proxy=None):
    def select_proxy(url, proxies):
    def resolve_proxies(request, proxies, trust_env=True):
    def default_user_agent(name="python-requests"):
    def default_headers():
    def parse_header_links(value):
    def guess_json_utf(data):
    def prepend_scheme_if_needed(url, new_scheme):
    def get_auth_from_url(url):
    def check_header_validity(header):
    def _validate_header_part(header, header_part, header_validator_index):
    def urldefragauth(url):
    def rewind_body(prepared_request):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _internal_utils.py
    import re
    from .compat import builtin_str
    _VALID_HEADER_NAME_RE_BYTE = re.compile(rb"^[^:\s][^:\r\n]*$")
    _VALID_HEADER_NAME_RE_STR = re.compile(r"^[^:\s][^:\r\n]*$")
    _VALID_HEADER_VALUE_RE_BYTE = re.compile(rb"^\S[^\r\n]*$|^$")
    _VALID_HEADER_VALUE_RE_STR = re.compile(r"^\S[^\r\n]*$|^$")
    _HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)
    _HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)
    HEADER_VALIDATORS = {
    def to_native_string(string, encoding="ascii"):
    def unicode_is_ascii(u_string):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    import warnings
    from pip._vendor import urllib3
    from .exceptions import RequestsDependencyWarning
    def check_compatibility(urllib3_version, chardet_version, charset_normalizer_version):
    def _check_cryptography(cryptography_version):
        from pip._internal.utils.compat import WINDOWS
            import ssl
            from pip._vendor.urllib3.contrib import pyopenssl
            from cryptography import __version__ as cryptography_version
    from pip._vendor.urllib3.exceptions import DependencyWarning
    import logging
    from logging import NullHandler
    from . import packages, utils
    from .__version__ import (
    from .api import delete, get, head, options, patch, post, put, request
    from .exceptions import (
    from .models import PreparedRequest, Request, Response
    from .sessions import Session, session
    from .status_codes import codes

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __version__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\resolvelib

  ðŸ“„ Ð¤Ð°Ð¹Ð»: providers.py
    class AbstractProvider(object):
        def identify(self, requirement_or_candidate):
        def get_preference(
        def find_matches(self, identifier, requirements, incompatibilities):
        def is_satisfied_by(self, requirement, candidate):
        def get_dependencies(self, candidate):
    class AbstractResolver(object):
        def __init__(self, provider, reporter):
        def resolve(self, requirements, **kwargs):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: reporters.py
    class BaseReporter(object):
        def starting(self):
        def starting_round(self, index):
        def ending_round(self, index, state):
        def ending(self, state):
        def adding_requirement(self, requirement, parent):
        def resolving_conflicts(self, causes):
        def rejecting_candidate(self, criterion, candidate):
        def pinning(self, candidate):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: resolvers.py
    import collections
    import itertools
    import operator
    from .providers import AbstractResolver
    from .structs import DirectedGraph, IteratorMapping, build_iter_view
    class ResolverException(Exception):
    class RequirementsConflicted(ResolverException):
        def __init__(self, criterion):
        def __str__(self):
    class InconsistentCandidate(ResolverException):
        def __init__(self, candidate, criterion):
        def __str__(self):
    class Criterion(object):
          from the union of contributing requirements and known incompatibilities.
        def __init__(self, candidates, information, incompatibilities):
        def __repr__(self):
        def iter_requirement(self):
        def iter_parent(self):
    class ResolutionError(ResolverException):
    class ResolutionImpossible(ResolutionError):
        def __init__(self, causes):
    class ResolutionTooDeep(ResolutionError):
        def __init__(self, round_count):
    class Resolution(object):
        def __init__(self, provider, reporter):
        @property
        def state(self):
        def _push_new_state(self):
        def _add_to_criteria(self, criteria, requirement, parent):
        def _remove_information_from_criteria(self, criteria, parents):
        def _get_preference(self, name):
        def _is_current_pin_satisfying(self, name, criterion):
        def _get_updated_criteria(self, candidate):
        def _attempt_to_pin_criterion(self, name):
        def _backjump(self, causes):
                def _patch_criteria():
        def resolve(self, requirements, max_rounds):
    def _has_route_to_root(criteria, key, all_keys, connected):
    def _build_result(state):
    class Resolver(AbstractResolver):
        def resolve(self, requirements, max_rounds=100):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: structs.py
    import itertools
    from .compat import collections_abc
    class DirectedGraph(object):
        def __init__(self):
        def __iter__(self):
        def __len__(self):
        def __contains__(self, key):
        def copy(self):
        def add(self, key):
        def remove(self, key):
        def connected(self, f, t):
        def connect(self, f, t):
        def iter_edges(self):
        def iter_children(self, key):
        def iter_parents(self, key):
    class IteratorMapping(collections_abc.Mapping):
        def __init__(self, mapping, accessor, appends=None):
        def __repr__(self):
        def __bool__(self):
        def __contains__(self, key):
        def __getitem__(self, k):
        def __iter__(self):
        def __len__(self):
    class _FactoryIterableView(object):
        def __init__(self, factory):
        def __repr__(self):
        def __bool__(self):
        def __iter__(self):
    class _SequenceIterableView(object):
        def __init__(self, sequence):
        def __repr__(self):
        def __bool__(self):
        def __iter__(self):
    def build_iter_view(matches):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from .providers import AbstractProvider, AbstractResolver
    from .reporters import BaseReporter
    from .resolvers import (

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\resolvelib\compat

  ðŸ“„ Ð¤Ð°Ð¹Ð»: collections_abc.py
        from collections.abc import Mapping, Sequence
        from collections import Mapping, Sequence

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\rich

  ðŸ“„ Ð¤Ð°Ð¹Ð»: abc.py
    from abc import ABC
    class RichRenderable(ABC):
        @classmethod
        def __subclasshook__(cls, other: type) -> bool:
        from pip._vendor.rich.text import Text
        class Foo:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: align.py
    import sys
    from itertools import chain
    from typing import TYPE_CHECKING, Iterable, Optional
        from typing import Literal
        from pip._vendor.typing_extensions import Literal  # pragma: no cover
    from .constrain import Constrain
    from .jupyter import JupyterMixin
    from .measure import Measurement
    from .segment import Segment
    from .style import StyleType
        from .console import Console, ConsoleOptions, RenderableType, RenderResult
    class Align(JupyterMixin):
        def __init__(
        def __repr__(self) -> str:
        @classmethod
        def left(
        @classmethod
        def center(
        @classmethod
        def right(
        def __rich_console__(
            def generate_segments() -> Iterable[Segment]:
            def blank_lines(count: int) -> Iterable[Segment]:
        def __rich_measure__(
    class VerticalCenter(JupyterMixin):
        def __init__(
        def __repr__(self) -> str:
        def __rich_console__(
            def blank_lines(count: int) -> Iterable[Segment]:
        def __rich_measure__(
        from pip._vendor.rich.console import Console, Group
        from pip._vendor.rich.highlighter import ReprHighlighter
        from pip._vendor.rich.panel import Panel

  ðŸ“„ Ð¤Ð°Ð¹Ð»: ansi.py
    import re
    import sys
    from contextlib import suppress
    from typing import Iterable, NamedTuple, Optional
    from .color import Color
    from .style import Style
    from .text import Text
    class _AnsiToken(NamedTuple):
    def _ansi_tokenize(ansi_text: str) -> Iterable[_AnsiToken]:
    SGR_STYLE_MAP = {
    class AnsiDecoder:
        def __init__(self) -> None:
        def decode(self, terminal_text: str) -> Iterable[Text]:
        def decode_line(self, line: str) -> Text:
        import io
        import os
        import pty
        import sys
        def read(fd: int) -> bytes:
        from .console import Console

  ðŸ“„ Ð¤Ð°Ð¹Ð»: bar.py
    from typing import Optional, Union
    from .color import Color
    from .console import Console, ConsoleOptions, RenderResult
    from .jupyter import JupyterMixin
    from .measure import Measurement
    from .segment import Segment
    from .style import Style
    BEGIN_BLOCK_ELEMENTS = ["â–ˆ", "â–ˆ", "â–ˆ", "â–", "â–", "â–", "â–•", "â–•"]
    END_BLOCK_ELEMENTS = [" ", "â–", "â–Ž", "â–", "â–Œ", "â–‹", "â–Š", "â–‰"]
    FULL_BLOCK = "â–ˆ"
    class Bar(JupyterMixin):
        def __init__(
        def __repr__(self) -> str:
        def __rich_console__(
        def __rich_measure__(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: box.py
    import sys
    from typing import TYPE_CHECKING, Iterable, List
        from typing import Literal
        from pip._vendor.typing_extensions import Literal  # pragma: no cover
    from ._loop import loop_last
        from pip._vendor.rich.console import ConsoleOptions
    class Box:
        def __init__(self, box: str, *, ascii: bool = False) -> None:
        def __repr__(self) -> str:
        def __str__(self) -> str:
        def substitute(self, options: "ConsoleOptions", safe: bool = True) -> "Box":
        def get_plain_headed_box(self) -> "Box":
        def get_top(self, widths: Iterable[int]) -> str:
        def get_row(
        def get_bottom(self, widths: Iterable[int]) -> str:
    LEGACY_WINDOWS_SUBSTITUTIONS = {
    PLAIN_HEADED_SUBSTITUTIONS = {
        from pip._vendor.rich.columns import Columns
        from pip._vendor.rich.panel import Panel
        from . import box as box
        from .console import Console
        from .table import Table
        from .text import Text
        BOXES = [

  ðŸ“„ Ð¤Ð°Ð¹Ð»: cells.py
    from __future__ import annotations
    from functools import lru_cache
    from typing import Callable
    from ._cell_widths import CELL_WIDTHS
    _SINGLE_CELLS = frozenset(
    @lru_cache(4096)
    def cached_cell_len(text: str) -> int:
    def cell_len(text: str, _cell_len: Callable[[str], int] = cached_cell_len) -> int:
    @lru_cache(maxsize=4096)
    def get_character_cell_size(character: str) -> int:
    def set_cell_size(text: str, total: int) -> str:
    def chop_cells(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: color.py
    import re
    import sys
    from colorsys import rgb_to_hls
    from enum import IntEnum
    from functools import lru_cache
    from typing import TYPE_CHECKING, NamedTuple, Optional, Tuple
    from ._palettes import EIGHT_BIT_PALETTE, STANDARD_PALETTE, WINDOWS_PALETTE
    from .color_triplet import ColorTriplet
    from .repr import Result, rich_repr
    from .terminal_theme import DEFAULT_TERMINAL_THEME
        from .terminal_theme import TerminalTheme
        from .text import Text
    WINDOWS = sys.platform == "win32"
    class ColorSystem(IntEnum):
        STANDARD = 1
        EIGHT_BIT = 2
        TRUECOLOR = 3
        WINDOWS = 4
        def __repr__(self) -> str:
        def __str__(self) -> str:
    class ColorType(IntEnum):
        DEFAULT = 0
        STANDARD = 1
        EIGHT_BIT = 2
        TRUECOLOR = 3
        WINDOWS = 4
        def __repr__(self) -> str:
    ANSI_COLOR_NAMES = {
    class ColorParseError(Exception):
    RE_COLOR = re.compile(
    @rich_repr
    class Color(NamedTuple):
        def __rich__(self) -> "Text":
            from .style import Style
            from .text import Text
        def __rich_repr__(self) -> Result:
        @property
        def system(self) -> ColorSystem:
        @property
        def is_system_defined(self) -> bool:
        @property
        def is_default(self) -> bool:
        def get_truecolor(
        @classmethod
        def from_ansi(cls, number: int) -> "Color":
        @classmethod
        def from_triplet(cls, triplet: "ColorTriplet") -> "Color":
        @classmethod
        def from_rgb(cls, red: float, green: float, blue: float) -> "Color":
        @classmethod
        def default(cls) -> "Color":
        @classmethod
        @lru_cache(maxsize=1024)
        def parse(cls, color: str) -> "Color":
        @lru_cache(maxsize=1024)
        def get_ansi_codes(self, foreground: bool = True) -> Tuple[str, ...]:
        @lru_cache(maxsize=1024)
        def downgrade(self, system: ColorSystem) -> "Color":
    def parse_rgb_hex(hex_color: str) -> ColorTriplet:
    def blend_rgb(
        from .console import Console
        from .table import Table
        from .text import Text

  ðŸ“„ Ð¤Ð°Ð¹Ð»: color_triplet.py
    from typing import NamedTuple, Tuple
    class ColorTriplet(NamedTuple):
        @property
        def hex(self) -> str:
        @property
        def rgb(self) -> str:
        @property
        def normalized(self) -> Tuple[float, float, float]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: columns.py
    from collections import defaultdict
    from itertools import chain
    from operator import itemgetter
    from typing import Dict, Iterable, List, Optional, Tuple
    from .align import Align, AlignMethod
    from .console import Console, ConsoleOptions, RenderableType, RenderResult
    from .constrain import Constrain
    from .measure import Measurement
    from .padding import Padding, PaddingDimensions
    from .table import Table
    from .text import TextType
    from .jupyter import JupyterMixin
    class Columns(JupyterMixin):
        def __init__(
        def add_renderable(self, renderable: RenderableType) -> None:
        def __rich_console__(
            def iter_renderables(
        import os

  ðŸ“„ Ð¤Ð°Ð¹Ð»: console.py
    import inspect
    import os
    import sys
    import threading
    import zlib
    from abc import ABC, abstractmethod
    from dataclasses import dataclass, field
    from datetime import datetime
    from functools import wraps
    from getpass import getpass
    from html import escape
    from inspect import isclass
    from itertools import islice
    from math import ceil
    from time import monotonic
    from types import FrameType, ModuleType, TracebackType
    from typing import (
    from pip._vendor.rich._null_file import NULL_FILE
        from typing import Literal, Protocol, runtime_checkable
        from pip._vendor.typing_extensions import (
    from . import errors, themes
    from ._emoji_replace import _emoji_replace
    from ._export_format import CONSOLE_HTML_FORMAT, CONSOLE_SVG_FORMAT
    from ._fileno import get_fileno
    from ._log_render import FormatTimeCallable, LogRender
    from .align import Align, AlignMethod
    from .color import ColorSystem, blend_rgb
    from .control import Control
    from .emoji import EmojiVariant
    from .highlighter import NullHighlighter, ReprHighlighter
    from .markup import render as render_markup
    from .measure import Measurement, measure_renderables
    from .pager import Pager, SystemPager
    from .pretty import Pretty, is_expandable
    from .protocol import rich_cast
    from .region import Region
    from .scope import render_scope
    from .screen import Screen
    from .segment import Segment
    from .style import Style, StyleType
    from .styled import Styled
    from .terminal_theme import DEFAULT_TERMINAL_THEME, SVG_EXPORT_THEME, TerminalTheme
    from .text import Text, TextType
    from .theme import Theme, ThemeStack
        from ._windows import WindowsConsoleFeatures
        from .live import Live
        from .status import Status
    JUPYTER_DEFAULT_COLUMNS = 115
    JUPYTER_DEFAULT_LINES = 100
    WINDOWS = sys.platform == "win32"
    class NoChange:
    NO_CHANGE = NoChange()
        _STDIN_FILENO = sys.__stdin__.fileno()  # type: ignore[union-attr]
        _STDIN_FILENO = 0
        _STDOUT_FILENO = sys.__stdout__.fileno()  # type: ignore[union-attr]
        _STDOUT_FILENO = 1
        _STDERR_FILENO = sys.__stderr__.fileno()  # type: ignore[union-attr]
        _STDERR_FILENO = 2
    _STD_STREAMS = (_STDIN_FILENO, _STDOUT_FILENO, _STDERR_FILENO)
    _STD_STREAMS_OUTPUT = (_STDOUT_FILENO, _STDERR_FILENO)
    _TERM_COLORS = {
    class ConsoleDimensions(NamedTuple):
    @dataclass
    class ConsoleOptions:
        @property
        def ascii_only(self) -> bool:
        def copy(self) -> "ConsoleOptions":
        def update(
        def update_width(self, width: int) -> "ConsoleOptions":
        def update_height(self, height: int) -> "ConsoleOptions":
        def reset_height(self) -> "ConsoleOptions":
        def update_dimensions(self, width: int, height: int) -> "ConsoleOptions":
    @runtime_checkable
    class RichCast(Protocol):
        def __rich__(
    @runtime_checkable
    class ConsoleRenderable(Protocol):
        def __rich_console__(
    class CaptureError(Exception):
    class NewLine:
        def __init__(self, count: int = 1) -> None:
        def __rich_console__(
    class ScreenUpdate:
        def __init__(self, lines: List[List[Segment]], x: int, y: int) -> None:
        def __rich_console__(
    class Capture:
        def __init__(self, console: "Console") -> None:
        def __enter__(self) -> "Capture":
        def __exit__(
        def get(self) -> str:
    class ThemeContext:
        def __init__(self, console: "Console", theme: Theme, inherit: bool = True) -> None:
        def __enter__(self) -> "ThemeContext":
        def __exit__(
    class PagerContext:
        def __init__(
        def __enter__(self) -> "PagerContext":
        def __exit__(
    class ScreenContext:
        def __init__(
        def update(
        def __enter__(self) -> "ScreenContext":
        def __exit__(
    class Group:
        def __init__(self, *renderables: "RenderableType", fit: bool = True) -> None:
        @property
        def renderables(self) -> List["RenderableType"]:
        def __rich_measure__(
        def __rich_console__(
    def group(fit: bool = True) -> Callable[..., Callable[..., Group]]:
        def decorator(
            @wraps(method)
            def _replace(*args: Any, **kwargs: Any) -> Group:
    def _is_jupyter() -> bool:  # pragma: no cover
    COLOR_SYSTEMS = {
    _COLOR_SYSTEMS_NAMES = {system: name for name, system in COLOR_SYSTEMS.items()}
    @dataclass
    class ConsoleThreadLocals(threading.local):
    class RenderHook(ABC):
        @abstractmethod
        def process_renderables(
    def get_windows_console_features() -> "WindowsConsoleFeatures":  # pragma: no cover
        from ._windows import get_windows_console_features
    def detect_legacy_windows() -> bool:
    class Console:
        def __init__(
        def __repr__(self) -> str:
        @property
        def file(self) -> IO[str]:
        @file.setter
        def file(self, new_file: IO[str]) -> None:
        @property
        def _buffer(self) -> List[Segment]:
        @property
        def _buffer_index(self) -> int:
        @_buffer_index.setter
        def _buffer_index(self, value: int) -> None:
        @property
        def _theme_stack(self) -> ThemeStack:
        def _detect_color_system(self) -> Optional[ColorSystem]:
        def _enter_buffer(self) -> None:
        def _exit_buffer(self) -> None:
        def set_live(self, live: "Live") -> None:
        def clear_live(self) -> None:
        def push_render_hook(self, hook: RenderHook) -> None:
        def pop_render_hook(self) -> None:
        def __enter__(self) -> "Console":
        def __exit__(self, exc_type: Any, exc_value: Any, traceback: Any) -> None:
        def begin_capture(self) -> None:
        def end_capture(self) -> str:
        def push_theme(self, theme: Theme, *, inherit: bool = True) -> None:
        def pop_theme(self) -> None:
        def use_theme(self, theme: Theme, *, inherit: bool = True) -> ThemeContext:
        @property
        def color_system(self) -> Optional[str]:
        @property
        def encoding(self) -> str:
        @property
        def is_terminal(self) -> bool:
        @property
        def is_dumb_terminal(self) -> bool:
        @property
        def options(self) -> ConsoleOptions:
        @property
        def size(self) -> ConsoleDimensions:
        @size.setter
        def size(self, new_size: Tuple[int, int]) -> None:
        @property
        def width(self) -> int:
        @width.setter
        def width(self, width: int) -> None:
        @property
        def height(self) -> int:
        @height.setter
        def height(self, height: int) -> None:
        def bell(self) -> None:
        def capture(self) -> Capture:
        def pager(
        def line(self, count: int = 1) -> None:
        def clear(self, home: bool = True) -> None:
        def status(
            from .status import Status
        def show_cursor(self, show: bool = True) -> bool:
        def set_alt_screen(self, enable: bool = True) -> bool:
        @property
        def is_alt_screen(self) -> bool:
        def set_window_title(self, title: str) -> bool:
        def screen(
        def measure(
        def render(
        def render_lines(
        def render_str(
        def get_style(
        def _collect_renderables(
                def align_append(renderable: RenderableType) -> None:
            def check_text() -> None:
        def rule(
            from .rule import Rule
        def control(self, *control: Control) -> None:
        def out(
        def print(
        def print_json(
            from pip._vendor.rich.json import JSON
        def update_screen(
        def update_screen_lines(
        def print_exception(
            from .traceback import Traceback
        @staticmethod
        def _caller_frame_info(
        def log(
        def on_broken_pipe(self) -> None:
        def _check_buffer(self) -> None:
        def _write_buffer(self) -> None:
                        from .jupyter import display
                                from pip._vendor.rich._win32_console import LegacyWindowsTerm
                                from pip._vendor.rich._windows_renderer import legacy_windows_render
                                MAX_WRITE = 32 * 1024 // 4
        def _render_buffer(self, buffer: Iterable[Segment]) -> str:
        def input(
        def export_text(self, *, clear: bool = True, styles: bool = False) -> str:
        def save_text(self, path: str, *, clear: bool = True, styles: bool = False) -> None:
        def export_html(
        def save_html(
        def export_svg(
            from pip._vendor.rich.cells import cell_len
            def get_svg_style(style: Style) -> str:
            def escape_text(text: str) -> str:
            def make_tag(
                def stringify(value: object) -> str:
        def save_svg(
    def _svg_hash(svg_main_code: str) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: constrain.py
    from typing import Optional, TYPE_CHECKING
    from .jupyter import JupyterMixin
    from .measure import Measurement
        from .console import Console, ConsoleOptions, RenderableType, RenderResult
    class Constrain(JupyterMixin):
        def __init__(self, renderable: "RenderableType", width: Optional[int] = 80) -> None:
        def __rich_console__(
        def __rich_measure__(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: containers.py
    from itertools import zip_longest
    from typing import (
        from .console import (
        from .text import Text
    from .cells import cell_len
    from .measure import Measurement
    T = TypeVar("T")
    class Renderables:
        def __init__(
        def __rich_console__(
        def __rich_measure__(
        def append(self, renderable: "RenderableType") -> None:
        def __iter__(self) -> Iterable["RenderableType"]:
    class Lines:
        def __init__(self, lines: Iterable["Text"] = ()) -> None:
        def __repr__(self) -> str:
        def __iter__(self) -> Iterator["Text"]:
        @overload
        def __getitem__(self, index: int) -> "Text":
        @overload
        def __getitem__(self, index: slice) -> List["Text"]:
        def __getitem__(self, index: Union[slice, int]) -> Union["Text", List["Text"]]:
        def __setitem__(self, index: int, value: "Text") -> "Lines":
        def __len__(self) -> int:
        def __rich_console__(
        def append(self, line: "Text") -> None:
        def extend(self, lines: Iterable["Text"]) -> None:
        def pop(self, index: int = -1) -> "Text":
        def justify(
            from .text import Text

  ðŸ“„ Ð¤Ð°Ð¹Ð»: control.py
    import sys
    import time
    from typing import TYPE_CHECKING, Callable, Dict, Iterable, List, Union
        from typing import Final
        from pip._vendor.typing_extensions import Final  # pragma: no cover
    from .segment import ControlCode, ControlType, Segment
        from .console import Console, ConsoleOptions, RenderResult
    class Control:
        def __init__(self, *codes: Union[ControlType, ControlCode]) -> None:
        @classmethod
        def bell(cls) -> "Control":
        @classmethod
        def home(cls) -> "Control":
        @classmethod
        def move(cls, x: int = 0, y: int = 0) -> "Control":
            def get_codes() -> Iterable[ControlCode]:
        @classmethod
        def move_to_column(cls, x: int, y: int = 0) -> "Control":
        @classmethod
        def move_to(cls, x: int, y: int) -> "Control":
        @classmethod
        def clear(cls) -> "Control":
        @classmethod
        def show_cursor(cls, show: bool) -> "Control":
        @classmethod
        def alt_screen(cls, enable: bool) -> "Control":
        @classmethod
        def title(cls, title: str) -> "Control":
        def __str__(self) -> str:
        def __rich_console__(
    def strip_control_codes(
    def escape_control_codes(
        from pip._vendor.rich.console import Console

  ðŸ“„ Ð¤Ð°Ð¹Ð»: default_styles.py
    from typing import Dict
    from .style import Style
        import argparse
        import io
        from pip._vendor.rich.console import Console
        from pip._vendor.rich.table import Table
        from pip._vendor.rich.text import Text

  ðŸ“„ Ð¤Ð°Ð¹Ð»: diagnose.py
    import os
    import platform
    from pip._vendor.rich import inspect
    from pip._vendor.rich.console import Console, get_windows_console_features
    from pip._vendor.rich.panel import Panel
    from pip._vendor.rich.pretty import Pretty
    def report() -> None:  # pragma: no cover

  ðŸ“„ Ð¤Ð°Ð¹Ð»: emoji.py
    import sys
    from typing import TYPE_CHECKING, Optional, Union
    from .jupyter import JupyterMixin
    from .segment import Segment
    from .style import Style
    from ._emoji_codes import EMOJI
    from ._emoji_replace import _emoji_replace
        from typing import Literal
        from pip._vendor.typing_extensions import Literal  # pragma: no cover
        from .console import Console, ConsoleOptions, RenderResult
    class NoEmoji(Exception):
    class Emoji(JupyterMixin):
        VARIANTS = {"text": "\uFE0E", "emoji": "\uFE0F"}
        def __init__(
        @classmethod
        def replace(cls, text: str) -> str:
        def __repr__(self) -> str:
        def __str__(self) -> str:
        def __rich_console__(
        import sys
        from pip._vendor.rich.columns import Columns
        from pip._vendor.rich.console import Console

  ðŸ“„ Ð¤Ð°Ð¹Ð»: errors.py
    class ConsoleError(Exception):
    class StyleError(Exception):
    class StyleSyntaxError(ConsoleError):
    class MissingStyle(StyleError):
    class StyleStackError(ConsoleError):
    class NotRenderableError(ConsoleError):
    class MarkupError(ConsoleError):
    class LiveError(ConsoleError):
    class NoAltScreen(ConsoleError):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: filesize.py
    from typing import Iterable, List, Optional, Tuple
    def _to_str(
    def pick_unit_and_suffix(size: int, suffixes: List[str], base: int) -> Tuple[int, str]:
    def decimal(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: file_proxy.py
    import io
    from typing import IO, TYPE_CHECKING, Any, List
    from .ansi import AnsiDecoder
    from .text import Text
        from .console import Console
    class FileProxy(io.TextIOBase):
        def __init__(self, console: "Console", file: IO[str]) -> None:
        @property
        def rich_proxied_file(self) -> IO[str]:
        def __getattr__(self, name: str) -> Any:
        def write(self, text: str) -> int:
        def flush(self) -> None:
        def fileno(self) -> int:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: highlighter.py
    import re
    from abc import ABC, abstractmethod
    from typing import List, Union
    from .text import Span, Text
    def _combine_regex(*regexes: str) -> str:
    class Highlighter(ABC):
        def __call__(self, text: Union[str, Text]) -> Text:
        @abstractmethod
        def highlight(self, text: Text) -> None:
    class NullHighlighter(Highlighter):
        def highlight(self, text: Text) -> None:
    class RegexHighlighter(Highlighter):
        def highlight(self, text: Text) -> None:
    class ReprHighlighter(RegexHighlighter):
    class JSONHighlighter(RegexHighlighter):
        JSON_STR = r"(?<![\\\w])(?P<str>b?\".*?(?<!\\)\")"
        JSON_WHITESPACE = {" ", "\n", "\r", "\t"}
        def highlight(self, text: Text) -> None:
    class ISO8601Highlighter(RegexHighlighter):
        from .console import Console
        import json

  ðŸ“„ Ð¤Ð°Ð¹Ð»: json.py
    from pathlib import Path
    from json import loads, dumps
    from typing import Any, Callable, Optional, Union
    from .text import Text
    from .highlighter import JSONHighlighter, NullHighlighter
    class JSON:
        def __init__(
        @classmethod
        def from_data(
        def __rich__(self) -> Text:
        import argparse
        import sys
        from pip._vendor.rich.console import Console

  ðŸ“„ Ð¤Ð°Ð¹Ð»: jupyter.py
    from typing import TYPE_CHECKING, Any, Dict, Iterable, List, Sequence
        from pip._vendor.rich.console import ConsoleRenderable
    from . import get_console
    from .segment import Segment
    from .terminal_theme import DEFAULT_TERMINAL_THEME
        from pip._vendor.rich.console import ConsoleRenderable
    JUPYTER_HTML_FORMAT = """\
    class JupyterRenderable:
        def __init__(self, html: str, text: str) -> None:
        def _repr_mimebundle_(
    class JupyterMixin:
        def _repr_mimebundle_(
    def _render_segments(segments: Iterable[Segment]) -> str:
        def escape(text: str) -> str:
    def display(segments: Iterable[Segment], text: str) -> None:
            from IPython.display import display as ipython_display
    def print(*args: Any, **kwargs: Any) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: layout.py
    from abc import ABC, abstractmethod
    from itertools import islice
    from operator import itemgetter
    from threading import RLock
    from typing import (
    from ._ratio import ratio_resolve
    from .align import Align
    from .console import Console, ConsoleOptions, RenderableType, RenderResult
    from .highlighter import ReprHighlighter
    from .panel import Panel
    from .pretty import Pretty
    from .region import Region
    from .repr import Result, rich_repr
    from .segment import Segment
    from .style import StyleType
        from pip._vendor.rich.tree import Tree
    class LayoutRender(NamedTuple):
    class LayoutError(Exception):
    class NoSplitter(LayoutError):
    class _Placeholder:
        def __init__(self, layout: "Layout", style: StyleType = "") -> None:
        def __rich_console__(
    class Splitter(ABC):
        @abstractmethod
        def get_tree_icon(self) -> str:
        @abstractmethod
        def divide(
    class RowSplitter(Splitter):
        def get_tree_icon(self) -> str:
        def divide(
    class ColumnSplitter(Splitter):
        def get_tree_icon(self) -> str:
        def divide(
    @rich_repr
    class Layout:
        def __init__(
        def __rich_repr__(self) -> Result:
        @property
        def renderable(self) -> RenderableType:
        @property
        def children(self) -> List["Layout"]:
        @property
        def map(self) -> RenderMap:
        def get(self, name: str) -> Optional["Layout"]:
        def __getitem__(self, name: str) -> "Layout":
        @property
        def tree(self) -> "Tree":
            from pip._vendor.rich.styled import Styled
            from pip._vendor.rich.table import Table
            from pip._vendor.rich.tree import Tree
            def summary(layout: "Layout") -> Table:
            def recurse(tree: "Tree", layout: "Layout") -> None:
        def split(
        def add_split(self, *layouts: Union["Layout", RenderableType]) -> None:
        def split_row(self, *layouts: Union["Layout", RenderableType]) -> None:
        def split_column(self, *layouts: Union["Layout", RenderableType]) -> None:
        def unsplit(self) -> None:
        def update(self, renderable: RenderableType) -> None:
        def refresh_screen(self, console: "Console", layout_name: str) -> None:
        def _make_region_map(self, width: int, height: int) -> RegionMap:
        def render(self, console: Console, options: ConsoleOptions) -> RenderMap:
        def __rich_console__(
        from pip._vendor.rich.console import Console

  ðŸ“„ Ð¤Ð°Ð¹Ð»: live.py
    import sys
    from threading import Event, RLock, Thread
    from types import TracebackType
    from typing import IO, Any, Callable, List, Optional, TextIO, Type, cast
    from . import get_console
    from .console import Console, ConsoleRenderable, RenderableType, RenderHook
    from .control import Control
    from .file_proxy import FileProxy
    from .jupyter import JupyterMixin
    from .live_render import LiveRender, VerticalOverflowMethod
    from .screen import Screen
    from .text import Text
    class _RefreshThread(Thread):
        def __init__(self, live: "Live", refresh_per_second: float) -> None:
        def stop(self) -> None:
        def run(self) -> None:
    class Live(JupyterMixin, RenderHook):
        def __init__(
        @property
        def is_started(self) -> bool:
        def get_renderable(self) -> RenderableType:
        def start(self, refresh: bool = False) -> None:
        def stop(self) -> None:
        def __enter__(self) -> "Live":
        def __exit__(
        def _enable_redirect_io(self) -> None:
        def _disable_redirect_io(self) -> None:
        @property
        def renderable(self) -> RenderableType:
        def update(self, renderable: RenderableType, *, refresh: bool = False) -> None:
        def refresh(self) -> None:
                        from IPython.display import display
                        from ipywidgets import Output
                        import warnings
        def process_renderables(
        import random
        import time
        from itertools import cycle
        from typing import Dict, List, Tuple
        from .align import Align
        from .console import Console
        from .live import Live as Live
        from .panel import Panel
        from .rule import Rule
        from .syntax import Syntax
        from .table import Table

  ðŸ“„ Ð¤Ð°Ð¹Ð»: live_render.py
    import sys
    from typing import Optional, Tuple
        from typing import Literal
        from pip._vendor.typing_extensions import Literal  # pragma: no cover
    from ._loop import loop_last
    from .console import Console, ConsoleOptions, RenderableType, RenderResult
    from .control import Control
    from .segment import ControlType, Segment
    from .style import StyleType
    from .text import Text
    class LiveRender:
        def __init__(
        def set_renderable(self, renderable: RenderableType) -> None:
        def position_cursor(self) -> Control:
        def restore_cursor(self) -> Control:
        def __rich_console__(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: logging.py
    import logging
    from datetime import datetime
    from logging import Handler, LogRecord
    from pathlib import Path
    from types import ModuleType
    from typing import ClassVar, Iterable, List, Optional, Type, Union
    from pip._vendor.rich._null_file import NullFile
    from . import get_console
    from ._log_render import FormatTimeCallable, LogRender
    from .console import Console, ConsoleRenderable
    from .highlighter import Highlighter, ReprHighlighter
    from .text import Text
    from .traceback import Traceback
    class RichHandler(Handler):
        def __init__(
        def get_level_text(self, record: LogRecord) -> Text:
        def emit(self, record: LogRecord) -> None:
        def render_message(self, record: LogRecord, message: str) -> "ConsoleRenderable":
        def render(
        from time import sleep
        FORMAT = "%(message)s"
        def divide() -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: markup.py
    import re
    from ast import literal_eval
    from operator import attrgetter
    from typing import Callable, Iterable, List, Match, NamedTuple, Optional, Tuple, Union
    from ._emoji_replace import _emoji_replace
    from .emoji import EmojiVariant
    from .errors import MarkupError
    from .style import Style
    from .text import Span, Text
    RE_TAGS = re.compile(
    RE_HANDLER = re.compile(r"^([\w.]*?)(\(.*?\))?$")
    class Tag(NamedTuple):
        def __str__(self) -> str:
        @property
        def markup(self) -> str:
    def escape(
        def escape_backslashes(match: Match[str]) -> str:
    def _parse(markup: str) -> Iterable[Tuple[int, Optional[str], Optional[Tag]]]:
    def render(
        def pop_style(style_name: str) -> Tuple[int, Tag]:
        MARKUP = [
        from pip._vendor.rich import print
        from pip._vendor.rich.table import Table

  ðŸ“„ Ð¤Ð°Ð¹Ð»: measure.py
    from operator import itemgetter
    from typing import TYPE_CHECKING, Callable, NamedTuple, Optional, Sequence
    from . import errors
    from .protocol import is_renderable, rich_cast
        from .console import Console, ConsoleOptions, RenderableType
    class Measurement(NamedTuple):
        @property
        def span(self) -> int:
        def normalize(self) -> "Measurement":
        def with_maximum(self, width: int) -> "Measurement":
        def with_minimum(self, width: int) -> "Measurement":
        def clamp(
        @classmethod
        def get(
    def measure_renderables(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: padding.py
    from typing import TYPE_CHECKING, List, Optional, Tuple, Union
        from .console import (
    from .jupyter import JupyterMixin
    from .measure import Measurement
    from .segment import Segment
    from .style import Style
    class Padding(JupyterMixin):
        def __init__(
        @classmethod
        def indent(cls, renderable: "RenderableType", level: int) -> "Padding":
        @staticmethod
        def unpack(pad: "PaddingDimensions") -> Tuple[int, int, int, int]:
        def __repr__(self) -> str:
        def __rich_console__(
        def __rich_measure__(
        from pip._vendor.rich import print

  ðŸ“„ Ð¤Ð°Ð¹Ð»: pager.py
    from abc import ABC, abstractmethod
    from typing import Any
    class Pager(ABC):
        @abstractmethod
        def show(self, content: str) -> None:
    class SystemPager(Pager):
        def _pager(self, content: str) -> Any:  # Â pragma: no cover
        def show(self, content: str) -> None:
        from .__main__ import make_test_card
        from .console import Console

  ðŸ“„ Ð¤Ð°Ð¹Ð»: palette.py
    from math import sqrt
    from functools import lru_cache
    from typing import Sequence, Tuple, TYPE_CHECKING
    from .color_triplet import ColorTriplet
        from pip._vendor.rich.table import Table
    class Palette:
        def __init__(self, colors: Sequence[Tuple[int, int, int]]):
        def __getitem__(self, number: int) -> ColorTriplet:
        def __rich__(self) -> "Table":
            from pip._vendor.rich.color import Color
            from pip._vendor.rich.style import Style
            from pip._vendor.rich.text import Text
            from pip._vendor.rich.table import Table
        @lru_cache(maxsize=1024)
        def match(self, color: Tuple[int, int, int]) -> int:
            def get_color_distance(index: int) -> float:
        import colorsys
        from typing import Iterable
        from pip._vendor.rich.color import Color
        from pip._vendor.rich.console import Console, ConsoleOptions
        from pip._vendor.rich.segment import Segment
        from pip._vendor.rich.style import Style
        class ColorBox:
            def __rich_console__(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: panel.py
    from typing import TYPE_CHECKING, Optional
    from .align import AlignMethod
    from .box import ROUNDED, Box
    from .cells import cell_len
    from .jupyter import JupyterMixin
    from .measure import Measurement, measure_renderables
    from .padding import Padding, PaddingDimensions
    from .segment import Segment
    from .style import Style, StyleType
    from .text import Text, TextType
        from .console import Console, ConsoleOptions, RenderableType, RenderResult
    class Panel(JupyterMixin):
        def __init__(
        @classmethod
        def fit(
        @property
        def _title(self) -> Optional[Text]:
        @property
        def _subtitle(self) -> Optional[Text]:
        def __rich_console__(
            def align_text(
        def __rich_measure__(
        from .console import Console
        from .box import DOUBLE, ROUNDED
        from .padding import Padding

  ðŸ“„ Ð¤Ð°Ð¹Ð»: pretty.py
    import builtins
    import collections
    import dataclasses
    import inspect
    import os
    import reprlib
    import sys
    from array import array
    from collections import Counter, UserDict, UserList, defaultdict, deque
    from dataclasses import dataclass, fields, is_dataclass
    from inspect import isclass
    from itertools import islice
    from types import MappingProxyType
    from typing import (
    from pip._vendor.rich.repr import RichReprResult
        import attr as _attr_module
    from . import get_console
    from ._loop import loop_last
    from ._pick import pick_bool
    from .abc import RichRenderable
    from .cells import cell_len
    from .highlighter import ReprHighlighter
    from .jupyter import JupyterMixin, JupyterRenderable
    from .measure import Measurement
    from .text import Text
        from .console import (
    def _is_attr_object(obj: Any) -> bool:
    def _get_attr_fields(obj: Any) -> Sequence["_attr_module.Attribute[Any]"]:
    def _is_dataclass_repr(obj: object) -> bool:
    def _has_default_namedtuple_repr(obj: object) -> bool:
    def _ipy_display_hook(
        from .console import ConsoleRenderable
    def _safe_isinstance(
    def install(
        from pip._vendor.rich import get_console
        def display_hook(value: Any) -> None:
            from IPython.core.formatters import BaseFormatter
            class RichFormatter(BaseFormatter):  # type: ignore[misc]
                def __call__(self, value: Any) -> Any:
    class Pretty(JupyterMixin):
        def __init__(
        def __rich_console__(
        def __rich_measure__(
    def _get_braces_for_defaultdict(_object: DefaultDict[Any, Any]) -> Tuple[str, str, str]:
    def _get_braces_for_deque(_object: Deque[Any]) -> Tuple[str, str, str]:
    def _get_braces_for_array(_object: "array[Any]") -> Tuple[str, str, str]:
    _CONTAINERS = tuple(_BRACES.keys())
    _MAPPING_CONTAINERS = (dict, os._Environ, MappingProxyType, UserDict)
    def is_expandable(obj: Any) -> bool:
    @dataclass
    class Node:
        def iter_tokens(self) -> Iterable[str]:
        def check_length(self, start_length: int, max_length: int) -> bool:
        def __str__(self) -> str:
        def render(
    @dataclass
    class _Line:
        @property
        def expandable(self) -> bool:
        def check_length(self, max_length: int) -> bool:
        def expand(self, indent_size: int) -> Iterable["_Line"]:
        def __str__(self) -> str:
    def _is_namedtuple(obj: Any) -> bool:
    def traverse(
        def to_repr(obj: Any) -> str:
        def _traverse(obj: Any, root: bool = False, depth: int = 0) -> Node:
            def iter_rich_args(rich_args: Any) -> Iterable[Union[Any, Tuple[str, Any]]]:
                        def iter_attrs() -> (
    def pretty_repr(
    def pprint(
        class BrokenRepr:
            def __repr__(self) -> str:
        from typing import NamedTuple
        class StockKeepingUnit(NamedTuple):
        from pip._vendor.rich import print
        class Thing:
            def __repr__(self) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: progress.py
    import io
    import sys
    import typing
    import warnings
    from abc import ABC, abstractmethod
    from collections import deque
    from dataclasses import dataclass, field
    from datetime import timedelta
    from io import RawIOBase, UnsupportedOperation
    from math import ceil
    from mmap import mmap
    from operator import length_hint
    from os import PathLike, stat
    from threading import Event, RLock, Thread
    from types import TracebackType
    from typing import (
        from typing import Literal
        from pip._vendor.typing_extensions import Literal  # pragma: no cover
        from typing import Self
        from pip._vendor.typing_extensions import Self  # pragma: no cover
    from . import filesize, get_console
    from .console import Console, Group, JustifyMethod, RenderableType
    from .highlighter import Highlighter
    from .jupyter import JupyterMixin
    from .live import Live
    from .progress_bar import ProgressBar
    from .spinner import Spinner
    from .style import StyleType
    from .table import Column, Table
    from .text import Text, TextType
    _I = typing.TypeVar("_I", TextIO, BinaryIO)
    class _TrackThread(Thread):
        def __init__(self, progress: "Progress", task_id: "TaskID", update_period: float):
        def run(self) -> None:
        def __enter__(self) -> "_TrackThread":
        def __exit__(
    def track(
    class _Reader(RawIOBase, BinaryIO):
        def __init__(
        def __enter__(self) -> "_Reader":
        def __exit__(
        def __iter__(self) -> BinaryIO:
        def __next__(self) -> bytes:
        @property
        def closed(self) -> bool:
        def fileno(self) -> int:
        def isatty(self) -> bool:
        @property
        def mode(self) -> str:
        @property
        def name(self) -> str:
        def readable(self) -> bool:
        def seekable(self) -> bool:
        def writable(self) -> bool:
        def read(self, size: int = -1) -> bytes:
        def readinto(self, b: Union[bytearray, memoryview, mmap]):  # type: ignore[no-untyped-def, override]
        def readline(self, size: int = -1) -> bytes:  # type: ignore[override]
        def readlines(self, hint: int = -1) -> List[bytes]:
        def close(self) -> None:
        def seek(self, offset: int, whence: int = 0) -> int:
        def tell(self) -> int:
        def write(self, s: Any) -> int:
        def writelines(self, lines: Iterable[Any]) -> None:
    class _ReadContext(ContextManager[_I], Generic[_I]):
        def __init__(self, progress: "Progress", reader: _I) -> None:
        def __enter__(self) -> _I:
        def __exit__(
    def wrap_file(
    @typing.overload
    def open(
    @typing.overload
    def open(
    def open(
    class ProgressColumn(ABC):
        def __init__(self, table_column: Optional[Column] = None) -> None:
        def get_table_column(self) -> Column:
        def __call__(self, task: "Task") -> RenderableType:
        @abstractmethod
        def render(self, task: "Task") -> RenderableType:
    class RenderableColumn(ProgressColumn):
        def __init__(
        def render(self, task: "Task") -> RenderableType:
    class SpinnerColumn(ProgressColumn):
        def __init__(
        def set_spinner(
        def render(self, task: "Task") -> RenderableType:
    class TextColumn(ProgressColumn):
        def __init__(
        def render(self, task: "Task") -> Text:
    class BarColumn(ProgressColumn):
        def __init__(
        def render(self, task: "Task") -> ProgressBar:
    class TimeElapsedColumn(ProgressColumn):
        def render(self, task: "Task") -> Text:
    class TaskProgressColumn(TextColumn):
        def __init__(
        @classmethod
        def render_speed(cls, speed: Optional[float]) -> Text:
        def render(self, task: "Task") -> Text:
    class TimeRemainingColumn(ProgressColumn):
        def __init__(
        def render(self, task: "Task") -> Text:
    class FileSizeColumn(ProgressColumn):
        def render(self, task: "Task") -> Text:
    class TotalFileSizeColumn(ProgressColumn):
        def render(self, task: "Task") -> Text:
    class MofNCompleteColumn(ProgressColumn):
        def __init__(self, separator: str = "/", table_column: Optional[Column] = None):
        def render(self, task: "Task") -> Text:
    class DownloadColumn(ProgressColumn):
        def __init__(
        def render(self, task: "Task") -> Text:
    class TransferSpeedColumn(ProgressColumn):
        def render(self, task: "Task") -> Text:
    class ProgressSample(NamedTuple):
    @dataclass
    class Task:
        def get_time(self) -> float:
        @property
        def started(self) -> bool:
        @property
        def remaining(self) -> Optional[float]:
        @property
        def elapsed(self) -> Optional[float]:
        @property
        def finished(self) -> bool:
        @property
        def percentage(self) -> float:
        @property
        def speed(self) -> Optional[float]:
        @property
        def time_remaining(self) -> Optional[float]:
        def _reset(self) -> None:
    class Progress(JupyterMixin):
        def __init__(
        @classmethod
        def get_default_columns(cls) -> Tuple[ProgressColumn, ...]:
        @property
        def console(self) -> Console:
        @property
        def tasks(self) -> List[Task]:
        @property
        def task_ids(self) -> List[TaskID]:
        @property
        def finished(self) -> bool:
        def start(self) -> None:
        def stop(self) -> None:
        def __enter__(self) -> Self:
        def __exit__(
        def track(
        def wrap_file(
        @typing.overload
        def open(
        @typing.overload
        def open(
        def open(
        def start_task(self, task_id: TaskID) -> None:
        def stop_task(self, task_id: TaskID) -> None:
        def update(
        def reset(
        def advance(self, task_id: TaskID, advance: float = 1) -> None:
        def refresh(self) -> None:
        def get_renderable(self) -> RenderableType:
        def get_renderables(self) -> Iterable[RenderableType]:
        def make_tasks_table(self, tasks: Iterable[Task]) -> Table:
        def __rich__(self) -> RenderableType:
        def add_task(
        def remove_task(self, task_id: TaskID) -> None:
        import random
        import time
        from .panel import Panel
        from .rule import Rule
        from .syntax import Syntax
        from .table import Table
        from itertools import cycle

  ðŸ“„ Ð¤Ð°Ð¹Ð»: progress_bar.py
    import math
    from functools import lru_cache
    from time import monotonic
    from typing import Iterable, List, Optional
    from .color import Color, blend_rgb
    from .color_triplet import ColorTriplet
    from .console import Console, ConsoleOptions, RenderResult
    from .jupyter import JupyterMixin
    from .measure import Measurement
    from .segment import Segment
    from .style import Style, StyleType
    PULSE_SIZE = 20
    class ProgressBar(JupyterMixin):
        def __init__(
        def __repr__(self) -> str:
        @property
        def percentage_completed(self) -> Optional[float]:
        @lru_cache(maxsize=16)
        def _get_pulse_segments(
        def update(self, completed: float, total: Optional[float] = None) -> None:
        def _render_pulse(
        def __rich_console__(
        def __rich_measure__(
        import time

  ðŸ“„ Ð¤Ð°Ð¹Ð»: prompt.py
    from typing import Any, Generic, List, Optional, TextIO, TypeVar, Union, overload
    from . import get_console
    from .console import Console
    from .text import Text, TextType
    class PromptError(Exception):
    class InvalidResponse(PromptError):
        def __init__(self, message: TextType) -> None:
        def __rich__(self) -> TextType:
    class PromptBase(Generic[PromptType]):
        def __init__(
        @classmethod
        @overload
        def ask(
        @classmethod
        @overload
        def ask(
        @classmethod
        def ask(
        def render_default(self, default: DefaultType) -> Text:
        def make_prompt(self, default: DefaultType) -> Text:
        @classmethod
        def get_input(
        def check_choice(self, value: str) -> bool:
        def process_response(self, value: str) -> PromptType:
        def on_validate_error(self, value: str, error: InvalidResponse) -> None:
        def pre_prompt(self) -> None:
        @overload
        def __call__(self, *, stream: Optional[TextIO] = None) -> PromptType:
        @overload
        def __call__(
        def __call__(self, *, default: Any = ..., stream: Optional[TextIO] = None) -> Any:
    class Prompt(PromptBase[str]):
    class IntPrompt(PromptBase[int]):
    class FloatPrompt(PromptBase[float]):
    class Confirm(PromptBase[bool]):
        def render_default(self, default: DefaultType) -> Text:
        def process_response(self, value: str) -> bool:
        from pip._vendor.rich import print

  ðŸ“„ Ð¤Ð°Ð¹Ð»: protocol.py
    from typing import Any, cast, Set, TYPE_CHECKING
    from inspect import isclass
        from pip._vendor.rich.console import RenderableType
    _GIBBERISH = """aihwerij235234ljsdnp34ksodfipwoe234234jlskjdf"""
    def is_renderable(check_object: Any) -> bool:
    def rich_cast(renderable: object) -> "RenderableType":
        from pip._vendor.rich.console import RenderableType

  ðŸ“„ Ð¤Ð°Ð¹Ð»: region.py
    from typing import NamedTuple
    class Region(NamedTuple):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: repr.py
    import inspect
    from functools import partial
    from typing import (
    T = TypeVar("T")
    class ReprError(Exception):
    @overload
    def auto(cls: Optional[Type[T]]) -> Type[T]:
    @overload
    def auto(*, angular: bool = False) -> Callable[[Type[T]], Type[T]]:
    def auto(
        def do_replace(cls: Type[T], angular: Optional[bool] = None) -> Type[T]:
            def auto_repr(self: T) -> str:
            def auto_rich_repr(self: Type[T]) -> Result:
    @overload
    def rich_repr(cls: Optional[Type[T]]) -> Type[T]:
    @overload
    def rich_repr(*, angular: bool = False) -> Callable[[Type[T]], Type[T]]:
    def rich_repr(
        @auto
        class Foo:
            def __rich_repr__(self) -> Result:
        from pip._vendor.rich.console import Console

  ðŸ“„ Ð¤Ð°Ð¹Ð»: rule.py
    from typing import Union
    from .align import AlignMethod
    from .cells import cell_len, set_cell_size
    from .console import Console, ConsoleOptions, RenderResult
    from .jupyter import JupyterMixin
    from .measure import Measurement
    from .style import Style
    from .text import Text
    class Rule(JupyterMixin):
        def __init__(
        def __repr__(self) -> str:
        def __rich_console__(
        def _rule_line(self, chars_len: int, width: int) -> Text:
        def __rich_measure__(
        import sys
        from pip._vendor.rich.console import Console

  ðŸ“„ Ð¤Ð°Ð¹Ð»: scope.py
    from collections.abc import Mapping
    from typing import TYPE_CHECKING, Any, Optional, Tuple
    from .highlighter import ReprHighlighter
    from .panel import Panel
    from .pretty import Pretty
    from .table import Table
    from .text import Text, TextType
        from .console import ConsoleRenderable
    def render_scope(
        def sort_items(item: Tuple[str, Any]) -> Tuple[bool, str]:
        from pip._vendor.rich import print
        def test(foo: float, bar: float) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: screen.py
    from typing import Optional, TYPE_CHECKING
    from .segment import Segment
    from .style import StyleType
    from ._loop import loop_last
        from .console import (
    class Screen:
        def __init__(
            from pip._vendor.rich.console import Group
        def __rich_console__(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: segment.py
    from enum import IntEnum
    from functools import lru_cache
    from itertools import filterfalse
    from logging import getLogger
    from operator import attrgetter
    from typing import (
    from .cells import (
    from .repr import Result, rich_repr
    from .style import Style
        from .console import Console, ConsoleOptions, RenderResult
    class ControlType(IntEnum):
        BELL = 1
        CARRIAGE_RETURN = 2
        HOME = 3
        CLEAR = 4
        SHOW_CURSOR = 5
        HIDE_CURSOR = 6
        ENABLE_ALT_SCREEN = 7
        DISABLE_ALT_SCREEN = 8
        CURSOR_UP = 9
        CURSOR_DOWN = 10
        CURSOR_FORWARD = 11
        CURSOR_BACKWARD = 12
        CURSOR_MOVE_TO_COLUMN = 13
        CURSOR_MOVE_TO = 14
        ERASE_IN_LINE = 15
        SET_WINDOW_TITLE = 16
    @rich_repr()
    class Segment(NamedTuple):
        @property
        def cell_length(self) -> int:
        def __rich_repr__(self) -> Result:
        def __bool__(self) -> bool:
        @property
        def is_control(self) -> bool:
        @classmethod
        @lru_cache(1024 * 16)
        def _split_cells(cls, segment: "Segment", cut: int) -> Tuple["Segment", "Segment"]:
        def split_cells(self, cut: int) -> Tuple["Segment", "Segment"]:
        @classmethod
        def line(cls) -> "Segment":
        @classmethod
        def apply_style(
        @classmethod
        def filter_control(
        @classmethod
        def split_lines(cls, segments: Iterable["Segment"]) -> Iterable[List["Segment"]]:
        @classmethod
        def split_and_crop_lines(
        @classmethod
        def adjust_line_length(
        @classmethod
        def get_line_length(cls, line: List["Segment"]) -> int:
        @classmethod
        def get_shape(cls, lines: List[List["Segment"]]) -> Tuple[int, int]:
        @classmethod
        def set_shape(
        @classmethod
        def align_top(
        @classmethod
        def align_bottom(
        @classmethod
        def align_middle(
        @classmethod
        def simplify(cls, segments: Iterable["Segment"]) -> Iterable["Segment"]:
        @classmethod
        def strip_links(cls, segments: Iterable["Segment"]) -> Iterable["Segment"]:
        @classmethod
        def strip_styles(cls, segments: Iterable["Segment"]) -> Iterable["Segment"]:
        @classmethod
        def remove_color(cls, segments: Iterable["Segment"]) -> Iterable["Segment"]:
        @classmethod
        def divide(
    class Segments:
        def __init__(self, segments: Iterable[Segment], new_lines: bool = False) -> None:
        def __rich_console__(
    class SegmentLines:
        def __init__(self, lines: Iterable[List[Segment]], new_lines: bool = False) -> None:
        def __rich_console__(
        from pip._vendor.rich.console import Console
        from pip._vendor.rich.syntax import Syntax
        from pip._vendor.rich.text import Text

  ðŸ“„ Ð¤Ð°Ð¹Ð»: spinner.py
    from typing import cast, List, Optional, TYPE_CHECKING, Union
    from ._spinners import SPINNERS
    from .measure import Measurement
    from .table import Table
    from .text import Text
        from .console import Console, ConsoleOptions, RenderResult, RenderableType
        from .style import StyleType
    class Spinner:
        def __init__(
        def __rich_console__(
        def __rich_measure__(
        def render(self, time: float) -> "RenderableType":
        def update(
        from time import sleep
        from .columns import Columns
        from .panel import Panel
        from .live import Live

  ðŸ“„ Ð¤Ð°Ð¹Ð»: status.py
    from types import TracebackType
    from typing import Optional, Type
    from .console import Console, RenderableType
    from .jupyter import JupyterMixin
    from .live import Live
    from .spinner import Spinner
    from .style import StyleType
    class Status(JupyterMixin):
        def __init__(
        @property
        def renderable(self) -> Spinner:
        @property
        def console(self) -> "Console":
        def update(
        def start(self) -> None:
        def stop(self) -> None:
        def __rich__(self) -> RenderableType:
        def __enter__(self) -> "Status":
        def __exit__(
        from time import sleep
        from .console import Console

  ðŸ“„ Ð¤Ð°Ð¹Ð»: style.py
    import sys
    from functools import lru_cache
    from marshal import dumps, loads
    from random import randint
    from typing import Any, Dict, Iterable, List, Optional, Type, Union, cast
    from . import errors
    from .color import Color, ColorParseError, ColorSystem, blend_rgb
    from .repr import Result, rich_repr
    from .terminal_theme import DEFAULT_TERMINAL_THEME, TerminalTheme
    class _Bit:
        def __init__(self, bit_no: int) -> None:
        def __get__(self, obj: "Style", objtype: Type["Style"]) -> Optional[bool]:
    @rich_repr
    class Style:
        STYLE_ATTRIBUTES = {
        def __init__(
            def _make_color(color: Union[Color, str]) -> Color:
        @classmethod
        def null(cls) -> "Style":
        @classmethod
        def from_color(
        @classmethod
        def from_meta(cls, meta: Optional[Dict[str, Any]]) -> "Style":
        @classmethod
        def on(cls, meta: Optional[Dict[str, Any]] = None, **handlers: Any) -> "Style":
        @property
        def link_id(self) -> str:
        def __str__(self) -> str:
        def __bool__(self) -> bool:
        def _make_ansi_codes(self, color_system: ColorSystem) -> str:
        @classmethod
        @lru_cache(maxsize=1024)
        def normalize(cls, style: str) -> str:
        @classmethod
        def pick_first(cls, *values: Optional[StyleType]) -> StyleType:
        def __rich_repr__(self) -> Result:
        def __eq__(self, other: Any) -> bool:
        def __ne__(self, other: Any) -> bool:
        def __hash__(self) -> int:
        @property
        def color(self) -> Optional[Color]:
        @property
        def bgcolor(self) -> Optional[Color]:
        @property
        def link(self) -> Optional[str]:
        @property
        def transparent_background(self) -> bool:
        @property
        def background_style(self) -> "Style":
        @property
        def meta(self) -> Dict[str, Any]:
        @property
        def without_color(self) -> "Style":
        @classmethod
        @lru_cache(maxsize=4096)
        def parse(cls, style_definition: str) -> "Style":
            STYLE_ATTRIBUTES = cls.STYLE_ATTRIBUTES
        @lru_cache(maxsize=1024)
        def get_html_style(self, theme: Optional[TerminalTheme] = None) -> str:
        @classmethod
        def combine(cls, styles: Iterable["Style"]) -> "Style":
        @classmethod
        def chain(cls, *styles: "Style") -> "Style":
        def copy(self) -> "Style":
        @lru_cache(maxsize=128)
        def clear_meta_and_links(self) -> "Style":
        def update_link(self, link: Optional[str] = None) -> "Style":
        def render(
        def test(self, text: Optional[str] = None) -> None:
        @lru_cache(maxsize=1024)
        def _add(self, style: Optional["Style"]) -> "Style":
        def __add__(self, style: Optional["Style"]) -> "Style":
    NULL_STYLE = Style()
    class StyleStack:
        def __init__(self, default_style: "Style") -> None:
        def __repr__(self) -> str:
        @property
        def current(self) -> Style:
        def push(self, style: Style) -> None:
        def pop(self) -> Style:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: styled.py
    from typing import TYPE_CHECKING
    from .measure import Measurement
    from .segment import Segment
    from .style import StyleType
        from .console import Console, ConsoleOptions, RenderResult, RenderableType
    class Styled:
        def __init__(self, renderable: "RenderableType", style: "StyleType") -> None:
        def __rich_console__(
        def __rich_measure__(
        from pip._vendor.rich import print
        from pip._vendor.rich.panel import Panel

  ðŸ“„ Ð¤Ð°Ð¹Ð»: syntax.py
    import os.path
    import re
    import sys
    import textwrap
    from abc import ABC, abstractmethod
    from pathlib import Path
    from typing import (
    from pip._vendor.pygments.lexer import Lexer
    from pip._vendor.pygments.lexers import get_lexer_by_name, guess_lexer_for_filename
    from pip._vendor.pygments.style import Style as PygmentsStyle
    from pip._vendor.pygments.styles import get_style_by_name
    from pip._vendor.pygments.token import (
    from pip._vendor.pygments.util import ClassNotFound
    from pip._vendor.rich.containers import Lines
    from pip._vendor.rich.padding import Padding, PaddingDimensions
    from ._loop import loop_first
    from .cells import cell_len
    from .color import Color, blend_rgb
    from .console import Console, ConsoleOptions, JustifyMethod, RenderResult
    from .jupyter import JupyterMixin
    from .measure import Measurement
    from .segment import Segment, Segments
    from .style import Style, StyleType
    from .text import Text
    WINDOWS = sys.platform == "win32"
    DEFAULT_THEME = "monokai"
    RICH_SYNTAX_THEMES = {"ansi_light": ANSI_LIGHT, "ansi_dark": ANSI_DARK}
    NUMBERS_COLUMN_DEFAULT_PADDING = 2
    class SyntaxTheme(ABC):
        @abstractmethod
        def get_style_for_token(self, token_type: TokenType) -> Style:
        @abstractmethod
        def get_background_style(self) -> Style:
    class PygmentsSyntaxTheme(SyntaxTheme):
        def __init__(self, theme: Union[str, Type[PygmentsStyle]]) -> None:
        def get_style_for_token(self, token_type: TokenType) -> Style:
        def get_background_style(self) -> Style:
    class ANSISyntaxTheme(SyntaxTheme):
        def __init__(self, style_map: Dict[TokenType, Style]) -> None:
        def get_style_for_token(self, token_type: TokenType) -> Style:
        def get_background_style(self) -> Style:
    class _SyntaxHighlightRange(NamedTuple):
    class Syntax(JupyterMixin):
        @classmethod
        def get_theme(cls, name: Union[str, SyntaxTheme]) -> SyntaxTheme:
        def __init__(
        @classmethod
        def from_path(
        @classmethod
        def guess_lexer(cls, path: str, code: Optional[str] = None) -> str:
        def _get_base_style(self) -> Style:
        def _get_token_color(self, token_type: TokenType) -> Optional[Color]:
        @property
        def lexer(self) -> Optional[Lexer]:
        @property
        def default_lexer(self) -> Lexer:
        def highlight(
                    def line_tokenize() -> Iterable[Tuple[Any, str]]:
                    def tokens_to_spans() -> Iterable[Tuple[str, Optional[Style]]]:
        def stylize_range(
        def _get_line_numbers_color(self, blend: float = 0.3) -> Color:
        @property
        def _numbers_column_width(self) -> int:
        def _get_number_styles(self, console: Console) -> Tuple[Style, Style, Style]:
        def __rich_measure__(
        def __rich_console__(
        def _get_syntax(
        def _apply_stylized_ranges(self, text: Text) -> None:
        def _process_code(self, code: str) -> Tuple[bool, str]:
    def _get_code_index_for_syntax_position(
        import argparse
        import sys
        from pip._vendor.rich.console import Console

  ðŸ“„ Ð¤Ð°Ð¹Ð»: table.py
    from dataclasses import dataclass, field, replace
    from typing import (
    from . import box, errors
    from ._loop import loop_first_last, loop_last
    from ._pick import pick_bool
    from ._ratio import ratio_distribute, ratio_reduce
    from .align import VerticalAlignMethod
    from .jupyter import JupyterMixin
    from .measure import Measurement
    from .padding import Padding, PaddingDimensions
    from .protocol import is_renderable
    from .segment import Segment
    from .style import Style, StyleType
    from .text import Text, TextType
        from .console import (
    @dataclass
    class Column:
        def copy(self) -> "Column":
        @property
        def cells(self) -> Iterable["RenderableType"]:
        @property
        def flexible(self) -> bool:
    @dataclass
    class Row:
    class _Cell(NamedTuple):
    class Table(JupyterMixin):
        def __init__(
        @classmethod
        def grid(
        @property
        def expand(self) -> bool:
        @expand.setter
        def expand(self, expand: bool) -> None:
        @property
        def _extra_width(self) -> int:
        @property
        def row_count(self) -> int:
        def get_row_style(self, console: "Console", index: int) -> StyleType:
        def __rich_measure__(
        @property
        def padding(self) -> Tuple[int, int, int, int]:
        @padding.setter
        def padding(self, padding: PaddingDimensions) -> "Table":
        def add_column(
        def add_row(
            def add_cell(column: Column, renderable: "RenderableType") -> None:
        def add_section(self) -> None:
        def __rich_console__(
            def render_annotation(
        def _calculate_column_widths(
        @classmethod
        def _collapse_widths(
        def _get_cells(
            def get_padding(first_row: bool, last_row: bool) -> Tuple[int, int, int, int]:
        def _get_padding_width(self, column_index: int) -> int:
        def _measure_column(
        def _render(
                def align_cell(
        from pip._vendor.rich.console import Console
        from pip._vendor.rich.highlighter import ReprHighlighter
        from pip._vendor.rich.table import Table as Table
        from ._timer import timer
            def header(text: str) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: terminal_theme.py
    from typing import List, Optional, Tuple
    from .color_triplet import ColorTriplet
    from .palette import Palette
    class TerminalTheme:
        def __init__(
    DEFAULT_TERMINAL_THEME = TerminalTheme(
    MONOKAI = TerminalTheme(
    DIMMED_MONOKAI = TerminalTheme(
    NIGHT_OWLISH = TerminalTheme(
    SVG_EXPORT_THEME = TerminalTheme(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: text.py
    import re
    from functools import partial, reduce
    from math import gcd
    from operator import itemgetter
    from typing import (
    from ._loop import loop_last
    from ._pick import pick_bool
    from ._wrap import divide_line
    from .align import AlignMethod
    from .cells import cell_len, set_cell_size
    from .containers import Lines
    from .control import strip_control_codes
    from .emoji import EmojiVariant
    from .jupyter import JupyterMixin
    from .measure import Measurement
    from .segment import Segment
    from .style import Style, StyleType
        from .console import Console, ConsoleOptions, JustifyMethod, OverflowMethod
    class Span(NamedTuple):
        def __repr__(self) -> str:
        def __bool__(self) -> bool:
        def split(self, offset: int) -> Tuple["Span", Optional["Span"]]:
        def move(self, offset: int) -> "Span":
        def right_crop(self, offset: int) -> "Span":
        def extend(self, cells: int) -> "Span":
    class Text(JupyterMixin):
        def __init__(
        def __len__(self) -> int:
        def __bool__(self) -> bool:
        def __str__(self) -> str:
        def __repr__(self) -> str:
        def __add__(self, other: Any) -> "Text":
        def __eq__(self, other: object) -> bool:
        def __contains__(self, other: object) -> bool:
        def __getitem__(self, slice: Union[int, slice]) -> "Text":
            def get_text_at(offset: int) -> "Text":
        @property
        def cell_len(self) -> int:
        @property
        def markup(self) -> str:
            from .markup import escape
        @classmethod
        def from_markup(
            from .markup import render
        @classmethod
        def from_ansi(
            from .ansi import AnsiDecoder
        @classmethod
        def styled(
        @classmethod
        def assemble(
        @property
        def plain(self) -> str:
        @plain.setter
        def plain(self, new_text: str) -> None:
        @property
        def spans(self) -> List[Span]:
        @spans.setter
        def spans(self, spans: List[Span]) -> None:
        def blank_copy(self, plain: str = "") -> "Text":
        def copy(self) -> "Text":
        def stylize(
        def stylize_before(
        def apply_meta(
        def on(self, meta: Optional[Dict[str, Any]] = None, **handlers: Any) -> "Text":
        def remove_suffix(self, suffix: str) -> None:
        def get_style_at_offset(self, console: "Console", offset: int) -> Style:
        def extend_style(self, spaces: int) -> None:
        def highlight_regex(
        def highlight_words(
        def rstrip(self) -> None:
        def rstrip_end(self, size: int) -> None:
        def set_length(self, new_length: int) -> None:
        def __rich_console__(
        def __rich_measure__(
        def render(self, console: "Console", end: str = "") -> Iterable["Segment"]:
            def get_current_style() -> Style:
        def join(self, lines: Iterable["Text"]) -> "Text":
            def iter_text() -> Iterable["Text"]:
        def expand_tabs(self, tab_size: Optional[int] = None) -> None:
        def truncate(
        def _trim_spans(self) -> None:
        def pad(self, count: int, character: str = " ") -> None:
        def pad_left(self, count: int, character: str = " ") -> None:
        def pad_right(self, count: int, character: str = " ") -> None:
        def align(self, align: AlignMethod, width: int, character: str = " ") -> None:
        def append(
        def append_text(self, text: "Text") -> "Text":
        def append_tokens(
        def copy_styles(self, text: "Text") -> None:
        def split(
                def flatten_spans() -> Iterable[int]:
        def divide(self, offsets: Iterable[int]) -> Lines:
        def right_crop(self, amount: int = 1) -> None:
        def wrap(
        def fit(self, width: int) -> Lines:
        def detect_indentation(self) -> int:
        def with_indent_guides(
        from pip._vendor.rich.console import Console

  ðŸ“„ Ð¤Ð°Ð¹Ð»: theme.py
    import configparser
    from typing import IO, Dict, List, Mapping, Optional
    from .default_styles import DEFAULT_STYLES
    from .style import Style, StyleType
    class Theme:
        def __init__(
        @property
        def config(self) -> str:
        @classmethod
        def from_file(
        @classmethod
        def read(
    class ThemeStackError(Exception):
    class ThemeStack:
        def __init__(self, theme: Theme) -> None:
        def push_theme(self, theme: Theme, inherit: bool = True) -> None:
        def pop_theme(self) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: themes.py
    from .default_styles import DEFAULT_STYLES
    from .theme import Theme
    DEFAULT = Theme(DEFAULT_STYLES)

  ðŸ“„ Ð¤Ð°Ð¹Ð»: traceback.py
    import inspect
    import linecache
    import os
    import sys
    from dataclasses import dataclass, field
    from itertools import islice
    from traceback import walk_tb
    from types import ModuleType, TracebackType
    from typing import (
    from pip._vendor.pygments.lexers import guess_lexer_for_filename
    from pip._vendor.pygments.token import Comment, Keyword, Name, Number, Operator, String
    from pip._vendor.pygments.token import Text as TextToken
    from pip._vendor.pygments.token import Token
    from pip._vendor.pygments.util import ClassNotFound
    from . import pretty
    from ._loop import loop_last
    from .columns import Columns
    from .console import Console, ConsoleOptions, ConsoleRenderable, RenderResult, group
    from .constrain import Constrain
    from .highlighter import RegexHighlighter, ReprHighlighter
    from .panel import Panel
    from .scope import render_scope
    from .style import Style
    from .syntax import Syntax
    from .text import Text
    from .theme import Theme
    WINDOWS = sys.platform == "win32"
    LOCALS_MAX_LENGTH = 10
    LOCALS_MAX_STRING = 80
    def install(
        def excepthook(
        def ipy_excepthook_closure(ip: Any) -> None:  # pragma: no cover
            def ipy_show_traceback(*args: Any, **kwargs: Any) -> None:
            def ipy_display_traceback(
    @dataclass
    class Frame:
    @dataclass
    class _SyntaxError:
    @dataclass
    class Stack:
    @dataclass
    class Trace:
    class PathHighlighter(RegexHighlighter):
    class Traceback:
        LEXERS = {
        def __init__(
        @classmethod
        def from_exception(
        @classmethod
        def extract(
            from pip._vendor.rich import _IMPORT_CWD
            def safe_str(_object: Any) -> str:
                def get_locals(
        def __rich_console__(
        @group()
        def _render_syntax_error(self, syntax_error: _SyntaxError) -> RenderResult:
        @classmethod
        def _guess_lexer(cls, filename: str, code: str) -> str:
        @group()
        def _render_stack(self, stack: Stack) -> RenderResult:
            def read_code(filename: str) -> str:
            def render_locals(frame: Frame) -> Iterable[ConsoleRenderable]:
        import sys
        def bar(
        def foo(a: Any) -> None:
        def error() -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: tree.py
    from typing import Iterator, List, Optional, Tuple
    from ._loop import loop_first, loop_last
    from .console import Console, ConsoleOptions, RenderableType, RenderResult
    from .jupyter import JupyterMixin
    from .measure import Measurement
    from .segment import Segment
    from .style import Style, StyleStack, StyleType
    from .styled import Styled
    class Tree(JupyterMixin):
        ASCII_GUIDES = ("    ", "|   ", "+-- ", "`-- ")
        TREE_GUIDES = [
        def __init__(
        def add(
        def __rich_console__(
            def make_guide(index: int, style: Style) -> Segment:
        def __rich_measure__(
        from pip._vendor.rich.console import Group
        from pip._vendor.rich.markdown import Markdown
        from pip._vendor.rich.panel import Panel
        from pip._vendor.rich.syntax import Syntax
        from pip._vendor.rich.table import Table
    class Segment(NamedTuple):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _cell_widths.py
    CELL_WIDTHS = [

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _emoji_codes.py
    EMOJI = {

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _emoji_replace.py
    from typing import Callable, Match, Optional
    import re
    from ._emoji_codes import EMOJI
    def _emoji_replace(
        def do_replace(match: Match[str]) -> str:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _export_format.py
    CONSOLE_HTML_FORMAT = """\
    CONSOLE_SVG_FORMAT = """\
        @font-face {{
        @font-face {{
    _SVG_FONT_FAMILY = "Rich Fira Code"
    _SVG_CLASSES_PREFIX = "rich-svg"

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _extension.py
    from typing import Any
    def load_ipython_extension(ip: Any) -> None:  # pragma: no cover
        from pip._vendor.rich.pretty import install
        from pip._vendor.rich.traceback import install as tr_install

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _fileno.py
    from __future__ import annotations
    from typing import IO, Callable
    def get_fileno(file_like: IO[str]) -> int | None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _inspect.py
    import inspect
    from inspect import cleandoc, getdoc, getfile, isclass, ismodule, signature
    from typing import Any, Collection, Iterable, Optional, Tuple, Type, Union
    from .console import Group, RenderableType
    from .control import escape_control_codes
    from .highlighter import ReprHighlighter
    from .jupyter import JupyterMixin
    from .panel import Panel
    from .pretty import Pretty
    from .table import Table
    from .text import Text, TextType
    def _first_paragraph(doc: str) -> str:
    class Inspect(JupyterMixin):
        def __init__(
        def _make_title(self, obj: Any) -> Text:
        def __rich__(self) -> Panel:
        def _get_signature(self, name: str, obj: Any) -> Optional[Text]:
        def _render(self) -> Iterable[RenderableType]:
            def sort_items(item: Tuple[str, Any]) -> Tuple[bool, str]:
            def safe_getattr(attr_name: str) -> Tuple[Any, Any]:
        def _get_formatted_doc(self, object_: Any) -> Optional[str]:
    def get_object_types_mro(obj: Union[object, Type[Any]]) -> Tuple[type, ...]:
    def get_object_types_mro_as_strings(obj: object) -> Collection[str]:
    def is_object_one_of_types(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _log_render.py
    from datetime import datetime
    from typing import Iterable, List, Optional, TYPE_CHECKING, Union, Callable
    from .text import Text, TextType
        from .console import Console, ConsoleRenderable, RenderableType
        from .table import Table
    class LogRender:
        def __init__(
        def __call__(
            from .containers import Renderables
            from .table import Table
        from pip._vendor.rich.console import Console

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _loop.py
    from typing import Iterable, Tuple, TypeVar
    T = TypeVar("T")
    def loop_first(values: Iterable[T]) -> Iterable[Tuple[bool, T]]:
    def loop_last(values: Iterable[T]) -> Iterable[Tuple[bool, T]]:
    def loop_first_last(values: Iterable[T]) -> Iterable[Tuple[bool, bool, T]]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _null_file.py
    from types import TracebackType
    from typing import IO, Iterable, Iterator, List, Optional, Type
    class NullFile(IO[str]):
        def close(self) -> None:
        def isatty(self) -> bool:
        def read(self, __n: int = 1) -> str:
        def readable(self) -> bool:
        def readline(self, __limit: int = 1) -> str:
        def readlines(self, __hint: int = 1) -> List[str]:
        def seek(self, __offset: int, __whence: int = 1) -> int:
        def seekable(self) -> bool:
        def tell(self) -> int:
        def truncate(self, __size: Optional[int] = 1) -> int:
        def writable(self) -> bool:
        def writelines(self, __lines: Iterable[str]) -> None:
        def __next__(self) -> str:
        def __iter__(self) -> Iterator[str]:
        def __enter__(self) -> IO[str]:
        def __exit__(
        def write(self, text: str) -> int:
        def flush(self) -> None:
        def fileno(self) -> int:
    NULL_FILE = NullFile()

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _palettes.py
    from .palette import Palette
    WINDOWS_PALETTE = Palette(
    STANDARD_PALETTE = Palette(
    EIGHT_BIT_PALETTE = Palette(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _pick.py
    from typing import Optional
    def pick_bool(*values: Optional[bool]) -> bool:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _ratio.py
    import sys
    from fractions import Fraction
    from math import ceil
    from typing import cast, List, Optional, Sequence
        from typing import Protocol
        from pip._vendor.typing_extensions import Protocol  # pragma: no cover
    class Edge(Protocol):
    def ratio_resolve(total: int, edges: Sequence[Edge]) -> List[int]:
    def ratio_reduce(
    def ratio_distribute(
        from dataclasses import dataclass
        @dataclass
        class E:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _spinners.py
    SPINNERS = {

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _stack.py
    from typing import List, TypeVar
    T = TypeVar("T")
    class Stack(List[T]):
        @property
        def top(self) -> T:
        def push(self, item: T) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _timer.py
    from time import time
    import contextlib
    from typing import Generator
    @contextlib.contextmanager
    def timer(subject: str = "time") -> Generator[None, None, None]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _win32_console.py
    import ctypes
    import sys
    from typing import Any
    import time
    from ctypes import Structure, byref, wintypes
    from typing import IO, NamedTuple, Type, cast
    from pip._vendor.rich.color import ColorSystem
    from pip._vendor.rich.style import Style
    STDOUT = -11
    ENABLE_VIRTUAL_TERMINAL_PROCESSING = 4
    COORD = wintypes._COORD
    class LegacyWindowsError(Exception):
    class WindowsCoordinates(NamedTuple):
        @classmethod
        def from_param(cls, value: "WindowsCoordinates") -> COORD:
    class CONSOLE_SCREEN_BUFFER_INFO(Structure):
    class CONSOLE_CURSOR_INFO(ctypes.Structure):
    def GetStdHandle(handle: int = STDOUT) -> wintypes.HANDLE:
    def GetConsoleMode(std_handle: wintypes.HANDLE) -> int:
    def FillConsoleOutputCharacter(
    def FillConsoleOutputAttribute(
    def SetConsoleTextAttribute(
    def GetConsoleScreenBufferInfo(
    def SetConsoleCursorPosition(
    def GetConsoleCursorInfo(
    def SetConsoleCursorInfo(
    def SetConsoleTitle(title: str) -> bool:
    class LegacyWindowsTerm:
        BRIGHT_BIT = 8
        ANSI_TO_WINDOWS = [
        def __init__(self, file: "IO[str]") -> None:
        @property
        def cursor_position(self) -> WindowsCoordinates:
        @property
        def screen_size(self) -> WindowsCoordinates:
        def write_text(self, text: str) -> None:
        def write_styled(self, text: str, style: Style) -> None:
        def move_cursor_to(self, new_position: WindowsCoordinates) -> None:
        def erase_line(self) -> None:
        def erase_end_of_line(self) -> None:
        def erase_start_of_line(self) -> None:
        def move_cursor_up(self) -> None:
        def move_cursor_down(self) -> None:
        def move_cursor_forward(self) -> None:
        def move_cursor_to_column(self, column: int) -> None:
        def move_cursor_backward(self) -> None:
        def hide_cursor(self) -> None:
        def show_cursor(self) -> None:
        def set_title(self, title: str) -> None:
        def _get_cursor_size(self) -> int:
        from pip._vendor.rich.console import Console

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _windows.py
    import sys
    from dataclasses import dataclass
    @dataclass
    class WindowsConsoleFeatures:
        import ctypes
        from ctypes import LibraryLoader
        from pip._vendor.rich._win32_console import (
        def get_windows_console_features() -> WindowsConsoleFeatures:
        def get_windows_console_features() -> WindowsConsoleFeatures:
        import platform
        from pip._vendor.rich import print

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _windows_renderer.py
    from typing import Iterable, Sequence, Tuple, cast
    from pip._vendor.rich._win32_console import LegacyWindowsTerm, WindowsCoordinates
    from pip._vendor.rich.segment import ControlCode, ControlType, Segment
    def legacy_windows_render(buffer: Iterable[Segment], term: LegacyWindowsTerm) -> None:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _wrap.py
    from __future__ import annotations
    import re
    from typing import Iterable
    from ._loop import loop_last
    from .cells import cell_len, chop_cells
    def words(text: str) -> Iterable[tuple[int, int, str]]:
    def divide_line(text: str, width: int, fold: bool = True) -> list[int]:
        from .console import Console

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    import os
    from typing import IO, TYPE_CHECKING, Any, Callable, Optional, Union
    from ._extension import load_ipython_extension  # noqa: F401
        from .console import Console
        _IMPORT_CWD = os.path.abspath(os.getcwd())
        _IMPORT_CWD = ""
    def get_console() -> "Console":
            from .console import Console
    def reconfigure(*args: Any, **kwargs: Any) -> None:
        from pip._vendor.rich.console import Console
    def print(
        from .console import Console
    def print_json(
    def inspect(
        from pip._vendor.rich._inspect import Inspect

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __main__.py
    import colorsys
    import io
    from time import process_time
    from pip._vendor.rich import box
    from pip._vendor.rich.color import Color
    from pip._vendor.rich.console import Console, ConsoleOptions, Group, RenderableType, RenderResult
    from pip._vendor.rich.markdown import Markdown
    from pip._vendor.rich.measure import Measurement
    from pip._vendor.rich.pretty import Pretty
    from pip._vendor.rich.segment import Segment
    from pip._vendor.rich.style import Style
    from pip._vendor.rich.syntax import Syntax
    from pip._vendor.rich.table import Table
    from pip._vendor.rich.text import Text
    class ColorBox:
        def __rich_console__(
        def __rich_measure__(
    def make_test_card() -> Table:
        def comparison(renderable1: RenderableType, renderable2: RenderableType) -> Table:
    def iter_last(values: Iterable[T]) -> Iterable[Tuple[bool, T]]:
        from pip._vendor.rich.panel import Panel

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\tomli

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _parser.py
    from __future__ import annotations
    from collections.abc import Iterable
    import string
    import sys
    from types import MappingProxyType
    from typing import IO, Any, Final, NamedTuple
    import warnings
    from ._re import (
    from ._types import Key, ParseFloat, Pos
    class DEPRECATED_DEFAULT:
    class TOMLDecodeError(ValueError):
        def __init__(
    def load(__fp: IO[bytes], *, parse_float: ParseFloat = float) -> dict[str, Any]:
    def loads(__s: str, *, parse_float: ParseFloat = float) -> dict[str, Any]:  # noqa: C901
    class Flags:
        def __init__(self) -> None:
        def add_pending(self, key: Key, flag: int) -> None:
        def finalize_pending(self) -> None:
        def unset_all(self, key: Key) -> None:
        def set(self, key: Key, flag: int, *, recursive: bool) -> None:  # noqa: A003
        def is_(self, key: Key, flag: int) -> bool:
    class NestedDict:
        def __init__(self) -> None:
        def get_or_create_nest(
        def append_nest_to_list(self, key: Key) -> None:
    class Output(NamedTuple):
    def skip_chars(src: str, pos: Pos, chars: Iterable[str]) -> Pos:
    def skip_until(
    def skip_comment(src: str, pos: Pos) -> Pos:
    def skip_comments_and_array_ws(src: str, pos: Pos) -> Pos:
    def create_dict_rule(src: str, pos: Pos, out: Output) -> tuple[Pos, Key]:
    def create_list_rule(src: str, pos: Pos, out: Output) -> tuple[Pos, Key]:
    def key_value_rule(
    def parse_key_value_pair(
    def parse_key(src: str, pos: Pos) -> tuple[Pos, Key]:
    def parse_key_part(src: str, pos: Pos) -> tuple[Pos, str]:
    def parse_one_line_basic_str(src: str, pos: Pos) -> tuple[Pos, str]:
    def parse_array(
    def parse_inline_table(
    def parse_basic_str_escape(
    def parse_basic_str_escape_multiline(src: str, pos: Pos) -> tuple[Pos, str]:
    def parse_hex_char(src: str, pos: Pos, hex_len: int) -> tuple[Pos, str]:
    def parse_literal_str(src: str, pos: Pos) -> tuple[Pos, str]:
    def parse_multiline_str(src: str, pos: Pos, *, literal: bool) -> tuple[Pos, str]:
    def parse_basic_str(src: str, pos: Pos, *, multiline: bool) -> tuple[Pos, str]:
    def parse_value(  # noqa: C901
    def is_unicode_scalar_value(codepoint: int) -> bool:
    def make_safe_parse_float(parse_float: ParseFloat) -> ParseFloat:
        def safe_parse_float(float_str: str) -> Any:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _re.py
    from __future__ import annotations
    from datetime import date, datetime, time, timedelta, timezone, tzinfo
    from functools import lru_cache
    import re
    from typing import Any, Final
    from ._types import ParseFloat
    def match_to_datetime(match: re.Match) -> datetime | date:
    @lru_cache(maxsize=None)
    def cached_tz(hour_str: str, minute_str: str, sign_str: str) -> timezone:
    def match_to_localtime(match: re.Match) -> time:
    def match_to_number(match: re.Match, parse_float: ParseFloat) -> Any:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _types.py
    from typing import Any, Callable, Tuple

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from ._parser import TOMLDecodeError, load, loads

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\truststore

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _api.py
    import os
    import platform
    import socket
    import ssl
    import sys
    import typing
    import _ssl  # type: ignore[import-not-found]
    from ._ssl_constants import (
        from ._windows import _configure_context, _verify_peercerts_impl
        from ._macos import _configure_context, _verify_peercerts_impl
        from ._openssl import _configure_context, _verify_peercerts_impl
        from pip._vendor.typing_extensions import Buffer
    def inject_into_ssl() -> None:
            import pip._vendor.urllib3.util.ssl_ as urllib3_ssl
    def extract_from_ssl() -> None:
            import pip._vendor.urllib3.util.ssl_ as urllib3_ssl
    class SSLContext(_truststore_SSLContext_super_class):  # type: ignore[misc]
        @property  # type: ignore[misc]
        def __class__(self) -> type:
        def __init__(self, protocol: int = None) -> None:  # type: ignore[assignment]
            class TruststoreSSLObject(ssl.SSLObject):
                def do_handshake(self) -> None:
        def wrap_socket(
        def wrap_bio(
        def load_verify_locations(
        def load_cert_chain(
        def load_default_certs(
        def set_alpn_protocols(self, alpn_protocols: typing.Iterable[str]) -> None:
        def set_npn_protocols(self, npn_protocols: typing.Iterable[str]) -> None:
        def set_ciphers(self, __cipherlist: str) -> None:
        def get_ciphers(self) -> typing.Any:
        def session_stats(self) -> dict[str, int]:
        def cert_store_stats(self) -> dict[str, int]:
        def set_default_verify_paths(self) -> None:
        @typing.overload
        def get_ca_certs(
        @typing.overload
        def get_ca_certs(self, binary_form: typing.Literal[True] = ...) -> list[bytes]: ...
        @typing.overload
        def get_ca_certs(self, binary_form: bool = ...) -> typing.Any: ...
        def get_ca_certs(self, binary_form: bool = False) -> list[typing.Any] | list[bytes]:
        @property
        def check_hostname(self) -> bool:
        @check_hostname.setter
        def check_hostname(self, value: bool) -> None:
        @property
        def hostname_checks_common_name(self) -> bool:
        @hostname_checks_common_name.setter
        def hostname_checks_common_name(self, value: bool) -> None:
        @property
        def keylog_filename(self) -> str:
        @keylog_filename.setter
        def keylog_filename(self, value: str) -> None:
        @property
        def maximum_version(self) -> ssl.TLSVersion:
        @maximum_version.setter
        def maximum_version(self, value: ssl.TLSVersion) -> None:
        @property
        def minimum_version(self) -> ssl.TLSVersion:
        @minimum_version.setter
        def minimum_version(self, value: ssl.TLSVersion) -> None:
        @property
        def options(self) -> ssl.Options:
        @options.setter
        def options(self, value: ssl.Options) -> None:
        @property
        def post_handshake_auth(self) -> bool:
        @post_handshake_auth.setter
        def post_handshake_auth(self, value: bool) -> None:
        @property
        def protocol(self) -> ssl._SSLMethod:
        @property
        def security_level(self) -> int:
        @property
        def verify_flags(self) -> ssl.VerifyFlags:
        @verify_flags.setter
        def verify_flags(self, value: ssl.VerifyFlags) -> None:
        @property
        def verify_mode(self) -> ssl.VerifyMode:
        @verify_mode.setter
        def verify_mode(self, value: ssl.VerifyMode) -> None:
        def _get_unverified_chain_bytes(sslobj: ssl.SSLObject) -> list[bytes]:
        def _get_unverified_chain_bytes(sslobj: ssl.SSLObject) -> list[bytes]:
    def _verify_peercerts(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _macos.py
    import contextlib
    import ctypes
    import platform
    import ssl
    import typing
    from ctypes import (
    from ctypes.util import find_library
    from ._ssl_constants import _set_ssl_context_verify_mode
    def _load_cdll(name: str, macos10_16_path: str) -> CDLL:
    def _handle_osstatus(result: OSStatus, _: typing.Any, args: typing.Any) -> typing.Any:
    class CFConst:
    def _bytes_to_cf_data_ref(value: bytes) -> CFDataRef:  # type: ignore[valid-type]
    def _bytes_to_cf_string(value: bytes) -> CFString:
    def _cf_string_ref_to_str(cf_string_ref: CFStringRef) -> str | None:  # type: ignore[valid-type]
    def _der_certs_to_cf_cert_array(certs: list[bytes]) -> CFMutableArrayRef:  # type: ignore[valid-type]
    @contextlib.contextmanager
    def _configure_context(ctx: ssl.SSLContext) -> typing.Iterator[None]:
    def _verify_peercerts_impl(
    def _verify_peercerts_impl_macos_10_13(
    def _verify_peercerts_impl_macos_10_14(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _openssl.py
    import contextlib
    import os
    import re
    import ssl
    import typing
    _CA_FILE_CANDIDATES = [
    _HASHED_CERT_FILENAME_RE = re.compile(r"^[0-9a-fA-F]{8}\.[0-9]$")
    @contextlib.contextmanager
    def _configure_context(ctx: ssl.SSLContext) -> typing.Iterator[None]:
    def _capath_contains_certs(capath: str) -> bool:
    def _verify_peercerts_impl(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _ssl_constants.py
    import ssl
    import sys
    import typing
    def _set_ssl_context_verify_mode(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _windows.py
    import contextlib
    import ssl
    import typing
    from ctypes import WinDLL  # type: ignore
    from ctypes import WinError  # type: ignore
    from ctypes import (
    from ctypes.wintypes import (
    from typing import TYPE_CHECKING, Any
    from ._ssl_constants import _set_ssl_context_verify_mode
    HCERTCHAINENGINE = HANDLE
    HCERTSTORE = HANDLE
    HCRYPTPROV_LEGACY = HANDLE
    class CERT_CONTEXT(Structure):
    PCERT_CONTEXT = POINTER(CERT_CONTEXT)
    PCCERT_CONTEXT = POINTER(PCERT_CONTEXT)
    class CERT_ENHKEY_USAGE(Structure):
    PCERT_ENHKEY_USAGE = POINTER(CERT_ENHKEY_USAGE)
    class CERT_USAGE_MATCH(Structure):
    class CERT_CHAIN_PARA(Structure):
        PCERT_CHAIN_PARA = pointer[CERT_CHAIN_PARA]  # type: ignore[misc]
        PCERT_CHAIN_PARA = POINTER(CERT_CHAIN_PARA)
    class CERT_TRUST_STATUS(Structure):
    class CERT_CHAIN_ELEMENT(Structure):
    PCERT_CHAIN_ELEMENT = POINTER(CERT_CHAIN_ELEMENT)
    class CERT_SIMPLE_CHAIN(Structure):
    PCERT_SIMPLE_CHAIN = POINTER(CERT_SIMPLE_CHAIN)
    class CERT_CHAIN_CONTEXT(Structure):
    PCERT_CHAIN_CONTEXT = POINTER(CERT_CHAIN_CONTEXT)
    PCCERT_CHAIN_CONTEXT = POINTER(PCERT_CHAIN_CONTEXT)
    class SSL_EXTRA_CERT_CHAIN_POLICY_PARA(Structure):
    class CERT_CHAIN_POLICY_PARA(Structure):
    PCERT_CHAIN_POLICY_PARA = POINTER(CERT_CHAIN_POLICY_PARA)
    class CERT_CHAIN_POLICY_STATUS(Structure):
    PCERT_CHAIN_POLICY_STATUS = POINTER(CERT_CHAIN_POLICY_STATUS)
    class CERT_CHAIN_ENGINE_CONFIG(Structure):
    PCERT_CHAIN_ENGINE_CONFIG = POINTER(CERT_CHAIN_ENGINE_CONFIG)
    PHCERTCHAINENGINE = POINTER(HCERTCHAINENGINE)
    CERT_STORE_PROV_MEMORY = b"Memory"
    CERT_STORE_ADD_USE_EXISTING = 2
    USAGE_MATCH_TYPE_OR = 1
    OID_PKIX_KP_SERVER_AUTH = c_char_p(b"1.3.6.1.5.5.7.3.1")
    CERT_CHAIN_REVOCATION_CHECK_END_CERT = 0x10000000
    CERT_CHAIN_REVOCATION_CHECK_CHAIN = 0x20000000
    CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS = 0x00000007
    CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG = 0x00000008
    CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG = 0x00000010
    CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG = 0x00000040
    CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG = 0x00000020
    CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG = 0x00000080
    CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS = 0x00000F00
    CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG = 0x00008000
    CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG = 0x00004000
    SECURITY_FLAG_IGNORE_CERT_CN_INVALID = 0x00001000
    AUTHTYPE_SERVER = 2
    CERT_CHAIN_POLICY_SSL = 4
    FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000
    FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200
    CERT_CHAIN_POLICY_VERIFY_MODE_NONE_FLAGS = (
    def _handle_win_error(result: bool, _: Any, args: Any) -> Any:
    def _verify_peercerts_impl(
    def _get_and_verify_cert_chain(
    def _verify_using_custom_ca_certs(
    @contextlib.contextmanager
    def _configure_context(ctx: ssl.SSLContext) -> typing.Iterator[None]:

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    import sys as _sys
            import ssl as _ssl
    from ._api import SSLContext, extract_from_ssl, inject_into_ssl  # noqa: E402

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\urllib3

  ðŸ“„ Ð¤Ð°Ð¹Ð»: connection.py
    from __future__ import absolute_import
    import datetime
    import logging
    import os
    import re
    import socket
    import warnings
    from socket import error as SocketError
    from socket import timeout as SocketTimeout
    from .packages import six
    from .packages.six.moves.http_client import HTTPConnection as _HTTPConnection
    from .packages.six.moves.http_client import HTTPException  # noqa: F401
    from .util.proxy import create_proxy_ssl_context
        import ssl
        class BaseSSLError(BaseException):
        class ConnectionError(Exception):
        class BrokenPipeError(Exception):
    from ._collections import HTTPHeaderDict  # noqa (historical, removed in v2)
    from ._version import __version__
    from .exceptions import (
    from .util import SKIP_HEADER, SKIPPABLE_HEADERS, connection
    from .util.ssl_ import (
    from .util.ssl_match_hostname import CertificateError, match_hostname
    RECENT_DATE = datetime.date(2024, 1, 1)
    _CONTAINS_CONTROL_CHAR_RE = re.compile(r"[^-!#$%&'*+.^_`|~0-9a-zA-Z]")
    class HTTPConnection(_HTTPConnection, object):
        def __init__(self, *args, **kw):
        @property
        def host(self):
        @host.setter
        def host(self, value):
        def _new_conn(self):
        def _is_using_tunnel(self):
        def _prepare_conn(self, conn):
        def connect(self):
        def putrequest(self, method, url, *args, **kwargs):
        def putheader(self, header, *values):
        def request(self, method, url, body=None, headers=None):
        def request_chunked(self, method, url, body=None, headers=None):
    class HTTPSConnection(HTTPConnection):
        def __init__(
        def set_cert(
        def connect(self):
        def _connect_tls_proxy(self, hostname, conn):
    def _match_hostname(cert, asserted_hostname):
    def _get_default_user_agent():
    class DummyConnection(object):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: connectionpool.py
    from __future__ import absolute_import
    import errno
    import logging
    import re
    import socket
    import sys
    import warnings
    from socket import error as SocketError
    from socket import timeout as SocketTimeout
    from ._collections import HTTPHeaderDict
    from .connection import (
    from .exceptions import (
    from .packages import six
    from .packages.six.moves import queue
    from .request import RequestMethods
    from .response import HTTPResponse
    from .util.connection import is_connection_dropped
    from .util.proxy import connection_requires_http_tunnel
    from .util.queue import LifoQueue
    from .util.request import set_file_position
    from .util.response import assert_header_parsing
    from .util.retry import Retry
    from .util.ssl_match_hostname import CertificateError
    from .util.timeout import Timeout
    from .util.url import Url, _encode_target
    from .util.url import _normalize_host as normalize_host
    from .util.url import get_host, parse_url
        import weakref
        from .packages.backports.weakref_finalize import weakref_finalize
    class ConnectionPool(object):
        def __init__(self, host, port=None):
        def __str__(self):
        def __enter__(self):
        def __exit__(self, exc_type, exc_val, exc_tb):
        def close(self):
    class HTTPConnectionPool(ConnectionPool, RequestMethods):
        def __init__(
        def _new_conn(self):
        def _get_conn(self, timeout=None):
        def _put_conn(self, conn):
        def _validate_conn(self, conn):
        def _prepare_proxy(self, conn):
        def _get_timeout(self, timeout):
        def _raise_timeout(self, err, url, timeout_value):
        def _make_request(
        def _absolute_url(self, path):
        def close(self):
        def is_same_host(self, url):
        def urlopen(
                def _is_ssl_error_message_from_http_proxy(ssl_error):
    class HTTPSConnectionPool(HTTPConnectionPool):
        def __init__(
        def _prepare_conn(self, conn):
        def _prepare_proxy(self, conn):
        def _new_conn(self):
        def _validate_conn(self, conn):
    def connection_from_url(url, **kw):
    def _normalize_host(host, scheme):
    def _close_pool_connections(pool):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: exceptions.py
    from __future__ import absolute_import
    from .packages.six.moves.http_client import IncompleteRead as httplib_IncompleteRead
    class HTTPError(Exception):
    class HTTPWarning(Warning):
    class PoolError(HTTPError):
        def __init__(self, pool, message):
        def __reduce__(self):
    class RequestError(PoolError):
        def __init__(self, pool, url, message):
        def __reduce__(self):
    class SSLError(HTTPError):
    class ProxyError(HTTPError):
        def __init__(self, message, error, *args):
    class DecodeError(HTTPError):
    class ProtocolError(HTTPError):
    class MaxRetryError(RequestError):
        def __init__(self, pool, url, reason=None):
    class HostChangedError(RequestError):
        def __init__(self, pool, url, retries=3):
    class TimeoutStateError(HTTPError):
    class TimeoutError(HTTPError):
    class ReadTimeoutError(TimeoutError, RequestError):
    class ConnectTimeoutError(TimeoutError):
    class NewConnectionError(ConnectTimeoutError, PoolError):
    class EmptyPoolError(PoolError):
    class ClosedPoolError(PoolError):
    class LocationValueError(ValueError, HTTPError):
    class LocationParseError(LocationValueError):
        def __init__(self, location):
    class URLSchemeUnknown(LocationValueError):
        def __init__(self, scheme):
    class ResponseError(HTTPError):
        GENERIC_ERROR = "too many error responses"
        SPECIFIC_ERROR = "too many {status_code} error responses"
    class SecurityWarning(HTTPWarning):
    class SubjectAltNameWarning(SecurityWarning):
    class InsecureRequestWarning(SecurityWarning):
    class SystemTimeWarning(SecurityWarning):
    class InsecurePlatformWarning(SecurityWarning):
    class SNIMissingWarning(HTTPWarning):
    class DependencyWarning(HTTPWarning):
    class ResponseNotChunked(ProtocolError, ValueError):
    class BodyNotHttplibCompatible(HTTPError):
    class IncompleteRead(HTTPError, httplib_IncompleteRead):
        def __init__(self, partial, expected):
        def __repr__(self):
    class InvalidChunkLength(HTTPError, httplib_IncompleteRead):
        def __init__(self, response, length):
        def __repr__(self):
    class InvalidHeader(HTTPError):
    class ProxySchemeUnknown(AssertionError, URLSchemeUnknown):
        def __init__(self, scheme):
    class ProxySchemeUnsupported(ValueError):
    class HeaderParsingError(HTTPError):
        def __init__(self, defects, unparsed_data):
    class UnrewindableBodyError(HTTPError):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: fields.py
    from __future__ import absolute_import
    import email.utils
    import mimetypes
    import re
    from .packages import six
    def guess_content_type(filename, default="application/octet-stream"):
    def format_header_param_rfc2231(name, value):
    def _replace_multiple(value, needles_and_replacements):
        def replacer(match):
    def format_header_param_html5(name, value):
    class RequestField(object):
        def __init__(
        @classmethod
        def from_tuples(cls, fieldname, value, header_formatter=format_header_param_html5):
        def _render_part(self, name, value):
        def _render_parts(self, header_parts):
        def render_headers(self):
        def make_multipart(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: filepost.py
    from __future__ import absolute_import
    import binascii
    import codecs
    import os
    from io import BytesIO
    from .fields import RequestField
    from .packages import six
    from .packages.six import b
    def choose_boundary():
    def iter_field_objects(fields):
    def iter_fields(fields):
    def encode_multipart_formdata(fields, boundary=None):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: poolmanager.py
    from __future__ import absolute_import
    import collections
    import functools
    import logging
    from ._collections import HTTPHeaderDict, RecentlyUsedContainer
    from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool, port_by_scheme
    from .exceptions import (
    from .packages import six
    from .packages.six.moves.urllib.parse import urljoin
    from .request import RequestMethods
    from .util.proxy import connection_requires_http_tunnel
    from .util.retry import Retry
    from .util.url import parse_url
    SSL_KEYWORDS = (
    def _default_key_normalizer(key_class, request_context):
    class PoolManager(RequestMethods):
        def __init__(self, num_pools=10, headers=None, **connection_pool_kw):
        def __enter__(self):
        def __exit__(self, exc_type, exc_val, exc_tb):
        def _new_pool(self, scheme, host, port, request_context=None):
        def clear(self):
        def connection_from_host(self, host, port=None, scheme="http", pool_kwargs=None):
        def connection_from_context(self, request_context):
        def connection_from_pool_key(self, pool_key, request_context=None):
        def connection_from_url(self, url, pool_kwargs=None):
        def _merge_pool_kwargs(self, override):
        def _proxy_requires_url_absolute_form(self, parsed_url):
        def _validate_proxy_scheme_url_selection(self, url_scheme):
        def urlopen(self, method, url, redirect=True, **kw):
    class ProxyManager(PoolManager):
        def __init__(
        def connection_from_host(self, host, port=None, scheme="http", pool_kwargs=None):
        def _set_proxy_headers(self, url, headers=None):
        def urlopen(self, method, url, redirect=True, **kw):
    def proxy_from_url(url, **kw):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: request.py
    from __future__ import absolute_import
    import sys
    from .filepost import encode_multipart_formdata
    from .packages import six
    from .packages.six.moves.urllib.parse import urlencode
    class RequestMethods(object):
        def __init__(self, headers=None):
        def urlopen(
        def request(self, method, url, fields=None, headers=None, **urlopen_kw):
        def request_encode_url(self, method, url, fields=None, headers=None, **urlopen_kw):
        def request_encode_body(
        class RequestModule(sys.modules[__name__].__class__):
            def __call__(self, *args, **kwargs):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: response.py
    from __future__ import absolute_import
    import io
    import logging
    import sys
    import warnings
    import zlib
    from contextlib import contextmanager
    from socket import error as SocketError
    from socket import timeout as SocketTimeout
    from . import util
    from ._collections import HTTPHeaderDict
    from .connection import BaseSSLError, HTTPException
    from .exceptions import (
    from .packages import six
    from .util.response import is_fp_closed, is_response_to_head
    class DeflateDecoder(object):
        def __init__(self):
        def __getattr__(self, name):
        def decompress(self, data):
    class GzipDecoderState(object):
        FIRST_MEMBER = 0
        OTHER_MEMBERS = 1
        SWALLOW_DATA = 2
    class GzipDecoder(object):
        def __init__(self):
        def __getattr__(self, name):
        def decompress(self, data):
        class BrotliDecoder(object):
            def __init__(self):
            def flush(self):
    class MultiDecoder(object):
        def __init__(self, modes):
        def flush(self):
        def decompress(self, data):
    def _get_decoder(mode):
    class HTTPResponse(io.IOBase):
        class is also compatible with the Python standard library's :mod:`io`
        CONTENT_DECODERS = ["gzip", "deflate"]
        REDIRECT_STATUSES = [301, 302, 303, 307, 308]
        def __init__(
        def get_redirect_location(self):
        def release_conn(self):
        def drain_conn(self):
        @property
        def data(self):
        @property
        def connection(self):
        def isclosed(self):
        def tell(self):
        def _init_length(self, request_method):
        def _init_decoder(self):
        DECODER_ERROR_CLASSES = (IOError, zlib.error)
        def _decode(self, data, decode_content, flush_decoder):
        def _flush_decoder(self):
        @contextmanager
        def _error_catcher(self):
        def _fp_read(self, amt):
        def read(self, amt=None, decode_content=None, cache_content=False):
        def stream(self, amt=2 ** 16, decode_content=None):
        @classmethod
        def from_httplib(ResponseCls, r, **response_kw):
        def getheaders(self):
        def getheader(self, name, default=None):
        def info(self):
        def close(self):
        @property
        def closed(self):
        def fileno(self):
        def flush(self):
        def readable(self):
        def readinto(self, b):
        def supports_chunked_reads(self):
        def _update_chunk_length(self):
        def _handle_chunk(self, amt):
        def read_chunked(self, amt=None, decode_content=None):
        def geturl(self):
        def __iter__(self):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _collections.py
    from __future__ import absolute_import
        from collections.abc import Mapping, MutableMapping
        from collections import Mapping, MutableMapping
        from threading import RLock
        class RLock:
            def __enter__(self):
            def __exit__(self, exc_type, exc_value, traceback):
    from collections import OrderedDict
    from .exceptions import InvalidHeader
    from .packages import six
    from .packages.six import iterkeys, itervalues
    class RecentlyUsedContainer(MutableMapping):
        def __init__(self, maxsize=10, dispose_func=None):
        def __getitem__(self, key):
        def __setitem__(self, key, value):
        def __delitem__(self, key):
        def __len__(self):
        def __iter__(self):
        def clear(self):
        def keys(self):
    class HTTPHeaderDict(MutableMapping):
        def __init__(self, headers=None, **kwargs):
        def __setitem__(self, key, val):
        def __getitem__(self, key):
        def __delitem__(self, key):
        def __contains__(self, key):
        def __eq__(self, other):
        def __ne__(self, other):
        def __len__(self):
        def __iter__(self):
        def pop(self, key, default=__marker):
        def discard(self, key):
        def add(self, key, val):
        def extend(self, *args, **kwargs):
        def getlist(self, key, default=__marker):
        def _prepare_for_method_change(self):
        def __repr__(self):
        def _copy_from(self, other):
        def copy(self):
        def iteritems(self):
        def itermerged(self):
        def items(self):
        @classmethod
        def from_httplib(cls, message):  # Python 2

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _version.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from __future__ import absolute_import
    import logging
    import warnings
    from logging import NullHandler
    from . import exceptions
    from ._version import __version__
    from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool, connection_from_url
    from .filepost import encode_multipart_formdata
    from .poolmanager import PoolManager, ProxyManager, proxy_from_url
    from .response import HTTPResponse
    from .util.request import make_headers
    from .util.retry import Retry
    from .util.timeout import Timeout
    from .util.url import get_host
        import urllib3_secure_extra  # type: ignore # noqa: F401
    def add_stderr_logger(level=logging.DEBUG):
    def disable_warnings(category=exceptions.HTTPWarning):

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\urllib3\contrib

  ðŸ“„ Ð¤Ð°Ð¹Ð»: appengine.py
        from pip._vendor.urllib3 import PoolManager
        from pip._vendor.urllib3.contrib.appengine import AppEngineManager, is_appengine_sandbox
    from __future__ import absolute_import
    import io
    import logging
    import warnings
    from ..exceptions import (
    from ..packages.six.moves.urllib.parse import urljoin
    from ..request import RequestMethods
    from ..response import HTTPResponse
    from ..util.retry import Retry
    from ..util.timeout import Timeout
    from . import _appengine_environ
        from google.appengine.api import urlfetch
    class AppEnginePlatformWarning(HTTPWarning):
    class AppEnginePlatformError(HTTPError):
    class AppEngineManager(RequestMethods):
        def __init__(
        def __enter__(self):
        def __exit__(self, exc_type, exc_val, exc_tb):
        def urlopen(
        def _urlfetch_response_to_http_response(self, urlfetch_resp, **response_kw):
        def _get_absolute_timeout(self, timeout):
        def _get_retries(self, retries, redirect):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: ntlmpool.py
    from __future__ import absolute_import
    import warnings
    from logging import getLogger
    from ntlm import ntlm
    from .. import HTTPSConnectionPool
    from ..packages.six.moves.http_client import HTTPSConnection
    class NTLMConnectionPool(HTTPSConnectionPool):
        def __init__(self, user, pw, authurl, *args, **kwargs):
        def _new_conn(self):
        def urlopen(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: pyopenssl.py
            import pip._vendor.urllib3.contrib.pyopenssl as pyopenssl
    from __future__ import absolute_import
    import OpenSSL.crypto
    import OpenSSL.SSL
    from cryptography import x509
    from cryptography.hazmat.backends.openssl import backend as openssl_backend
        from cryptography.x509 import UnsupportedExtension
        class UnsupportedExtension(Exception):
    from io import BytesIO
    from socket import error as SocketError
    from socket import timeout
        from socket import _fileobject
        from ..packages.backports.makefile import backport_makefile
    import logging
    import ssl
    import sys
    import warnings
    from .. import util
    from ..packages import six
    from ..util.ssl_ import PROTOCOL_TLS_CLIENT
    HAS_SNI = True
    SSL_WRITE_BLOCKSIZE = 16384
    def inject_into_urllib3():
    def extract_from_urllib3():
    def _validate_dependencies_met():
        from cryptography.x509.extensions import Extensions
        from OpenSSL.crypto import X509
    def _dnsname_to_stdlib(name):
        from ASCII bytes. We need to idna-encode that string to get it back, and
        def idna_encode(name):
            from pip._vendor import idna
    def get_subj_alt_name(peer_cert):
    class WrappedSocket(object):
        def __init__(self, connection, socket, suppress_ragged_eofs=True):
        def fileno(self):
        def _decref_socketios(self):
        def recv(self, *args, **kwargs):
        def recv_into(self, *args, **kwargs):
        def settimeout(self, timeout):
        def _send_until_done(self, data):
        def sendall(self, data):
        def shutdown(self):
        def close(self):
        def getpeercert(self, binary_form=False):
        def version(self):
        def _reuse(self):
        def _drop(self):
        def makefile(self, mode, bufsize=-1):
    class PyOpenSSLContext(object):
        def __init__(self, protocol):
        @property
        def options(self):
        @options.setter
        def options(self, value):
        @property
        def verify_mode(self):
        @verify_mode.setter
        def verify_mode(self, value):
        def set_default_verify_paths(self):
        def set_ciphers(self, ciphers):
        def load_verify_locations(self, cafile=None, capath=None, cadata=None):
        def load_cert_chain(self, certfile, keyfile=None, password=None):
        def set_alpn_protocols(self, protocols):
        def wrap_socket(
    def _verify_callback(cnx, x509, err_no, err_depth, return_code):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: securetransport.py
        import pip._vendor.urllib3.contrib.securetransport as securetransport
    from __future__ import absolute_import
    import contextlib
    import ctypes
    import errno
    import os.path
    import shutil
    import socket
    import ssl
    import struct
    import threading
    import weakref
    from .. import util
    from ..packages import six
    from ..util.ssl_ import PROTOCOL_TLS_CLIENT
    from ._securetransport.bindings import CoreFoundation, Security, SecurityConst
    from ._securetransport.low_level import (
        from socket import _fileobject
        from ..packages.backports.makefile import backport_makefile
    HAS_SNI = True
    SSL_WRITE_BLOCKSIZE = 16384
    CIPHER_SUITES = [
    def inject_into_urllib3():
    def extract_from_urllib3():
    def _read_callback(connection_id, data_buffer, data_length_pointer):
    def _write_callback(connection_id, data_buffer, data_length_pointer):
    class WrappedSocket(object):
        def __init__(self, socket):
        @contextlib.contextmanager
        def _raise_on_error(self):
        def _set_ciphers(self):
        def _set_alpn_protocols(self, protocols):
        def _custom_validate(self, verify, trust_bundle):
        def _evaluate_trust(self, trust_bundle):
        def handshake(
        def fileno(self):
        def _decref_socketios(self):
        def recv(self, bufsiz):
        def recv_into(self, buffer, nbytes=None):
        def settimeout(self, timeout):
        def gettimeout(self):
        def send(self, data):
        def sendall(self, data):
        def shutdown(self):
        def close(self):
        def getpeercert(self, binary_form=False):
        def version(self):
        def _reuse(self):
        def _drop(self):
        def makefile(self, mode, bufsize=-1):
        def makefile(self, mode="r", buffering=None, *args, **kwargs):
    class SecureTransportContext(object):
        def __init__(self, protocol):
        @property
        def check_hostname(self):
        @check_hostname.setter
        def check_hostname(self, value):
        @property
        def options(self):
        @options.setter
        def options(self, value):
        @property
        def verify_mode(self):
        @verify_mode.setter
        def verify_mode(self, value):
        def set_default_verify_paths(self):
        def load_default_certs(self):
        def set_ciphers(self, ciphers):
        def load_verify_locations(self, cafile=None, capath=None, cadata=None):
        def load_cert_chain(self, certfile, keyfile=None, password=None):
        def set_alpn_protocols(self, protocols):
        def wrap_socket(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: socks.py
    from __future__ import absolute_import
        import socks
        import warnings
        from ..exceptions import DependencyWarning
    from socket import error as SocketError
    from socket import timeout as SocketTimeout
    from ..connection import HTTPConnection, HTTPSConnection
    from ..connectionpool import HTTPConnectionPool, HTTPSConnectionPool
    from ..exceptions import ConnectTimeoutError, NewConnectionError
    from ..poolmanager import PoolManager
    from ..util.url import parse_url
        import ssl
    class SOCKSConnection(HTTPConnection):
        def __init__(self, *args, **kwargs):
        def _new_conn(self):
    class SOCKSHTTPSConnection(SOCKSConnection, HTTPSConnection):
    class SOCKSHTTPConnectionPool(HTTPConnectionPool):
    class SOCKSHTTPSConnectionPool(HTTPSConnectionPool):
    class SOCKSProxyManager(PoolManager):
        def __init__(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: _appengine_environ.py
    import os
    def is_appengine():
    def is_appengine_sandbox():
    def is_local_appengine():
    def is_prod_appengine():
    def is_prod_appengine_mvms():

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\urllib3\contrib\_securetransport

  ðŸ“„ Ð¤Ð°Ð¹Ð»: bindings.py
    from __future__ import absolute_import
    import platform
    from ctypes import (
    from ctypes.util import find_library
    from ...packages.six import raise_from
    def load_cdll(name, macos10_16_path):
    class CFConst(object):
    class SecurityConst(object):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: low_level.py
    import base64
    import ctypes
    import itertools
    import os
    import re
    import ssl
    import struct
    import tempfile
    from .bindings import CFConst, CoreFoundation, Security
    _PEM_CERTS_RE = re.compile(
    def _cf_data_from_bytes(bytestring):
    def _cf_dictionary_from_tuples(tuples):
    def _cfstr(py_bstr):
    def _create_cfstring_array(lst):
    def _cf_string_to_unicode(value):
    def _assert_no_error(error, exception_class=None):
    def _cert_array_from_pem(pem_bundle):
    def _is_cert(item):
    def _is_identity(item):
    def _temporary_keychain():
    def _load_items_from_file(keychain, path):
    def _load_client_cert_chain(keychain, *paths):
    TLS_PROTOCOL_VERSIONS = {
    def _build_tls_unknown_ca_alert(version):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\urllib3\packages

  ðŸ“„ Ð¤Ð°Ð¹Ð»: six.py
    from __future__ import absolute_import
    import functools
    import itertools
    import operator
    import sys
    import types
        MAXSIZE = sys.maxsize
            MAXSIZE = int((1 << 31) - 1)
            class X(object):
                def __len__(self):
                MAXSIZE = int((1 << 31) - 1)
                MAXSIZE = int((1 << 63) - 1)
        from importlib.util import spec_from_loader
    def _add_doc(func, doc):
    def _import_module(name):
    class _LazyDescr(object):
        def __init__(self, name):
        def __get__(self, obj, tp):
    class MovedModule(_LazyDescr):
        def __init__(self, name, old, new=None):
        def _resolve(self):
        def __getattr__(self, attr):
    class _LazyModule(types.ModuleType):
        def __init__(self, name):
        def __dir__(self):
    class MovedAttribute(_LazyDescr):
        def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
        def _resolve(self):
    class _SixMetaPathImporter(object):
        def __init__(self, six_module_name):
        def _add_module(self, mod, *fullnames):
        def _get_module(self, fullname):
        def find_module(self, fullname, path=None):
        def find_spec(self, fullname, path, target=None):
        def __get_module(self, fullname):
        def load_module(self, fullname):
        def is_package(self, fullname):
        def get_code(self, fullname):
        def create_module(self, spec):
        def exec_module(self, module):
    class _MovedItems(_LazyModule):
    class Module_six_moves_urllib_parse(_LazyModule):
    class Module_six_moves_urllib_error(_LazyModule):
    class Module_six_moves_urllib_request(_LazyModule):
    class Module_six_moves_urllib_response(_LazyModule):
    class Module_six_moves_urllib_robotparser(_LazyModule):
    class Module_six_moves_urllib(types.ModuleType):
        def __dir__(self):
    def add_move(move):
    def remove_move(name):
        def advance_iterator(it):
        def callable(obj):
        def get_unbound_function(unbound):
        def create_unbound_method(func, cls):
        def get_unbound_function(unbound):
        def create_bound_method(func, obj):
        def create_unbound_method(func, cls):
        class Iterator(object):
            def next(self):
        def iterkeys(d, **kw):
        def itervalues(d, **kw):
        def iteritems(d, **kw):
        def iterlists(d, **kw):
        def iterkeys(d, **kw):
        def itervalues(d, **kw):
        def iteritems(d, **kw):
        def iterlists(d, **kw):
        def b(s):
        def u(s):
        import struct
        import io
        def b(s):
        def u(s):
        def byte2int(bs):
        def indexbytes(buf, i):
        import StringIO
    def assertCountEqual(self, *args, **kwargs):
    def assertRaisesRegex(self, *args, **kwargs):
    def assertRegex(self, *args, **kwargs):
    def assertNotRegex(self, *args, **kwargs):
        def reraise(tp, value, tb=None):
        def exec_(_code_, _globs_=None, _locs_=None):
        def raise_from(value, from_value):
        def print_(*args, **kwargs):
            def write(data):
        def print_(*args, **kwargs):
        def _update_wrapper(
        def wraps(
    def with_metaclass(meta, *bases):
        class metaclass(type):
            def __new__(cls, name, this_bases, d):
            @classmethod
            def __prepare__(cls, name, this_bases):
    def add_metaclass(metaclass):
        def wrapper(cls):
    def ensure_binary(s, encoding="utf-8", errors="strict"):
    def ensure_str(s, encoding="utf-8", errors="strict"):
    def ensure_text(s, encoding="utf-8", errors="strict"):
    def python_2_unicode_compatible(klass):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\urllib3\packages\backports

  ðŸ“„ Ð¤Ð°Ð¹Ð»: makefile.py
    import io
    from socket import SocketIO
    def backport_makefile(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: weakref_finalize.py
    from __future__ import absolute_import
    import itertools
    import sys
    from weakref import ref
    class weakref_finalize(object):
        class _Info(object):
        def __init__(self, obj, func, *args, **kwargs):
                import atexit
        def __call__(self, _=None):
        def detach(self):
        def peek(self):
        @property
        def alive(self):
        @property
        def atexit(self):
        @atexit.setter
        def atexit(self, value):
        def __repr__(self):
        @classmethod
        def _select_for_exit(cls):
            L = [(f, i) for (f, i) in cls._registry.items() if i.atexit]
        @classmethod
        def _exitfunc(cls):
                    import gc

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    âš ï¸ ÐÐµÑ‚ ÑÑ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ð½Ñ‹Ñ… ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² (import/class/def/const)

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip\_vendor\urllib3\util

  ðŸ“„ Ð¤Ð°Ð¹Ð»: connection.py
    from __future__ import absolute_import
    import socket
    from ..contrib import _appengine_environ
    from ..exceptions import LocationParseError
    from ..packages import six
    from .wait import NoWayToWaitForSocketError, wait_for_read
    def is_connection_dropped(conn):  # Platform-specific
    def create_connection(
    def _set_socket_options(sock, options):
    def allowed_gai_family():
    def _has_ipv6(host):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: proxy.py
    from .ssl_ import create_urllib3_context, resolve_cert_reqs, resolve_ssl_version
    def connection_requires_http_tunnel(
    def create_proxy_ssl_context(

  ðŸ“„ Ð¤Ð°Ð¹Ð»: queue.py
    import collections
    from ..packages import six
    from ..packages.six.moves import queue
        import Queue as _unused_module_Queue  # noqa: F401
    class LifoQueue(queue.Queue):
        def _init(self, _):
        def _qsize(self, len=len):
        def _put(self, item):
        def _get(self):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: request.py
    from __future__ import absolute_import
    from base64 import b64encode
    from ..exceptions import UnrewindableBodyError
    from ..packages.six import b, integer_types
    SKIP_HEADER = "@@@SKIP_HEADER@@@"
    SKIPPABLE_HEADERS = frozenset(["accept-encoding", "host", "user-agent"])
    ACCEPT_ENCODING = "gzip,deflate"
    _FAILEDTELL = object()
    def make_headers(
    def set_file_position(body, pos):
    def rewind_body(body, body_pos):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: response.py
    from __future__ import absolute_import
    from email.errors import MultipartInvariantViolationDefect, StartBoundaryNotFoundDefect
    from ..exceptions import HeaderParsingError
    from ..packages.six.moves import http_client as httplib
    def is_fp_closed(obj):
    def assert_header_parsing(headers):
    def is_response_to_head(response):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: retry.py
    from __future__ import absolute_import
    import email
    import logging
    import re
    import time
    import warnings
    from collections import namedtuple
    from itertools import takewhile
    from ..exceptions import (
    from ..packages import six
    class _RetryMeta(type):
        @property
        def DEFAULT_METHOD_WHITELIST(cls):
        @DEFAULT_METHOD_WHITELIST.setter
        def DEFAULT_METHOD_WHITELIST(cls, value):
        @property
        def DEFAULT_REDIRECT_HEADERS_BLACKLIST(cls):
        @DEFAULT_REDIRECT_HEADERS_BLACKLIST.setter
        def DEFAULT_REDIRECT_HEADERS_BLACKLIST(cls, value):
        @property
        def BACKOFF_MAX(cls):
        @BACKOFF_MAX.setter
        def BACKOFF_MAX(cls, value):
    @six.add_metaclass(_RetryMeta)
    class Retry(object):
        DEFAULT_ALLOWED_METHODS = frozenset(
        RETRY_AFTER_STATUS_CODES = frozenset([413, 429, 503])
        DEFAULT_REMOVE_HEADERS_ON_REDIRECT = frozenset(
        DEFAULT_BACKOFF_MAX = 120
        def __init__(
        def new(self, **kw):
        @classmethod
        def from_int(cls, retries, redirect=True, default=None):
        def get_backoff_time(self):
        def parse_retry_after(self, retry_after):
        def get_retry_after(self, response):
        def sleep_for_retry(self, response=None):
        def _sleep_backoff(self):
        def sleep(self, response=None):
        def _is_connection_error(self, err):
        def _is_read_error(self, err):
        def _is_method_retryable(self, method):
        def is_retry(self, method, status_code, has_retry_after=False):
        def is_exhausted(self):
        def increment(
        def __repr__(self):
        def __getattr__(self, item):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: ssltransport.py
    import io
    import socket
    import ssl
    from ..exceptions import ProxySchemeUnsupported
    from ..packages import six
    SSL_BLOCKSIZE = 16384
    class SSLTransport:
        @staticmethod
        def _validate_ssl_context_for_tls_in_tls(ssl_context):
        def __init__(
        def __enter__(self):
        def __exit__(self, *_):
        def fileno(self):
        def read(self, len=1024, buffer=None):
        def recv(self, len=1024, flags=0):
        def recv_into(self, buffer, nbytes=None, flags=0):
        def sendall(self, data, flags=0):
        def send(self, data, flags=0):
        def makefile(
        def unwrap(self):
        def close(self):
        def getpeercert(self, binary_form=False):
        def version(self):
        def cipher(self):
        def selected_alpn_protocol(self):
        def selected_npn_protocol(self):
        def shared_ciphers(self):
        def compression(self):
        def settimeout(self, value):
        def gettimeout(self):
        def _decref_socketios(self):
        def _wrap_ssl_read(self, len, buffer=None):
        def _ssl_io_loop(self, func, *args):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: ssl_.py
    from __future__ import absolute_import
    import hashlib
    import hmac
    import os
    import sys
    import warnings
    from binascii import hexlify, unhexlify
    from ..exceptions import (
    from ..packages import six
    from .url import BRACELESS_IPV6_ADDRZ_RE, IPV4_RE
    HAS_SNI = False
    IS_PYOPENSSL = False
    IS_SECURETRANSPORT = False
    ALPN_PROTOCOLS = ["http/1.1"]
    HASHFUNC_MAP = {
    def _const_compare_digest_backport(a, b):
        import ssl
        from ssl import CERT_REQUIRED, wrap_socket
        from ssl import HAS_SNI  # Has SNI?
        from .ssltransport import SSLTransport
        from ssl import PROTOCOL_TLS
            from ssl import PROTOCOL_SSLv23 as PROTOCOL_TLS
        from ssl import PROTOCOL_TLS_CLIENT
        PROTOCOL_TLS_CLIENT = PROTOCOL_TLS
        from ssl import OP_NO_COMPRESSION, OP_NO_SSLv2, OP_NO_SSLv3
        OP_NO_COMPRESSION = 0x20000
        from ssl import OP_NO_TICKET
        OP_NO_TICKET = 0x4000
    DEFAULT_CIPHERS = ":".join(
        from ssl import SSLContext  # Modern SSL?
        class SSLContext(object):  # Platform-specific: Python 2
            def __init__(self, protocol_version):
            def load_cert_chain(self, certfile, keyfile):
            def load_verify_locations(self, cafile=None, capath=None, cadata=None):
            def set_ciphers(self, cipher_suite):
            def wrap_socket(self, socket, server_hostname=None, server_side=False):
    def assert_fingerprint(cert, fingerprint):
    def resolve_cert_reqs(candidate):
    def resolve_ssl_version(candidate):
    def create_urllib3_context(
            from pip._vendor.urllib3.util import ssl_
        def disable_check_hostname():
    def ssl_wrap_socket(
    def is_ipaddress(hostname):
    def _is_key_file_encrypted(key_file):
    def _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname=None):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: ssl_match_hostname.py
    import re
    import sys
        import ipaddress
    class CertificateError(ValueError):
    def _dnsname_match(dn, hostname, max_wildcards=1):
    def _to_unicode(obj):
    def _ipaddress_match(ipname, host_ip):
    def match_hostname(cert, hostname):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: timeout.py
    from __future__ import absolute_import
    import time
    from socket import _GLOBAL_DEFAULT_TIMEOUT, getdefaulttimeout
    from ..exceptions import TimeoutStateError
    class Timeout(object):
        DEFAULT_TIMEOUT = _GLOBAL_DEFAULT_TIMEOUT
        def __init__(self, total=None, connect=_Default, read=_Default):
        def __repr__(self):
        @classmethod
        def resolve_default_timeout(cls, timeout):
        @classmethod
        def _validate_timeout(cls, value, name):
        @classmethod
        def from_float(cls, timeout):
        def clone(self):
        def start_connect(self):
        def get_connect_duration(self):
        @property
        def connect_timeout(self):
        @property
        def read_timeout(self):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: url.py
    from __future__ import absolute_import
    import re
    from collections import namedtuple
    from ..exceptions import LocationParseError
    from ..packages import six
    NORMALIZABLE_SCHEMES = ("http", "https", None)
    PERCENT_RE = re.compile(r"%[a-fA-F0-9]{2}")
    SCHEME_RE = re.compile(r"^(?:[a-zA-Z][a-zA-Z0-9+-]*:|/)")
    URI_RE = re.compile(
    HEX_PAT = "[0-9A-Fa-f]{1,4}"
    UNRESERVED_PAT = r"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789._\-~"
    ZONE_ID_PAT = "(?:%25|%)(?:[" + UNRESERVED_PAT + "]|%[a-fA-F0-9]{2})+"
    REG_NAME_PAT = r"(?:[^\[\]%:/?#]|%[a-fA-F0-9]{2})*"
    TARGET_RE = re.compile(r"^(/[^?#]*)(?:\?([^#]*))?(?:#.*)?$")
    ZONE_ID_RE = re.compile("(" + ZONE_ID_PAT + r")\]$")
    _HOST_PORT_PAT = ("^(%s|%s|%s)(?::0*?(|0|[1-9][0-9]{0,4}))?$") % (
    _HOST_PORT_RE = re.compile(_HOST_PORT_PAT, re.UNICODE | re.DOTALL)
    UNRESERVED_CHARS = set(
    SUB_DELIM_CHARS = set("!$&'()*+,;=")
    USERINFO_CHARS = UNRESERVED_CHARS | SUB_DELIM_CHARS | {":"}
    PATH_CHARS = USERINFO_CHARS | {"@", "/"}
    QUERY_CHARS = FRAGMENT_CHARS = PATH_CHARS | {"?"}
    class Url(namedtuple("Url", url_attrs)):
        def __new__(
        @property
        def hostname(self):
        @property
        def request_uri(self):
        @property
        def netloc(self):
        @property
        def url(self):
        def __str__(self):
    def split_first(s, delims):
    def _encode_invalid_chars(component, allowed_chars, encoding="utf-8"):
    def _remove_path_dot_segments(path):
    def _normalize_host(host, scheme):
    def _idna_encode(name):
                from pip._vendor import idna
    def _encode_target(target):
    def parse_url(url):
        def ensure_type(x):
    def get_host(url):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: wait.py
    import errno
    import select
    import sys
    from functools import partial
        from time import monotonic
        from time import time as monotonic
    class NoWayToWaitForSocketError(Exception):
        def _retry_on_intr(fn, timeout):
        def _retry_on_intr(fn, timeout):
    def select_wait_for_socket(sock, read=False, write=False, timeout=None):
    def poll_wait_for_socket(sock, read=False, write=False, timeout=None):
        def do_poll(t):
    def null_wait_for_socket(*args, **kwargs):
    def _have_working_poll():
    def wait_for_socket(*args, **kwargs):
    def wait_for_read(sock, timeout=None):
    def wait_for_write(sock, timeout=None):

  ðŸ“„ Ð¤Ð°Ð¹Ð»: __init__.py
    from __future__ import absolute_import
    from .connection import is_connection_dropped
    from .request import SKIP_HEADER, SKIPPABLE_HEADERS, make_headers
    from .response import is_fp_closed
    from .retry import Retry
    from .ssl_ import (
    from .timeout import Timeout, current_time
    from .url import Url, get_host, parse_url, split_first
    from .wait import wait_for_read, wait_for_write

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\pip-25.0.1.dist-info

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Lib\site-packages\__pycache__

ðŸ“ ÐŸÐ°Ð¿ÐºÐ°: .venv\Scripts

  ðŸ“„ Ð¤Ð°Ð¹Ð»: activate_this.py
    import runpy
    from __future__ import annotations
    import os
    import site
    import sys